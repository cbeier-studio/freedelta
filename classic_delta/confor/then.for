      SUBROUTINE HENNTI (ITM, ISBND, LIDAT, ITYPC, IMC, NSTAT, KSTAT,       THEN
     * WTC, IWORK, NC, ISTAT, MS, IMI, JI, IVARIT)
 
C* REVISED 7-SEP-93.
C  OUTPUTS AN ITEM IN HENNIG FORMAT.
 
C  ITM RECEIVES THE ITEM.
C  ISBND RECEIVES THE KEY STATE BOUNDARIES.
C  LIDAT RECEIVES THE DIMENSION OF ITM AND ISBND.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  IMC RECEIVES THE CHARACTER MASK.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  KSTAT RECEIVES THE NUMBERS OF KEY STATES.
C  WTC RECEIVES THE CHARACTER WEIGHTS.
C  IWORK RECEIVES WORKING SPACE OF LENGTH NC.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  ISTAT IS WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C  IMI RECEIVES THE ITEM MASK.
C  JI RECEIVES THE ITEM NUMBER.
C  IVARIT RECEIVES -1 WHEN ALL ITEMS ARE PROCESSED.
 
C  PROCEDURE FOR DETERMINING HENNIG VALUES (SAME AS FOR PAUP).
C    1. NUMERIC CHARACTERS WITHOUT KEY STATES ARE EXCLUDED.
C    2. ONLY `NORMAL' VALUES OF NUMERIC CHARACTERS ARE USED. EXTREME VALUES
C       ARE IGNORED.
C    3. KEY STATES ARE APPLIED. ALL NUMERIC CHARACTERS ARE SUBSEQUENTLY TREATED
C       AS ORDERED MULTISTATE.
C    4. IF A `USE MEAN VALUES' DIRECTIVE IS IN FORCE, MULTIPLE VALUES OF ORDERED
C       MULTISTATE CHARACTERS (INCLUDING FORMER NUMERIC CHARACTERS) ARE REPLACED
C       BY THEIR MEAN.
C    5. IF ONLY ONE STATE VALUE IS PRESENT, THAT VALUE IS OUTPUT.
C    6. IF ALL POSSIBLE STATE VALUES ARE PRESENT, OR IF MORE THAN ONE VALUE IS
C       PRESENT AND `TREAT VARIABLE AS UNKNOWN' HAS BEEN SPECIFIED, THEN ?
C       IS OUTPUT.
C       OTHERWISE -
C    7. FOR ORDERED MULTISTATE CHARACTERS (INCLUDING FORMER NUMERICS)
C       A SINGLE VALUE IS OBTAINED AS IN STEP 4.
C    8. FOR UNORDERED MULTISTATES, A SINGLE VALUE IS OBTAINED FROM THE ORIGINAL
C       DATA (BEFORE THE APPLICATION OF KEY STATES) BY SELECTING THE FIRST VALUE
C       CODED, UNLESS `USE LAST VALUE CODED' HAS BEEN SPECIFIED, WHEN THE LAST
C       VALUE IS SELECTED. KEY STATES ARE THEN APPLIED IF SPECIFIED.
C    9. THE VALUE IS OUTPUT.
 
      DIMENSION ITM(LIDAT),ISBND(LIDAT),
     * ITYPC(NC),IMC(NC),NSTAT(NC),KSTAT(NC),WTC(NC),IWORK(NC),
     * ISTAT(MS),IMI(JI)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /HEDXXX/ LHEAD,IHEAD(200)
      COMMON /ITSXXX/ ITSS
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
      COMMON /LUFXXX/ FNAME(19),LFNAME(19)
        CHARACTER FNAME*80
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /MISXXX/ IMPVAL,IPACH,IPCHN,IPUNC,IRAB,IKEYCH,ICMPRS,
     * ITUNC,ITINAP,ITIMPL,IUNVAR,LNKC,IDEPC,LICDEP,IPSUMM,ICHSEQ,
     * ITMSEQ,INSRVA,IFATT,ITINTR,ICMAND,IUNRNG,IOMTOR,NEWFLS,IRSEMI,
     * IOMSTC,IADDCH,IEMPCH,IVARUN,ISCALC,ICNOTE,ICIMGE,ITIMGE,MTIMGE,
     * NTIMGE,IOMNSC,IOMCMT,IOMLOW,IERRPC,IERRAB,ICHNSE,NUMST0,IUMEAN,
     * NADNAM,NEMNAM,NODELO,IOMUSP,ICKYIMG,ITKYIMG,ISUPIMG,ICTIMGE,
     * ICTNAME,IHTML,IRTF,MTHEAD,NTHEAD,ITMHDGS,LCDNAM,MTFILE,NTFILE,
     * ITMFILS,MXHEAD,NXHEAD,IDXHDGS,INSIMGFN,ICOFILE,IUCC,IOUNC,ITLINK,
     * MTLINK,NTLINK,NAUTOCC,IOUTSUBJ
      COMMON /NUMXXX/ KNUM(10),KDEC,KMINUS
      COMMON /SCRNMX/ SCRNAM(7)
        CHARACTER*8 SCRNAM
      COMMON /SCRXXX/ LUNTS1,LUNTS2,LUNTS3,LUNTS4,LUNTS5,LUNTS6,LUNTS7
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
 
C     LOCAL ARRAYS.
      DIMENSION ITSF(3),IBF(132)
      CHARACTER FSPEC*30,XREAD*5,PROC*7,CCODE*7,QUOTE*1
      SAVE MITEM,LA,UA,LZ,UZ,I0,I9,IUNDSC
 
      PARAMETER(XREAD='xread',PROC='proc / ',CCODE='ccode [',
     * QUOTE='''')
 
      IF (IVARIT.LT.0)  GOTO 1100
      IF (JI.GT.1)  GOTO 10
 
      MITEM = 0
      LUNTYP = 4
 
C-    OPEN SCRATCH FILE FOR MATRIX.
      CALL GETAU (L)
      FSPEC = SCRNAM(1)
      CALL SETLUN (FSPEC, L, LUNTS1)
      CALL UOPEN (L, LUNUSE(L), FSPEC, IDUMMY, IERR)
      IF (IERR.NE.0)  CALL MESSB (20, 1, 1, -1, 0)

C     OUTPUT PRELIMINARIES.
      CALL COPSIA (XREAD, IOUT(1, LUNTYP), 5)
      CALL WRTREC (IOUT(1,LUNTYP), 5, LUNTYP, 4)
 
C     HEADING.
      CALL SENSIM (IHEAD(2), LHEAD, IBF, LPUDEF-2, 1, L, 0, 0)
      KQUOTE = ICHAR(QUOTE)
C     TRANSFER HEADING TO OUTPUT BUFFER DISCARDING ANY QUOTES.
      IOUT(1,LUNTYP) = KQUOTE
      DO I = 1, L
        IF (IBF(I).NE.KQUOTE)  IOUT(I+1,LUNTYP) = IBF(I)
      ENDDO
      IOUT(L+2,LUNTYP) = KQUOTE
      CALL WRTREC (IOUT(1,LUNTYP), L+2, LUNTYP, 4)
 
      LA = ICHAR('a')
      UA = ICHAR('A')
      LZ = ICHAR('z')
      UZ = ICHAR('Z')
      I0 = ICHAR('0')
      I9 = ICHAR('9')
      IUNDSC = ICHAR('_')
 
   10 IF (IMI(JI).EQ.0)  GOTO 2000
      MITEM = MITEM + 1
 
C     EXTRACT ITEM NAME.
      LUNTYP = LUNTS1
      CALL SENSIM (ITM(NC+2), LIDAT, IOUT(1,LUNTYP), LPUDEF, 1, L, 0, 0)
C     REMOVE ANY NON-ALPHANUMERIC CHARACTERS FROM ITEM NAMES.
C     REPLACE BLANKS IN ITEM NAME WITH UNDERSCORES.
      J = 0
      DO I = 1,L
        IC = IOUT(I, LUNTYP)
        IF (IC.EQ.KBLANK)  THEN
          K = IUNDSC
        ELSEIF ((IC.GE.LA.AND.IC.LE.LZ) .OR.
     *          (IC.GE.UA.AND.IC.LE.UZ) .OR.
     *          (IC.GE.I0.AND.IC.LE.I9))  THEN
          K = IC
        ELSE
          K = 0
        ENDIF
        IF (K.GT.0)  THEN
          J = J + 1
          IOUT(J, LUNTYP) = K
        ENDIF
      ENDDO
      CALL WRTREC (IOUT(1,LUNTYP), J, LUNTYP, 4)
      JBF = 0
 
C--   OUTPUT ATTRIBUTES.
 
      CALL SETIA (IWORK, NC, 1)
      DO 1000 IC = 1, NC
        IF (IMC(IC).EQ.0)  GOTO 1000
        JBF = JBF + 1
        IF (ITM(IC).LE.0)  GO TO 510
        JTYPC = IABS(ITYPC(IC))
 
C       APPLY KEY STATES.
        CALL FNDKST (ITM, ISBND, IC, LIDAT, ITYPC, KSTAT, IWORK, NC,
     *   1, ISTAT, MS, ITSF, JI, 0.0, 0.0)
        KNS = KSTAT(IC)
        NZ = NONZER (ISTAT, KNS)
        IF (NZ.EQ.1)  THEN
          DO IS = 1, KNS
            IF (ISTAT(IS).NE.0)  THEN
              IOUT(JBF,LUNTYP) = KNUM(IS)
              GOTO 600
            ENDIF
          ENDDO
        ELSEIF (NZ.GT.1)  THEN
          IF (JTYPC.GE.2.AND.IUMEAN.NE.0) GOTO 100
          IF (NZ.EQ.KNS)  GOTO 510
C         TREAT VARIABLE AS UNKNOWN.
          IF (IVARUN.NE.0)  GOTO 510
          IF (JTYPC.GE.2)  GOTO 100
          GOTO 200
        ELSE
          GOTO 510
        ENDIF
 
C       USE MEAN VALUES.
  100   VAL = 0.0
        N = 0
        DO I = 1, KNS
          IF (ISTAT(I).NE.0)  THEN
            VAL = VAL + I
            N = N + 1
          ENDIF
        ENDDO
        VAL = VAL/N
        IS = INT((VAL + 0.49))
        IOUT(JBF,LUNTYP) = KNUM(IS)
        GOTO 600
 
C-      UNORDERED MULTISTATE.
        
  200   JG = ITM(IC)
        JGN = JG + ITM(JG)
        JSG = JG + 1
 
C       FIND FIRST VALUE CODED.
        IF (IFATT.NE.0)  THEN
  255     IF (JSG.GE.JGN)  GOTO 510
          IF (ITM(JSG+1).NE.0)  GOTO 260
            JSG = JSG + ITM(JSG)
            GOTO 255
  260     IVAL = ITM(JSG+2)
      
        ELSE
C       FIND LAST VALUE CODED.
      
          LSTJSG = 0
  265     IF (JSG.GE.JGN)  GOTO 270
          IF (ITM(JSG+1).NE.0)  LSTJSG = JSG
            JSG = JSG + ITM(JSG)
            GOTO 265
  270     IF (LSTJSG.EQ.0)  GOTO 510
          JSG = LSTJSG
          IVAL = ITM(JSG+ITM(JSG)-1)
        ENDIF
        ITS = ITM(JSG+1)
        IF (ITS.GT.ITSS)  GOTO 510
 
C       APPLY KEY STATES, IF SPECIFIED.
        IF (ISBND(IC).NE.0)  THEN
C         DETERMINE KEY STATE. USE FIRST KEY STATE FOUND.
          IS = 0
          NS = KSTAT(IC)
          NG = ISBND(IC)
          NSG = NG + 1
          NGN = NG + ISBND(NG)
        
C         SCAN GROUPS OF KEY STATES.
  280     IF (NSG.GE.NGN)  GO TO 290
            IS = IS + 1
            ITS = ISBND(NSG+1)
            NB = NSG + 2
            NE = NSG + ISBND(NSG) - 1
        
            DO N = NB, NE
              IF (IVAL.EQ.ISBND(N))  GOTO 285
            ENDDO
            NSG = NSG + ISBND(NSG)
            GO TO 280
        ELSE
          IS = IVAL
        ENDIF

  285   IOUT(JBF,LUNTYP) = KNUM(IS)
        GOTO 600
  290   IOUT(JBF,LUNTYP) = KQUEST
        GOTO 600

C       UNKNOWN OR NOT APPLICABLE.
  510   IOUT(JBF,LUNTYP) = KQUEST
 
  600   IF (JBF.GE.LPUDEF)  THEN
           CALL WRTREC (IOUT(1,LUNTYP), JBF, LUNTYP, 4)
           JBF = 0
        ENDIF
 
 1000   CONTINUE
 
      IF (JBF.GT.0)  CALL WRTREC (IOUT(1,LUNTYP), JBF, LUNTYP, 4)
      RETURN
 
C     END OF ITEMS, COMPLETE OUTPUT.
C     NUMBERS OF CHARACTERS AND ITEMS.
 1100 LUNTYP = 4
      MCHAR = NONZER(IMC,NC)
      CALL INKOD (MCHAR, IOUT(1,LUNTYP), N1, LPUDEF)
      N1 = N1 + 1
      IOUT(N1,LUNTYP) = KBLANK
      CALL INKOD (MITEM, IOUT(N1+1,LUNTYP), N2, LPUDEF-N1)
      CALL WRTREC(IOUT(1,LUNTYP), N1+N2, LUNTYP, 4)
 
      REWIND LUNS1
      LUNREC(LUNS1) = 0
 1200 CALL RREC (IOUT(1,4), LPUDEF, LUNS1, LREC)
C     *  FNAME(LUNS1), LFNAME(LUNS1), LUNREC(LUNS1))
        IF (LREC.LT.0)  GOTO 1250
        LUNREC(LUNS1) = LUNREC(LUNS1) + 1
        IF (LREC.EQ.0)  GOTO 1210
        CALL WRTREC (IOUT(1,4), LREC, 4, 4)
 1210 GOTO 1200
 1250 CONTINUE
      CLOSE (UNIT=LUNS1, STATUS='DELETE')
C     MARK END OF DATA.
      CALL WRTREC (KSEMIC, 1, LUNTYP, 4)
 
C     OUTPUT CHARACTER RELIABILITIES.
C     (NOTE. CHARACTERS ARE NUMBERED FROM ZERO.)
      CALL COPSIA (CCODE, IOUT(1, LUNTYP), 7)
      JOUT = 7
      IB = -1
      IEND = 0
      IFIRST = 1
      ICM = 0
      DO 1260 IC = 1, NC+1
        IF (IC.GT.NC)  THEN
          IF (IB.LT.0)  GOTO 1260
          IEND = 1
        ELSE
          IF (IMC(IC).EQ.0)  GOTO 1260
          ICM = ICM + 1
          IWORK(ICM) = 0
          IF (WTC(IC).GT.0)  THEN
            REL = MAX(0.,MIN(10.,5.+1.45*ALOG(WTC(IC))))
            IWORK(ICM) = INT (REL*10.0 + 0.49)
          ENDIF
        ENDIF
        IF (IB.LT.0)  THEN
          IB = ICM - 1
          IE = ICM - 1
          IREL = IWORK(ICM)
        ELSE
          IF (IWORK(ICM).NE.IREL.OR.IEND.NE.0)  THEN
            JBF = 0
            IF (IFIRST.NE.0)  THEN
              IFIRST = 0
            ELSE
              JBF = JBF + 1
              IBF(JBF) = KBLANK
            ENDIF
            JBF = JBF+1
            IBF(JBF) = KSOL
            CALL INKOD (IREL, IBF(JBF+1), N, LPUDEF-JBF)
            JBF = JBF + N + 1
            IBF(JBF) = KBLANK
            CALL INKOD (IB, IBF(JBF+1), N, LPUDEF-JBF)
            JBF = JBF + N
            IF (IB.NE.IE)  THEN
              JBF = JBF + 1
              IBF(JBF) = KSTOP
              CALL INKOD (IE, IBF(JBF+1), N, LPUDEF-JBF)
              JBF = JBF + N
            ENDIF
            IF (JOUT+JBF.GT.LPUDEF)  THEN
              CALL WRTREC (IOUT(1,LUNTYP), JOUT, 4, 4)
              JOUT = 0
            ENDIF
            CALL COPIA (IBF, IOUT(JOUT+1,LUNTYP), JBF)
            JOUT = JOUT + JBF
            IB = ICM - 1
            IE = ICM - 1
            IREL = IWORK(ICM)
          ELSE
            IE = ICM - 1
          ENDIF
        ENDIF
 1260 CONTINUE
      IF (JOUT+1.GT.LPUDEF)  THEN
        CALL WRTREC (IOUT(1,LUNTYP), JOUT, 4, 4)
        JOUT = 0
      ENDIF
      JOUT = JOUT + 1
      IOUT(JOUT,LUNTYP) = KSEMIC
      CALL WRTREC (IOUT(1,LUNTYP), JOUT, 4, 4)

C     DEFINE WHETHER CHARACTERS ARE ADDITIVE OR NON-ADDITIVE.
C     (NOTE. CHARACTERS ARE NUMBERED FROM ZERO.)
      CALL COPSIA (CCODE, IOUT(1, LUNTYP), 6)
      JOUT = 6
      IB = -1
      IEND = 0
      IFIRST = 1
      ICM = 0
      DO 1270 IC = 1, NC+1
        IF (IC.GT.NC)  THEN
          IF (IB.LT.0)  GOTO 1270
          IEND = 1
        ELSE
          IF (IMC(IC).EQ.0)  GOTO 1270
          ICM = ICM + 1
          JTYPC = IABS(ITYPC(IC))
          IF (JTYPC.EQ.1)  THEN
            IWORK(ICM) = -1
          ELSE IF (JTYPC.GE.2.AND.JTYPC.LE.4)  THEN
            IWORK(ICM) = 1
          ELSE
            IWORK(ICM) = 0
          ENDIF
        ENDIF
        IF (IB.LT.0)  THEN
          IB = ICM - 1
          IE = ICM - 1
          IADD = IWORK(ICM)
        ELSE
          IF (IWORK(ICM).NE.IADD.OR.IEND.NE.0)  THEN
            IF (IADD.EQ.0)  THEN
              GOTO 1265
            ELSEIF (IADD.LT.0)  THEN
              ICOUT = KMINUS
            ELSE
              ICOUT = KDPLUS
            ENDIF
            JBF = 0
            IF (IFIRST.NE.0)  THEN
              IFIRST = 0
            ELSE
              JBF = JBF + 1
              IBF(JBF) = KBLANK
            ENDIF
            JBF = JBF + 1
            IBF(JBF) = ICOUT
            CALL INKOD (IB, IBF(JBF+1), N, LPUDEF-JBF)
            JBF = JBF + N
            IF (IB.NE.IE)  THEN
              JBF = JBF + 1
              IBF(JBF) = KSTOP
              CALL INKOD (IE, IBF(JBF+1), N, LPUDEF-JBF)
              JBF = JBF + N
            ENDIF
            IF (JOUT+JBF.GT.LPUDEF)  THEN
              CALL WRTREC (IOUT(1,LUNTYP), JOUT, 4, 4)
              JOUT = 0
            ENDIF
            CALL COPIA (IBF, IOUT(JOUT+1,LUNTYP), JBF)
            JOUT = JOUT + JBF
 1265       IB = ICM - 1
            IE = ICM - 1
            IADD = IWORK(ICM)
          ELSE
            IE = ICM - 1
          ENDIF
        ENDIF
 1270 CONTINUE
      IF (JOUT+1.GT.LPUDEF)  THEN
        CALL WRTREC (IOUT(1,LUNTYP), JOUT, 4, 4)
        JOUT = 0
      ENDIF
      JOUT = JOUT + 1
      IOUT(JOUT,LUNTYP) = KSEMIC
      CALL WRTREC (IOUT(1,LUNTYP), JOUT, 4, 4)

C     TRANSFER CONTROL TO USER VIA 'proc' DIRECTIVE.
      CALL COPSIA (PROC, IOUT(1,LUNTYP), 7)
      IOUT(8,LUNTYP) = KSEMIC
      CALL WRTREC (IOUT(1,LUNTYP), 8, LUNTYP, 4)
 
 2000 RETURN
      END
