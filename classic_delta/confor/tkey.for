      SUBROUTINE KEYCHA (ITYPC, NSTAT, KSTAT, ICDES, LCDES, ICADDR, NC,     TKEY
     * IKEYCH, KCOM, IAS, MS, ISBND, IDAT, LIDAT, ICSTR, LCSTR, IC)
 
C* REVISED 3-AUG-92.
C* OUTPUTS A CHARACTER DESCRIPTION IN KEY FORMAT.
 
C  2/10/86. BACKSPACE OVER BLANK CHARACTER AT END OF NUMERIC STATES.
 
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  KSTAT RECEIVES THE NUMBERS OF KEY STATES.
C  ICDES RECEIVES THE STARTING POSITIONS OF THE CHARACTER DESCRIPTIONS.
C  LCDES RECEIVES THE LENGTHS OF THE CHARACTER DESCRIPTIONS.
C  ICADDR RECEIVES WORKING SPACE OF LENGTH NC.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  IKEYCH RECEIVES WHETHER THIS IS A KEY CHARACTER LIST.
C  KCOM RECEIVES THE COMMA CHARACTER TO BE USED TO SEPARATE STATE DESCRIPTIONS.
C  IAS RECEIVES WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C  ISBND RECEIVES THE NEW STATE BOUNDARIES.
C  IDAT RECEIVES WORKING SPACE OF LENGTH LIDAT.
C  LIDAT RECEIVES THE DATA BUFFER LENGTH.
C  ICSTR. IF ISTYPE.EQ.1, ICSTR RECEIVES THE CHARACTER DESCRIPTIONS.
C    IF ISTYPE.NE.1, ICSTR IS WORKING SPACE. SEE SUBR. FETCHC.
C  LCSTR RECEIVES THE DIMENSION OF ICSTR.
C  IC RECEIVES THE CHARACTER NUMBER.
 
      DIMENSION ITYPC(NC),NSTAT(NC), KSTAT(NC),
     * ICDES(NC),LCDES(NC),ICADDR(NC),IAS(MS),
     * ISBND(LIDAT),IDAT(LIDAT),
     * ICSTR(LCSTR)
C
      COMMON /BLKXXX/ KBLANK
      COMMON /LUNDAX/ LRECDA,IRECDA
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
 
C---  GET CHARACTER DESCRIPTION.
      CALL FETCHC (ICSTR, LCSTR, ICDES, LCDES, NC, IC, IAC, IAS, MS)
C
      JTYPC = IABS(ITYPC(IC))
      NS = KSTAT(IC)
C
C---  FEATURE.
      JB = NS + 1
      LL = LIDAT - (NS + 1)
      CALL SENSIM (ICSTR(IAC), LCSTR, IDAT(JB+1), LL, 0, LBF, 0, 0)
      JB = JB + LBF
      LL = LL - LBF
      IDAT(1) = LBF
      IF (NS.LE.1)  GO TO 520
C
C---  STATES.
      JSG = ISBND(IC) + 1
C
      DO 500 JS = 1, NS
        IF (ISBND(IC).GT.0.AND.IKEYCH.EQ.0)  GO TO 200
C
C--     ORIGINAL STATES.
        I = IAS(JS)
        CALL SENSIM (ICSTR(I), LCSTR, IDAT(JB+1), LL, 1, LBF, 0, 0)
        JB = JB + LBF
        LL = LL - LBF
        IDAT(JS+1) = LBF
        GO TO 500
C
C--     NEW STATES.
  200   NB = JSG + 2
        NE = JSG + ISBND(JSG) - 1
        ITS = ISBND(JSG+1)
        JBB = JB
        IF (JTYPC.GE.3)  GO TO 300
C
C-      MULTISTATE.
        DO 230 J = NB, NE
          IS = ISBND(J)
          I = IAS(IS)
          CALL SENSIM (ICSTR(I), LCSTR, IDAT(JB+1), LL, 1, LBF, 0, 0)
          JB = JB + LBF
          LL = LL - LBF
          IF (J.EQ.NE)  GO TO 230
          IF (JTYPC.EQ.2) THEN
            IWD = 2
          ELSE
            CALL OUTWRD (KCOM, IDAT, LIDAT, JB, LL)
            IWD = 1
          ENDIF
          CALL OUTSYM (KBLANK, IDAT, JB, LL)
          CALL OUTWRD (IWD, IDAT, LIDAT, JB, LL)
  230     CONTINUE
        GO TO 400
C
C-      NUMERIC.
  300   IF (NSTAT(IC).EQ.1)  I1 = IAS(1)
        IF (JTYPC.EQ.4)  GO TO 310
        VMIN = ISBND(NB)
        VMAX = ISBND(NE)
        GO TO 320
  310   VMIN = RELIN (ISBND(NB))
        VMAX = RELIN (ISBND(NE))
C
 320    IF (NE.GT.NB)  GO TO 340
C       ONE VALUE.
        IF (JS.EQ.1.AND.ITS.EQ.3)  CALL OUTWRD (12, IDAT, LIDAT, JB, LL)
        CALL OUTNUM (VMIN, IDAT, JB, LL, 1)
        IF (NSTAT(IC).EQ.1)  THEN
          CALL SENSIM (ICSTR(I1), LCSTR, IDAT(JB+1), LL, 1, LBF, 0, 0)
          JB = JB + LBF
          LL = LL - LBF
          CALL OUTSYM (KBLANK, IDAT, JB, LL)
        ENDIF
        IF (JS.EQ.NS.AND.ITS.EQ.3)
     *   CALL OUTWRD (13, IDAT, LIDAT, JB, LL)
        GO TO 390
C
C       MORE THAN ONE VALUE.
  340   CALL OUTNUM (VMIN, IDAT, JB, LL, 1)
        CALL OUTWRD (2, IDAT, LIDAT, JB, LL)
        CALL OUTNUM (VMAX, IDAT, JB, LL, 1)
        IF (NSTAT(IC).EQ.1)  THEN
          CALL SENSIM (ICSTR(I1), LCSTR, IDAT(JB+1), LL, 1, LBF, 0, 0)
          JB = JB + LBF
          LL = LL - LBF
          CALL OUTSYM (KBLANK, IDAT, JB, LL)
        ENDIF
  390   JB = JB - 1
C--
  400   IF (ISBND(IC).GT.0)  JSG = JSG + ISBND(JSG)
        IDAT(JS+1) = JB - JBB
 
  500   CONTINUE
C---
C-
  520 NL = NS + 1
      IF (NS.LE.1)  NL = 1
      ICADDR(IC) = IRECDA + 1
      CALL WRCSTR (IDAT, JB, NL, LUNDA, LRECDA, IRECDA)
C
      RETURN
      END
      SUBROUTINE KEYDEP (ISBND, ICDEP, KCDEP, LIDAT, NSTAT, KSTAT,          TKEY
     * ITYPC, NC, LDEP)
 
C  REVISED 27/11/86.
C  TRANSFORMS DEPENDENCY ARRAY FOR KEY STATES.
 
C  ISBND RECEIVES THE KEY STATES.
C  ICDEP RECEIVES THE ORIGINAL DEPENDENCIES.
C  KCDEP RETURNS THE NEW DEPENDENCIES.
C  LIDAT RECEIVES THE LENGTH OF ISBND, ICDEP, KCDEP.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  KSTAT RECEIVES THE NUMBERS OF KEY STATES.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  LDEP RETURNS THE LENGTH OF KCDEP UTILISED.
 
      DIMENSION ISBND(LIDAT),ICDEP(LIDAT),KCDEP(LIDAT),NSTAT(NC),
     * KSTAT(NC),ITYPC(NC)
 
C     LENGTH OF NEW DEPENDENCY ARRAY.
      LDEP = NC
 
      DO 500 IC = 1, NC
        KCDEP(IC) = 0
        IF (ICDEP(IC).EQ.0)  GOTO 500
        KCDEP(IC) = LDEP + 1
        ICDPTR = ICDEP(IC)
        JTYPC = IABS(ITYPC(IC))
        NS = NSTAT(IC)
        KS = KSTAT(IC)
 
        IF (ISBND(IC).LE.0)  THEN
 
C         COPY ORIGINAL DEPENDENCIES TO NEW ARRAY.
          NXT = LDEP + NS
          DO 100 IS = 1, NS
            LDEP = LDEP + 1
            IF (ICDEP(ICDPTR+IS-1).EQ.0)  THEN
              KCDEP(LDEP) = 0
            ELSE
              ICNTRL = ICDEP(ICDPTR+IS-1)
              NR = ICDEP(ICNTRL)
              KCDEP(LDEP) = NXT + 1
              CALL COPIA (ICDEP(ICNTRL), KCDEP(NXT+1), NR*2+1)
              NXT = NXT + NR*2 + 1
            ENDIF
  100       CONTINUE
 
        ELSE
 
C         NEW STATES.
          NXT = LDEP + KS
          DO 110 IS = 1, KS
            KCDEP(LDEP+IS) = 0
  110       CONTINUE
 
          NG = ISBND(IC)
          NSG = NG + 1
          NGN = NG + ISBND(NG)
          IS = 0
 
  120     IF (NSG.GE.NGN)  GOTO 490
            IS = IS + 1
            NUMRNG = 0
            ISTART = NXT + 1
            INC = 2
            ITS = ISBND(NSG+1)
            NB = NSG + 2
            NE = NSG + ISBND(NSG) - 1
            IF (JTYPC.EQ.1)  THEN
 
C             UNORDERED MULTISTATE.
              DO 150 N = NB, NE
                DO 130 I = 1, NS
                  IF (ICDEP(ICDPTR+I-1).EQ.0)  GOTO 130
                  IF (I.NE.ISBND(N))  GOTO 130
                  ICNTRL = ICDEP(ICDPTR+I-1)
                  NR = ICDEP(ICNTRL)
                  NUMRNG = NUMRNG + NR
                  CALL COPIA (ICDEP(ICNTRL+1), KCDEP(NXT+INC), 2*NR)
                  NXT = NXT + 2*NR + INC - 1
                  INC = 1
  130             CONTINUE
  150           CONTINUE
 
            ELSE
 
C             ORDERED MULTISTATE.
              DO 200 I = 1, NS
                IF (ICDEP(ICDPTR+I-1).EQ.0)  GOTO 200
                IF (ITS.EQ.3)  THEN
C                 OPEN-ENDED RANGE.
                  IF (.NOT. ( (I.LE.ISBND(NE).OR.I.EQ.NS) .AND.
     *                      (ISBND(NE).LE.I.OR.I.EQ.1)))  GOTO 200
                ELSE
                  IF (.NOT. (I.LE.ISBND(NE).AND.ISBND(NB).LE.I))
     *              GOTO 200
                ENDIF
                ICNTRL = ICDEP(ICDPTR+I-1)
                NR = ICDEP(ICNTRL)
                NUMRNG = NUMRNG + NR
                CALL COPIA (ICDEP(ICNTRL+1), KCDEP(NXT+INC), 2*NR)
                NXT = NXT + 2*NR + INC - 1
                INC = 1
  200           CONTINUE
 
            ENDIF
 
            IF (NUMRNG.GT.0)  THEN
              KCDEP(LDEP+IS) = ISTART
              KCDEP(ISTART) = NUMRNG
            ENDIF
 
            NSG = NSG + ISBND(NSG)
            GOTO 120
 
        ENDIF
 
  490   LDEP = NXT
 
  500   CONTINUE
 
      RETURN
      END
      SUBROUTINE KEYI (ITM, LIDAT, IDAT, LTAXON, MI, JI,                    TKEY
     * KSTAT, NC, KMNS)
C
C* REVISED 19-JUN-97.
C* OUTPUTS KEY ITEM.
C
C  ITM RECEIVES THE SIMPLIFIED ITEM (SEE SUBR. RDITEM AND KEYSIM).
C  LIDAT RECEIVES THE LENGTH OF ITM.
C  IDAT RECEIVES WORKING SPACE OF LENGTH LIDAT.
C  LTAXON RETURNS THE LENGTHS OF THE TAXON NAMES.
C  MI RECEIVES THE MAXIMUM NUMBER OF ITEMS.
C  JI RECEIVES THE CURRENT ITEM NUMBER.
C  KSTAT RECEIVES THE NUMBERS OF KEY STATES.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  KMNS RECEIVES THE MAXIMUM NUMBER OF STATES ALLOWED BY 'KEY'.
C
      DIMENSION ITM(LIDAT),IDAT(LIDAT),LTAXON(MI),KSTAT(NC)
 
      COMMON /ITSXXX/ ITSS
      COMMON /LUNDAX/ LRECDA,IRECDA
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /WRDSIZ/ NBITS,NCHRWD
 
C-    NAME.
      CALL SENSIM (ITM(NC+2), LIDAT, IDAT, LIDAT, 1, L, 0, 0)
      LTAXON(JI) = L
      CALL WRCSTR (IDAT, L, 0, LUNDA, LRECDA, IRECDA)
C
C-    ATTRIBUTES.
      JBF = 1
      DO 100 IC = 1, NC
        IDAT(JBF) = 0
C       (NOTE THAT ITM(IC) HAS BEEN SET TO 0 IN KEYSIM FOR CHARACTERS
C       WITH KSTAT(IC).LE.1 OR KSTAT(IC).GT.KMNS.)
        IF (ITM(IC).LE.0) GOTO 99
        JG = ITM(IC)
        JSG = JG + 1
        JGN = JG + ITM(JG)
        ITS = ITM(JSG+1)
        IF (ITS.GT.ITSS) GOTO 50
        LS = JSG + 2
   20   IF (LS.GE.JGN) GOTO 99
          IS = ITM(LS)
          CALL SETBIT (IS, IDAT(JBF), NBITS)
          LS = LS + 1
        GOTO 20
C
   50   I = ITS - ITSS
        IF (I.EQ.1) THEN
          DO 52 J = 1, KSTAT(IC)
            CALL SETBIT (J, IDAT(JBF), NBITS)
   52     CONTINUE
        ELSEIF (I.EQ.3) THEN
          CALL SETBIT (KMNS+1, IDAT(JBF), NBITS)
        ENDIF
 
   99   JBF = JBF + 1
  100 CONTINUE
 
      JBF = JBF - 1
      CALL WRDAI (IDAT, JBF, LUNDA, LRECDA, IRECDA)
 
      RETURN
      END
      SUBROUTINE KEYSIM (IDAT, ITM, LIDAT, JITM, ITYPC, KSTAT,              TKEY
     * NORNG, PCERR, ABERR, NC, IUNRNG, IERRPC, IERRAB, ISTAT, MS,
     * KMNS, ISBND, JI, ICTNAME)
 
C  REVISED 23-JUN-97.
C  SIMPLIFIES AN ITEM FOR 'KEY' REQUIREMENTS.
 
C  IDAT RECEIVES THE ITEM DESCRIPTION AS READ BY SUBR. RDITEM.
C  ITM RETURNS THE SIMPLIFIED ITEM.
C    THE NAME IS NOT ALTERED. COMMENTS ARE REMOVED FROM ATTRIBUTES.
C    CHARACTERS WITH MORE THAN KMNS STATES ARE REPRESENTED AS MISSING.
C    NUMERICS ARE CONVERTED TO MULTISTATE.
C    MULTIPLE VALUES ARE COMBINED AS 1 SUBGROUP (I.E., REPRESENTED AS
C    INTERMEDIATES (FORMALLY)). CHARACTERS WITH ALL VALUES PRESENT
C    ARE REPRESENTED AS VARIABLE.
C  LIDAT RECEIVES THE LENGTH OF IDAT AND ITM.
C  JITM RETURNS THE LOCATION OF THE LAST ELEMENT OF ITM IN USE.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  KSTAT RECEIVES THE NUMBERS OF KEY STATES.
C  NORNG RECEIVES WHERE TO USE NORMAL CHARACTER RANGES.
C  PCERR RECEIVES PERCENTAGE ERROR VALUES FOR REAL NUMERIC CHARACTERS.
C  ABERR RECEIVES ABSOLUTE ERROR VALUES FOR REAL NUMERIC CHARACTERS.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  IUNRNG RECEIVES WHETHER TO USE NORMAL CHARACTER RANGES.
C  IERRPC RECEIVES WHETHER TO USE PERCENT ERRORS.
C  IERRAB RECEIVES WHETHER TO USE ABSOLUTE ERRORS.
C  ISTAT IS WORKING SPACE.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C  KMNS RECEIVES THE MAXIMUM NUMBER OF KEY STATES ALLOWED.
C  ISBND RECEIVES THE NEW STATES (SEE SUBR. SBOUND).
C  JI RECEIVES THE ITEM NUMBER.
C  ICTNAME RECEIVES THE CHARACTER FOR TAXON NAME
 
      DIMENSION IDAT(LIDAT),ITM(LIDAT),ITYPC(NC),KSTAT(NC),
     * NORNG(NC),PCERR(NC),ABERR(NC),ISTAT(MS),ISBND(LIDAT),ITSF(3)
 
      COMMON /ITSXXX/ ITSS
 
C--   COPY NAME.
      IALTNAME = 0
C     Is there an alternate name specified in "CHARACTER FOR TAXON NAME"?
      IF (ICTNAME.NE.0.AND.IDAT(ICTNAME).NE.0) THEN
        JG = IDAT(ICTNAME)
        JSG = JG + 1
C       CHECK THAT THERE IS SOMETHING THERE
        IF (JSG.LT.JG+IDAT(JG)) THEN
          IB = JSG + 2
          L = IDAT(JSG) - 2
C         IGNORE ANGLE BRACKETS, THUS REDUCING LENGTH BY 2.
          IB = IB + 1
          L = L - 2
          IF (L.GT.0) IALTNAME = 1
        ENDIF
      ENDIF
      IF (IALTNAME.NE.0) THEN
C       TOTAL LENGTH OF GROUP
        ITM(NC+2) = IDAT(JG) - 2
C       TOTAL LENGTH OF SUB-GROUP
        ITM(NC+2+1) = IDAT(JSG) - 2
C       TYPE OF SUB-GROUP
        ITM(NC+2+2) = 1
C       COPY TEXT, OMITTING LEADING AND TRAILING ANGLE BRACKETS
        CALL COPIA (IDAT(IB), ITM(NC+2+3), L)
      ELSE
        CALL COPIA (IDAT(NC+2), ITM(NC+2), IDAT(NC+2))
      ENDIF
      JITM = NC + 1 + ITM(NC+2)
C
C--   SIMPLIFY ATTRIBUTES.
      DO 500 IC = 1, NC
        NS = KSTAT(IC)
        IF (IDAT(IC).LE.0 .OR. NS.LE.1 .OR. NS.GT.KMNS)  GO TO 390            =*
        IF (JITM+3+NS.GT.LIDAT)  CALL MESSB (35, LIDAT, 1, -1, 0)
        JGI = JITM + 1
C
C-      SET UP START OF ATTRIBUTE.
        ITM(IC) = JGI
        JSGI = JGI + 1
        JITM = JSGI + 1
        JG = IDAT(IC)
        JSG = JG + 1
        IF (ISBND(IC).NE.0 .OR.
     *   IDAT(JG).NE.4 .OR. IDAT(JSG+1).NE.1)  GO TO 100
C
C-      SIMPLE, NON-NUMERIC ATTRIBUTE (CODED SEPARATELY FOR EFFICIENCY).
        ITM(JSGI+1) = 1
        JITM = JITM + 1
        ITM(JITM) = IDAT(JSG+2)
        GO TO 400
C
C-      COMPOUND, PSEUDO OR NUMERIC ATTRIBUTE.
  100   IF (IERRPC.NE.0)  THEN
          PCTERR = PCERR(IC)
        ELSE
          PCTERR = 0.
        ENDIF
        IF (IERRAB.NE.0)  THEN
          ABSERR = ABERR(IC)
        ELSE
          ABSERR = 0.
        ENDIF
        CALL FNDKST (IDAT, ISBND, IC, LIDAT, ITYPC, KSTAT, NORNG, NC,
     *   IUNRNG, ISTAT, MS, ITSF, JI, PCTERR, ABSERR)
C
C       CHECK FOR PSEUDOVALUES.
        ITSMAX = 0
        DO 110 I = 1, 3
          IF (ITSF(I).NE.0)  ITSMAX = I + ITSS
  110     CONTINUE
        IF (ITSMAX.LE.0)  GO TO 320
C
C       STORE PSEUDOVALUE.
        ITM(JSGI+1) = ITSMAX
        GO TO 400
C
C       STORE ORDINARY VALUES.
  320   ITM(JSGI+1) = 1
        LSGI = 0
        DO 340 I = 1, NS
          IF (ISTAT(I).EQ.0)  GO TO 340
          LSGI = LSGI + 1
          JITM = JITM + 1
          ITM(JITM) = I
  340     CONTINUE
        IF (LSGI.EQ.0)  GO TO 390
        IF (LSGI.GE.NS)  GOTO 350
        ITM(JSGI+1) = 1
        GO TO 400
C
C       ALL ORDINARY VALUES PRESENT. STORE AS VARIABLE.
  350   ITM(JSGI+1) = ITSS + 1
        JITM = JSGI + 1
        GO TO 400
  390   ITM(IC) = 0
        GO TO 500
  400   ITM(JSGI) = JITM - JSGI + 1
        ITM(JGI) = JITM - JGI + 1
  500 CONTINUE
C--
      ITM(NC+1) = JITM - NC
      RETURN
      END
      SUBROUTINE KEYTC (ITYPC, NSTAT, KSTAT, IALTC, ICDES, LCDES,           TKEY
     * IWORK, NC, IKEYCH, MM1S, MS, ISBND, IDAT, LIDAT,
     * ICSTR, LCSTR)
 
C* REVISED 3-AUG-92.
C* OUTPUTS CHARACTER LIST IN KEY FORMAT.
C
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  KSTAT RECEIVES THE NUMBERS OF KEY STATES.
C  IALTC RECEIVES WHETHER TO USE THE ALTERNATE COMMA CHARACTER.
C  ICDES RECEIVES THE STARTING POSITIONS OF THE CHARACTER DESCRIPTIONS.
C  LCDES RECEIVES THE LENGTHS OF THE CHARACTER DESCRIPTIONS.
C  IWORK RECEIVES WORKING SPACE OF LENGTH NC.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  IKEYCH RECEIVES WHETHER A KEY CHARACTER LIST IS BEING USED.
C  MM1S RECEIVES WORDING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C  ISBND RECEIVES THE NEW STATE BOUNDARIES.
C  IDAT RECEIVES WORKING SPACE OF LENGTH LIDAT.
C  LIDAT RECEIVES THE DATA BUFFER LENGTH.
C  ICSTR. IF ISTYPE.EQ.1, ICSTR RECEIVES THE CHARACTER DESCRIPTIONS.
C    IF ISTYPE.NE.1, ICSTR IS WORKING SPACE. SEE SUBR. FETCHC.
C  LCSTR RECEIVES THE DIMENSION OF ICSTR.
 
      DIMENSION ITYPC(NC),NSTAT(NC),KSTAT(NC),IALTC(NC),
     * ICDES(NC),LCDES(NC),IWORK(NC),MM1S(MS),
     * ISBND(LIDAT),IDAT(LIDAT),ICSTR(LCSTR),IPARAM(3)
 
      COMMON /LUNDAX/ LRECDA,IRECDA
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /VLWXXX/ NVWD,MAXVWD,LVWD(18),IBPUNC,IEPUNC,
     * KVSTOP,KVCOM1,KVCOM2,KVSEMI,KVDEC
 
C     SET RECORD POINTER TO START OF DIRECT ACCESS OUTPUT FILE.
      IRECDA = 1
C
      IPARAM(1) = NC
C
C     WRITE NUMBERS OF STATES.
      IPARAM(2) = IRECDA + 1
      CALL WRDAI (KSTAT, NC, LUNDA, LRECDA, IRECDA)
C
      DO 100 IC = 1, NC
C       SET COMMA CHARACTER TO BE USED.
        IF (IALTC(IC).EQ.0)  THEN
          KCOM = KVCOM1
        ELSE
          KCOM = KVCOM2
        ENDIF
        CALL KEYCHA (ITYPC, NSTAT, KSTAT, ICDES, LCDES, IWORK, NC,
     *   IKEYCH, KCOM, MM1S, MS, ISBND, IDAT, LIDAT, ICSTR, LCSTR, IC)
  100   CONTINUE
C
C     WRITE CHARACTER ADDRESSES.
      IPARAM(3) = IRECDA + 1
      CALL WRDAI (IWORK, NC, LUNDA, LRECDA, IRECDA)
C
C     WRITE FIRST RECORD.
      IRECDA = 0
      CALL WRDAI (IPARAM, 3, LUNDA, LRECDA, IRECDA)
 
      RETURN
      END
      SUBROUTINE KEYTI (IDAT, ITM, LIDAT, LTAXON, WORKI, MI,                TKEY
     * ITYPC, IMC, NSTAT, KSTAT, NORNG, PCERR, ABERR, WTC, WORKC, NC,
     * ISTAT, MS, ICDEP, LICDEP, ISBND, IMI, WTI, JI, IUNRNG,
     * IERRPC, IERRAB, IVARIT, ICTNAME)
C
C  REVISED 23-MAR-92.
C  CONVERTS AN ITEM TO *KEY* FORMAT AND OUTPUTS IT.
C
C  IDAT RECEIVES THE ITEM.
C  ITM IS WORKING SPACE, USED FOR THE SIMPLIFIED CURRENT ITEM.
C  LIDAT RECEIVES THE LENGTH OF IDAT, ITM AND ISBND.
C  LTAXON RECEIVES INTEGER WORKING SPACE OF LENGTH MI.
C  WORKI RECEIVES REAL WORKING SPACE OF LENGTH MI.
C  MI RECEIVES THE MAXIMUM NUMBER OF ITEMS.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  IMC RECEIVES THE CHARACTER MASK.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  KSTAT RECEIVES THE NUMBERS OF KEY STATES.
C  NORNG RECEIVES WHERE TO USE NORMAL CHARACTER RANGES.
C  PCERR RECEIVES PERCENTAGE ERROR VALUES FOR REAL NUMERIC CHARACTERS.
C  ABERR RECEIVES ABSOLUTE ERROR VALUES FOR REAL NUMERIC CHARACTERS.
C  WTC RECEIVES THE CHARACTER WEIGHTS.
C  WORKC RECEIVES REAL WORKING SPACE OF LENGTH NC.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  ISTAT IS WORKING SPACE OF LENGTH MS.
C  MS IS THE MAXIMUM NUMBER OF STATES.
C  ICDEP RECEIVES THE CHARACTER DEPENDENCIES.
C  LICDEP RECEIVES THE LENGTH OF ICDEP.
C  ISBND RECEIVES THE KEY-STATE BOUNDARIES (SEE SUBR. SBOUND).
C  IMI RECEIVES THE ITEM MASK.
C  WTI RECEIVES THE ITEM WEIGHTS.
C  JI RECEIVES THE ITEM NUMBER.
C  IUNRNG RECEIVES WHETHER TO USE NORMAL CHARACTER RANGES.
C  IERRPC RECEIVES WHETHER TO USE PERCENT ERRORS.
C  IERRAB RECEIVES WHETHER TO USE ABSOLUTE ERRORS.
C  IVARIT RECEIVES 1 IF THE CURRENT ITEM IS A VARIANT, 0 IF A MAIN,
C   -1 IF NO MORE ITEMS.
C  ICTNAME RECEIVES THE CHARACTER FOR TAXON NAME
C
      DIMENSION IDAT(LIDAT),ITM(LIDAT),LTAXON(MI),WORKI(MI),
     * ITYPC(NC),IMC(NC),NSTAT(NC),KSTAT(NC),NORNG(NC),PCERR(NC),
     * ABERR(NC),WTC(NC),WORKC(NC),
     * ICDEP(LIDAT),ISTAT(MS),ISBND(LIDAT),IMI(JI),WTI(JI),IPARAM(11)
C
      COMMON /HEDXXX/ LHEAD,IHEAD(200)
      COMMON /LUNDAX/ LRECDA,IRECDA
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
 
      IF (IVARIT.LT.0)  GOTO 300
C
C     MAXIMUM NUMBER OF STATES FOR KEY.
      KMNS = 20                                                               =*
C
      IF (JI.GT.1)  GOTO 10
C
C     SET RECORD POINTER FOR DIRECT-ACCESS OUTPUT FILE.
      IRECDA = 1
C
C--   CURRENT ITEM.
   10 CALL KEYSIM (IDAT, ITM, LIDAT, JITM, ITYPC, KSTAT, NORNG,
     * PCERR, ABERR, NC, IUNRNG, IERRPC, IERRAB, ISTAT, MS, KMNS,
     * ISBND, JI, ICTNAME)
 
C
C--   OUTPUT ITEM.
      CALL KEYI (ITM, LIDAT, IDAT, LTAXON, MI, JI, KSTAT, NC, KMNS)
      GOTO 500
C
C     WRITE NUMBER OF ITEMS, HEADER, MASK, AND LENGTHS OF TAXON NAMES.
  300 IPARAM(1) = JI
      IPARAM(2) = NC
 
C     HEADER.
      IPARAM(4) = IRECDA + 1
      CALL SENSIM (IHEAD(2), LHEAD, ITM(2), LIDAT-1, 1, L, 0, 0)
      ITM(1) = L
      L = L + 1
      CALL WRCSTR (ITM, L, 1, LUNDA, LRECDA, IRECDA)
 
C     WRITE CHARACTER MASK.
      IPARAM(5) = IRECDA + 1
      CALL WRDAI (IMC, NC, LUNDA, LRECDA, IRECDA)
C
C     WRITE NUMBERS OF STATES.
      IPARAM(6) = IRECDA + 1
      CALL WRDAI (KSTAT, NC, LUNDA, LRECDA, IRECDA)
C
C     WRITE CHARACTER DEPENDENCIES.
      IPARAM(7) = IRECDA + 1
      IF (LICDEP.GT.0)  THEN
        CALL KEYDEP (ISBND, ICDEP, ITM, LIDAT, NSTAT, KSTAT, ITYPC,
     *   NC, LDEP)
        IF (LDEP.GT.NC)  THEN
          CALL WRDAI (ITM, LDEP, LUNDA, LRECDA, IRECDA)
          IPARAM(3) = LDEP
        ELSE
          CALL WRDAI (ICDEP, LICDEP, LUNDA, LRECDA, IRECDA)
          IPARAM(3) = LICDEP
        ENDIF
      ENDIF
C
C     WRITE CHARACTER RELIABILITIES.
      IPARAM(8) = IRECDA + 1
      DO 50 IC = 1, NC
        WORKC(IC) = 0
        IF (WTC(IC).LE.0)  GOTO 50
        WORKC(IC) = MAX(0.,MIN(10.,5.+1.45*ALOG(WTC(IC))))
   50   CONTINUE
      CALL WRDAR (WORKC, NC, LUNDA, LRECDA, IRECDA)
 
C     TAXON MASK.
      IPARAM(9) = IRECDA + 1
      CALL WRDAI (IMI, JI, LUNDA, LRECDA, IRECDA)
 
C     LENGTHS OF NAMES.
      IPARAM(10) = IRECDA + 1
      CALL WRDAI (LTAXON, JI, LUNDA, LRECDA, IRECDA)
 
C     ITEM ABUNDANCES.
      IPARAM(11) = IRECDA + 1
      DO 60 I = 1, JI
        WORKI(I) = 0
        IF (WTI(I).LE.0)  GOTO 60
        WORKI(I) = MAX(0.,MIN(10.,5.+1.45*ALOG(WTI(I))))
   60   CONTINUE
      CALL WRDAR (WORKI, JI, LUNDA, LRECDA, IRECDA)
 
C     WRITE PARAMETERS RECORD.
      IRECDA = 0
      CALL WRDAI (IPARAM, 11, LUNDA, LRECDA, IRECDA)
C
C     TERMINATE USE OF DIRECT-ACCESS FILE.
      LUNDA = -1
 
  500 RETURN
      END
