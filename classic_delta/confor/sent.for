      INTEGER FUNCTION HEX2DEC(N)
 
C  RETURNS THE DECIMAL VALUE OF A HEXADECIMAL DIGIT.
C  REVISED 07-JUN-99.
 
      DIMENSION IHVAL(16),IDVAL(16)
 
      DATA (IHVAL(I),I=1,16)/
     * 48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70/
 
      DATA (IDVAL(I),I=1,16)/
     * 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15/
 
      HEX2DEC = 0
 
      CALL CAP(N, ICAP)
 
      DO I = 1, 16
        IF (N.EQ.IHVAL(I)) THEN
          HEX2DEC = IDVAL(I)
          RETURN
        ENDIF
      ENDDO
 
      END
      FUNCTION ISNUM (ICHAR)                                                SENT
C
C* REVISED 18/6/84.
C* CHECKS TO SEE IF A CHARACTER IS NUMERIC.
C
C  ICHAR RECEIVES THE CHARACTER.
C  ISNUM RETURNS 0 IF NOT NUMERIC, 1 IF NUMERIC.
C
      COMMON /NUMXXX/ KNUM(10),KDEC,KMINUS
C
      ISNUM = 0
      DO 10 K = 1, 10
        IF (ICHAR.EQ.KNUM(K))  GO TO 20
   10   CONTINUE
      GO TO 30
C
   20 ISNUM = 1
C
   30 RETURN
      END
      FUNCTION   IDSENT(ISEN1, ISEN2, LSEN)                                 SENT
C
C* REVISED 4/9/78.
C* TESTS TWO SENTENCES FOR IDENTITY, APART FROM COMMENTS AND BLANKS.
C
C  THE FUNCTION RETURNS 1 IF THE SENTENCES ARE IDENTICAL, 0 OTHERWISE.
C  ISEN1 RECEIVES THE FIRST SENTENCE.
C  ISEN2 RECEIVES THE SECOND SENTENCE.
C  LSEN RECEIVES THE (MAXIMUM) LENGTH OF ISEN1 AND ISEN2.
C
      DIMENSION ISEN1(LSEN),ISEN2(LSEN)
C
      COMMON /BLKXXX/ KBLANK
C
      JS1 = 1
      JS2 = 1
C
   50 CONTINUE
   60   CALL KSENT (K1, JS1, ISEN1, LSEN, JSG1)
          IF (JS1.LE.0)  GO TO 80
          IF (K1.EQ.KBLANK)  GO TO 60
   80   CALL KSENT (K2, JS2, ISEN2, LSEN, JSG2)
          IF (JS2.LE.0)  GO TO 100
          IF (K2.EQ.KBLANK)  GO TO 80
  100   IF (K1.NE.K2)  GO TO 150
        IF (JS1.GT.0.OR.JS2.GT.0)  GO TO 50
C
      IDSENT = 1
      GO TO 200
  150 IDSENT = 0
C
  200 RETURN
      END
      SUBROUTINE JSTOTP (IBF, LBF, IE, ITYPMK, LIDAT, LUNTYP, INHTML,       SENT
     * IHTMBKT)
 
C* REVISED 08-JUN-99.
C* PRODUCES JUSTIFIED OUTPUT, OMITTING TYPESETTING INSTRUCTIONS, IF REQUIRED.
C
C  PARAMETERS AS FOR JSTOUT.
C
      DIMENSION IBF(LBF),ITYPMK(LIDAT)
C
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
      COMMON /WRKXXX/ IWRK(132)
C
      CHARACTER*4 TEMP
 
      IF (ITPSET.EQ.0)  GO TO 400
      IF (ITPSET.GT.0)  GO TO 200
C
C     Handle any special RTF characters.
      CALL PROCRTF (IBF, LBF, JBF, ITPSET)
 
      J = 0
      DO 100 I = 1, JBF
        IF (IGNOR(IBF(I)).NE.0)  GO TO 100
        J = J + 1
        IWRK(J) = IBF(I)
        IF (IWRK(J).NE.KBLANK)  GO TO 100
        CALL JSTOUT (IWRK, J, 0, LUNTYP, INHTML)
        J = 0
  100   CONTINUE
      GO TO 310
C
C     CHECK FOR "-" BETWEEN NUMERICS AND INSERT EN DASH.
C
  200 J = 0
      DO 300 I = 1, LBF
      IF (IBF(I).NE.KDRANG)  GO TO 250
        K = I - 1
  210   IF (K.LE.0)  GO TO 250
        IF (IBF(K).NE.KBLANK)  GO TO 220
          K = K - 1
          GO TO 210
C
  220   IF (ISNUM(IBF(K)).EQ.0)  GO TO 250
C
        K = I + 1
  230   IF (K.GT.LBF)  GO TO 250
        IF (IBF(K).NE.KBLANK)  GO TO 240
          K = K + 1
          GO TO 230
C
  240   IF (ISNUM(IBF(K)).EQ.0)  GO TO 250
        IF (J.GT.0)  CALL JSTOUT (IWRK, J, -1, LUNTYP, INHTML)
        J = 0
        CALL JSTTPS (1, ITYPMK, LIDAT, NTYPMK, LUNTYP)
        GO TO 300
C
C     Change angle brackets to HTML.
  250 IF (IHTMBKT.EQ.0)  GOTO 290
        IF (IBF(I).NE.KDLBRA.AND.IBF(I).NE.KDRBRA)  GOTO 290
        IF (J.GT.0)  CALL JSTOUT (IWRK, J, -1, LUNTYP, INHTML)
        IF (IBF(I).EQ.KDLBRA) THEN
          TEMP = '&lt;'
        ELSE IF (IBF(I).EQ.KDRBRA) THEN
          TEMP = '&gt;'
        ENDIF
        J = 0
        DO K = 1, 4
          J = J + 1
          IWRK(J) = ICHAR(TEMP(K:K))
        ENDDO
C       Output and prevent capitalization with last parameter to JSTOUT.
        CALL JSTOUT (IWRK, J, -1, LUNTYP, 1)
        J = 0
        GO TO 300
 
  290 J = J+1
      IWRK(J) = IBF(I)
      IF (IWRK(J).NE.KBLANK)  GO TO 300
      CALL JSTOUT (IWRK, J, -1, LUNTYP, INHTML)
      J = 0
C
  300 CONTINUE
C
  310 IF (J.GT.0)  CALL JSTOUT (IWRK, J, -1, LUNTYP, INHTML)
      IF (IE.GE.0)  CALL JSTOUT (KBLANK, 1, IE, LUNTYP, 0)
      GO TO 500
C
  400 CALL JSTOUT (IBF, LBF, IE, LUNTYP, INHTML)
C
  500 RETURN
      END
      SUBROUTINE JSTWD (NW, IE, ITYPMK, LIDAT, LUNTYP)                      SENT
C
C* REVISED 25-OCT-00.
C* OUTPUTS A WORD SELECTED FROM A VOCABULARY.
C
C  NW RECEIVES THE NUMBER OF THE WORD IN THE VOCABULARY.
C  IE RECEIVES A FLAG SPECIFYING THE ACTION AFTER OUTPUT.
C    NEGATIVE - LAST WORD LEFT UNFINISHED. 0 - LAST WORD FINISHED.
C    POSITIVE - LINE FINISHED, AND (IE-1) EXTRA BLANK LINES.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  LIDAT RECEIVES THE LENGTH OF ITYPMK.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT FOR OUTPUT.
C
      COMMON /VWDXXX/ VWORD(18)
        CHARACTER*40 VWORD
      COMMON /VLWXXX/ NVWD,MAXVWD,LVWD(18),IBPUNC,IEPUNC,
     * KVSTOP,KVCOM1,KVCOM2,KVSEMI,KVDEC
 
      DIMENSION ITYPMK(LIDAT),IWORD(40)                                                     =*
C
 
      IF (NW.LE.0.OR.NW.GT.NVWD)  CALL BUG (9, NW)
      L = LVWD(NW)
      IF (L.LE.0.OR.L.GT.MAXVWD)  RETURN
      DO 10 IL = 1, L
        IWORD(IL) = ICHAR (VWORD(NW)(IL:IL))
   10   CONTINUE
      CALL JSTOTP (IWORD, L, IE, ITYPMK, LIDAT, LUNTYP, 0, 0)
      RETURN
      END
      SUBROUTINE KSENT (K, JS, ISEN, LSEN, JSG)                             SENT
C
C* REVISED 13/9/78.
C* GETS THE NEXT SYMBOL FROM A SENTENCE, EXCLUDING COMMENTS.
C
C  K RETURNS THE SYMBOL.
C  JS RECEIVES AND RETURNS THE LOCATION OF THE LAST SYMBOL FETCHED.
C    JS MUST RECEIVE 1 AT THE FIRST CALL FOR A NEW SENTENCE. IF JS
C    RECEIVES 0, ITS VALUE IS UNCHANGED ON RETURN, AND K RETURNS BLANK.
C    IF JS RECEIVES A POSITIVE VALUE, IT RETURNS THE LOCATION OF THE
C    NEXT SYMBOL, AND THIS VALUE MUST NOT BE ALTERED BETWEEN CALLS
C    FOR THE SAME SENTENCE. WHEN THE END OF A SUBGROUP IS REACHED,
C    JS RETURNS 2, AND K RETURNS BLANK. WHEN THE END OF
C    THE SENTENCE IS REACHED, JS RETURNS 0 AND K RETURNS BLANK.
C  ISEN RECEIVES THE SENTENCE (SEE SUBR. SENTNC).
C  LSEN RECEIVES THE LENGTH OF THE SENTENCE.
C  JSG RETURNS THE STARTING POSITION OF THE CURRENT SUBGROUP. IT MUST
C    NOT BE ALTERED BETWEEN CALLS FOR THE SAME SENTENCE.
C
      DIMENSION ISEN(LSEN)
C
      COMMON /BLKXXX/ KBLANK
C
      IF (JS.GE.3)  GO TO 40
      IF (JS.EQ.2)  GO TO 20
      IF (JS.EQ.1)  GO TO 10
      GO TO 80
C
   10 JSG = 2
   20 IF (JS.GT.1)  JSG = JSG + ISEN(JSG)
        IF (JSG.GT.ISEN(1))  GO TO 80
        JS = JSG + 1
        IF (ISEN(JSG+1).EQ.0)  GO TO 20
C
   40 JS = JS + 1
      IF (JS.GE.JSG+ISEN(JSG))  GO TO 60
      K = ISEN(JS)
      GO TO 100
C
   60 JS = 2
      GO TO 90
   80 JS = 0
   90 K = KBLANK
C
  100 RETURN
      END
      SUBROUTINE LANGSEN (ISEN, LSEN, LLANG, LIDAT, IFMT)                   SENT
 
C  REVISED 02-JUL-01.
C  EXTRACTS THE SPECIFIED LANGUAGE FROM A SENTENCE.
 
C  ISEN RECEIVES THE INPUT SENTENCE.
C  LSEN RECEIVES THE DIMENSION OF ISEN.
C  LLANG RECEIVES THE DEFINED LANGUAGES.
C  LIDAT RECEIVES THE LENGTH OF LLANG.
C  IFMT RECEIVES THE SENTENCE FORMAT.
C   1=SENTENCE CONTAINS SUBGROUPS, AS IN A CHARACTER DESCRIPTION.
C   2=SENTENCE CONSISTS OF A SINGLE GROUP.
 
      DIMENSION ISEN(LSEN),LLANG(LIDAT),MATCH(2),LSTR(2)
      CHARACTER STR*55
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /LANGXX/ IUSELNG1,IUSELNG2,NLANG
      COMMON /TNAMEX/ TNAME,LTNAME
        CHARACTER*256 TNAME
 
C     KAT = @
      PARAMETER (KAT=64)
 
      IF (IFMT.EQ.0.OR.NLANG.EQ.0.OR.IUSELNG1.EQ.0) GOTO 100
 
C     FLAG WHICH OF SELECTED LANGUAGES ARE PRESENT.
      MATCH(1) = 0
      MATCH(2) = 0
 
C     FLAG WHETHER '@' OCCURS IN THE COMMENT.
      JAT = 0
 
C--   SCAN FOR LANGUAGES PRESENT.
      JEND = 1 + ISEN(1)
      IF (IFMT.EQ.1)  THEN
        JG = 2
      ELSE IF (IFMT.EQ.2)  THEN
        JG = 1
      ENDIF
    5 JGN = JG + ISEN(JG)
      JSG = JG + 1
   10 IF (JSG.GE.JEND)  GO TO 40
        JSGN = JSG + ISEN(JSG)
        IB = JSG + 2
        L = ISEN(JSG) - 2
        IE = IB + L - 1
        ITS = ISEN(JSG+1)

        DO I = IB, IE-1
          IF (ISEN(I).EQ.KAT.AND.ISEN(I+1).NE.KBLANK)  THEN
            JAT = 1
            IB = I
            IMATCH = 0
C           WHICH LANGUAGE IS THIS?
            DO 20 ILANG = 1, NLANG
              K = I
              IPTR = LLANG(ILANG)
              LEN = LLANG(ILANG+1) - IPTR
              DO J = 1, LEN
                IF (K+1.GT.IE.OR.(K+1.EQ.IE.AND.ISEN(K+1).EQ.KDRBRA))
     *            GOTO 20
                K = K + 1
                IF (ISEN(K).NE.LLANG(IPTR+J-1)) GOTO 20
              ENDDO
              IMATCH = 1
              IF (ILANG.EQ.IUSELNG1) THEN
                MATCH(1) = 1
              ELSEIF (ILANG.EQ.IUSELNG2) THEN
                MATCH(2) = 1
              ENDIF
   20       CONTINUE
            
C           REPORT INVALID LANGUAGE IDENTIFIER
            IF (IMATCH.EQ.0) THEN
              LDAT = 1
              DO J = IB+1, L
                IF (ISEN(J).EQ.KBLANK)  GOTO 30
                LDAT = LDAT + 1
                IF (LDAT.EQ.5)  GOTO 30
              ENDDO
   30         IF (LDAT.GT.0)  THEN  
                LSTR(1) = LTNAME
                STR(1:) = TNAME
                LSTR(2) = LDAT
                CALL COPIAS (ISEN(IB), STR(LTNAME+1:), LDAT)
                CALL MESSC (152, IDUM, 1, 3, 0, STR, LSTR, 2)
              ENDIF
            ENDIF
          ENDIF
        ENDDO

        JSG = JSGN
        IF (JSG.GE.JGN)  THEN
          JG = JSG
          GOTO 5
        ELSE
          GOTO 10
        ENDIF
 
C     NO LANGUAGE STRINGS PRESENT
   40 IF (JAT.EQ.0)  GOTO 100
 
C     SELECT LANGUAGE TO USE.
      IF (MATCH(1).NE.0) THEN
        IUSELANG = IUSELNG1
      ELSEIF (MATCH(2).NE.0) THEN
        IUSELANG = IUSELNG2
      ELSE
        IUSELANG = IUSELNG1
      ENDIF
 
      IPTR = LLANG(IUSELANG)
      LUSE = LLANG(IUSELANG+1) - IPTR
      INLANG = 0

      IF (IFMT.EQ.1)  THEN
        JG = 2
        KG = 2
      ELSE IF (IFMT.EQ.2)  THEN
        JG = 1
        KG = 1
      ENDIF
   45 JGN = JG + ISEN(JG)
      JSG = JG + 1
      KSG = KG + 1
   50 IF (JSG.GE.JEND)  GO TO 90
        JSGN = JSG + ISEN(JSG)
        IB = JSG + 2
        KB = KSG + 2
        JB = 0
        L = ISEN(JSG) - 2
        IE = IB + L - 1
        ITS = ISEN(JSG+1)

      I = IB
      DO WHILE (I.LE.IE)
        IF (ISEN(I).EQ.KAT) THEN
          IF (I.EQ.IE)  THEN
C           ASSUME IMPLICIT BLANK FOLLOWING @.
            INLANG = 0 
            GOTO 60
          ELSE IF (ISEN(I+1).EQ.KBLANK)  THEN
            I = I + 1
            INLANG = 0
            GOTO 60
          ELSE IF (I+LUSE.GT.IE) THEN
            GOTO 60
          ENDIF
C         IS THIS THE RIGHT LANGUAGE?
          DO J = 1, LUSE
            I = I + 1
            IF (ISEN(I).NE.LLANG(IPTR+J-1)) THEN
              INLANG = -1
              GOTO 60
            ENDIF
          ENDDO
          INLANG = 1
C         Remove leading blanks.
          I = I + 1
          DO WHILE (ISEN(I).EQ.KBLANK)
            I = I + 1
          ENDDO
   60     CONTINUE
        ELSEIF (INLANG.GE.0) THEN
          ISEN(KB+JB) = ISEN(I)
          JB = JB + 1
        ENDIF
        I = I + 1
      ENDDO
 
C     IF SOMETHING WAS COPIED
      IF (JB.GT.0)  THEN
C       Remove trailing blanks.
        DO WHILE (ISEN(KB+JB-1).EQ.KBLANK)
          JB = JB - 1
        ENDDO
        IF (JB.GT.0) THEN
          ISEN(KSG) = JB + 2
          ISEN(KSG+1) = ITS
          KSG = KSG + ISEN(KSG)
        ENDIF
      ENDIF
 
      JSG = JSGN
      IF (JSG.GE.JGN)  THEN
        JG = JSG
        ISEN(KG) = KSG - KG
        KG = KSG
        GOTO 45
      ELSE
        GOTO 50
      ENDIF

   90 CONTINUE
      IF (IFMT.EQ.1)  ISEN(1) = KSG - 1
 
  100 RETURN
      END
      SUBROUTINE OTPSEN (ISEN, JSEN, LSEN)                                  SENT
 
C  REVISED 08-JUN-99.
C  REMOVES TYPESETTING INSTRUCTIONS FROM A SENTENCE.
C
C  ISEN RECEIVES THE INPUT SENTENCE.
C  JSEN RETURNS THE OUTPUT SENTENCE. (MAY USE THE SAME LOCATIONS
C    AS ISEN.)
C  LSEN RECEIVES THE DIMENSION OF ISEN AND JSEN.
C
      DIMENSION ISEN(LSEN),JSEN(LSEN)
C
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
C
      IF (ITPSET.GE.0)  GO TO 100
C
      JSG = 2
      JSGI = 2
      JGN = 1 + ISEN(1)
   50 IF (JSG.GE.JGN)  GO TO 90
        JSGN = JSG + ISEN(JSG)
        I = JSG + 2
        J = JSGI + 2
        ITS = ISEN(JSG+1)
C       Handle special RTF characters first.
        CALL PROCRTF (ISEN(I), JSGN-I, L, ITPSET)
        JSGM = I + L
   60   IF (I.GE.JSGM)  GO TO 80
          IF (IGNOR(ISEN(I)).NE.0)  GO TO 66
          JSEN(J) = ISEN(I)
          J = J + 1
   66     I = I + 1
          GO TO 60
   80   JSEN(JSGI) = J - JSGI
        JSEN(JSGI+1) = ITS
        JSG = JSGN
        JSGI = J
        GO TO 50
   90 JSEN(1) = JSGI - 1
      GO TO 200
C
  100 CALL COPIA (ISEN, JSEN, ISEN(1))
C
  200 RETURN
      END
      SUBROUTINE PROCRTF (IBF, LBF, JBF, ITPSET)                            SENT
 
C  Processes special RTF characters when omitting typesetting marks.
C  1. The RTF command for Unicode characters is of the form \uN\'xx or
C   \uNC, where N is a Unicode character value expressed as a decimal,
C  x is a hexadecimal digit, and C is a character.
C  The character represented by the hex value (xx) or C replaces
C  the RTF command string.
c  2. The RTF command for non-breaking space is of the form \~.
C   It is replaced by a space.
C  This routine needs to be called BEFORE calling IGNOR.
C  REVISED 14-SEP-00.
 
C  IBF RECEIVES AND RETURNS THE TEXT BUFFER.
C  LBF RECEIVES THE LENGTH OF IBF.
C  JBF RETURNS THE NEW (ALTERED) LENGTH OF IBF. (JBF <= LBF)
C  ITPSET RECEIVES WHETHER TYPESETTING MARKS ARE REQUIRED.
 
      COMMON /ALPLCX/ KLA,KLB,KLC,KLD,KLE,KLF,KLG,KLH,KLI,KLJ,KLK,KLL,
     *                KLM,KLN,KLO,KLP,KLQ,KLR,KLS,KLT,KLU,KLV,KLW,KLX,
     *                KLY,KLZ
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /NUMXXX/ KNUM(10),KDEC,KMINUS
 
      DIMENSION IBF(LBF)
      INTEGER HEX2DEC
 
      JBF = LBF 
 
      IF (ITPSET.GE.0) RETURN
 
      I = 1
      JBF = 0
      DO WHILE (I.LE.LBF)
C       Scan for \u.
        IF (I.LT.LBF.AND.IBF(I).EQ.KDBSLSH.AND.IBF(I+1).EQ.KLU) THEN
C         Unicode character.
C           Skip to over Unicode value to alternate character.
            J = I + 2
            DO WHILE (ISNUM(IBF(J)).NE.0.OR.IBF(J).EQ.KMINUS)
              J = J + 1
            ENDDO
            IF (IBF(J).EQ.KDBSLSH) THEN
C             Format: \'xx
              J = J + 2
C             Convert hex value to decimal.
              IVAL = 0
              DO K = 1, 2
                IVAL = IVAL*16 + HEX2DEC(IBF(J))
                J = J + 1
              ENDDO
C             Insert into buffer
              JBF = JBF + 1
              IBF(JBF) = IVAL
            ELSE
C             Format: C
C             Insert single character into buffer.
              JBF = JBF + 1
              IBF(JBF) = IBF(J)
              J = J + 1
            ENDIF
C           Continue processing from point after alternate character
            I = J
        ELSEIF (I.LT.LBF.AND.IBF(I).EQ.KDBSLSH.AND.
     *          IBF(I+1).EQ.KDINF) THEN
            JBF = JBF + 1
            IBF(JBF) = KBLANK
            I = I + 2
        ELSE
          JBF = JBF + 1
          IBF(JBF) = IBF(I)
          I = I + 1
        ENDIF
      ENDDO
 
      RETURN
      END
      SUBROUTINE SENSIM (ISEN, LSEN, IBF, LBF, MINBF, JBF, ICOMM, KCHAR)    SENT
 
C  REVISED 8-JUN-98.
C  COPYS A SENTENCE, OPTIONALLY RETAINING COMMENTS AND INSERTING A CHAR. BEFORE
 
C  ISEN RECEIVES THE SENTENCE, AS READ BY SUBR. SENTNC.
C  LSEN RECEIVES THE LENGTH OF ISEN.
C  IBF RETURNS THE SIMPLIFIED TEXT.
C  LBF RECEIVES THE LENGTH OF IBF.
C    THE TEXT IS TRUNCATED TO THIS LENGTH IF NECESSARY.
C  MINBF RECEIVES THE MINIMUM LENGTH OF THE TEXT.
C    BLANK FILL IS INSERTED IF NECESSARY TO ATTAIN THIS LENGTH.
C  JBF RETURNS THE ACTUAL LENGTH OF THE SIMPLIFIED TEXT.
C  ICOMM RECEIVES A FLAG FOR HANDLING OF COMMENTS - 0 - REMOVE COMMENT,
C    1 - RETAIN COMMENT WITH ANGLE BRACKETS, 2 - RETAIN COMMENT WITHOUT
C    ANGLE BRACKETS, BUT INSERTING CHARACTER KCHAR BEFORE THE COMMENT,
C    3 - REMOVE INNER COMMENTS
C  KCHAR RECEIVES THE CHARACTER TO BE INSERTED BEFORE THE COMMENT IF ICOMM=2
 
      DIMENSION ISEN(LSEN),IBF(LBF)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /CAPXXX/ KCAPMK,IOMCAP
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
C
      IF (MINBF.GT.LBF)  CALL BUG (4, LBF)
C
      JBF = 0
      LASTC = 0
C--   COPY SENTENCE.
      JSG = 2
C
  100 IF (JSG.GE.ISEN(1).OR.JBF.GE.LBF)  GO TO 200
        JSGN = JSG + ISEN(JSG)
C
C-    PROCESS COMMENT.
        IF (ISEN(JSG+1).GT.0.OR.ICOMM.EQ.1)  GO TO 110
        IF (ICOMM.LE.0)  GO TO 190
        IF (ICOMM.EQ.2)  THEN
          JBF = JBF + 1
          IF (JBF.GE.LBF)  GO TO 200
          IBF(JBF) = KCHAR
          I = JSG + 3
          IE = JSGN - 1
          GO TO 120
        ELSEIF (ICOMM.EQ.3)  THEN
          IB = JSG + 2
          IE = JSG + ISEN(JSG) - 1
          CALL REMNSC (ISEN(IB), IE-IB+1, L)
C         EMPTY COMMENT?
          IF (L.LE.2)  GOTO 190
          I = JSG + 2
          IE = IB + L
          GOTO 120
        ENDIF
C-
  110   I = JSG + 2
        IE = JSGN
  120   IF (ITPSET.LT.0) THEN
C         Handle special RTF characters first.
          CALL PROCRTF (ISEN(I), IE-I+1, L, ITPSET)
          IE = I + L - 1
        ENDIF
  125   IF (I.GE.IE)  GO TO 180
          IF (ITPSET.LT.0.AND.IGNOR(ISEN(I)).NE.0)  GO TO 130
          IF (JBF.GE.LBF)  GO TO 200
C         ELIMINATE MULTIPLE BLANKS.
          IF (ISEN(I).EQ.KBLANK.AND.LASTC.EQ.KBLANK)  GOTO 130
C         OMIT 'NO CAPITALIZATION' MARKER.
          IF (IOMCAP.NE.0.AND.ISEN(I).EQ.KCAPMK)  GOTO 130
          JBF = JBF + 1
          IBF(JBF) = ISEN(I)
          LASTC = ISEN(I)
  130     I = I + 1
          GO TO 125
  180   IF (IBF(JBF).EQ.KBLANK)  GO TO 190
        IF (JBF.GE.LBF)  GO TO 200
        JBF = JBF + 1
        IBF(JBF) = KBLANK
  190   JSG = JSGN
        GO TO 100
C
C--   ADJUST TRAILING BLANKS.
  200 IF (JBF.LE.MINBF)  GO TO 220
      IF (JBF.GT.0.AND.IBF(JBF).EQ.KBLANK)  JBF = JBF - 1
      GO TO 300
  220 IF (JBF.GE.MINBF)  GO TO 300
        JBF = JBF + 1
        IBF(JBF) = KBLANK
        GO TO 220
C--
  300 RETURN
      END
      SUBROUTINE SENTNC (IDAT, LIDAT, IFSOL, JIDAT, ISENT)                  SENT
 
C* REVISED 9-MAR-99.
C  READS AND STORES A SENTENCE.
 
C  A SENTENCE CONSISTS OF TEXT TERMINATED BY SOLIDUS-BLANK (KDSOL).
C    THE START OF A COMMENT IN THE SENTENCE IS INDICATED BY A
C    LEFT BRACKET (KDLBRA) PRECEDED BY A BLANK, RIGHT BRACKET, OR LEFT
C    BRACKET, AND THE END BY A RIGHT BRACKET (KDRBRA) FOLLOWED BY A
C    BLANK, LEFT BRACKET, SOLIDUS, OR RIGHT BRACKET (SEE ALSO IDEPTH).
C
C  IDAT RETURNS THE SENTENCE, STORED AS A GROUP (SEE SUBR. RDITEM)
C    STARTING AT IDAT(JIDAT+1).
C  LIDAT RECEIVES THE LENGTH OF IDAT. ITS VALUE MUST BE IDENTICAL
C    WITH THE VALUE IN DIM XXX.
C  IFSOL RECEIVES WHETHER A SOLIDUS IS REQUIRED TO TERMINATE THE SENTENCE.
C    IF IFSOL=-1, SOLIDUS IGNORED
C    IF IFSOL=0, NO SOLIDUS REQUIRED.
C    IF IFSOL=1, SOLIDUS REQUIRED AND THE SENTENCE CONTAINS A FEATURE/STATE DESCRIPTION.
C    IF IFSOL=2, SOLIDUS REQUIRED AND THE SENTENCE CONTAINS AN ITEM DESCRIPTION.
C  JIDAT RECEIVES AND RETURNS THE LAST ELEMENT OF IDAT IN USE.
C  ISENT RETURNS 1 IF A VALID SENTENCE IS READ,OR A NEGATIVE VALUE OTHERWISE.
C
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED AND NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS NORMALLY POSITIONED IMMEDIATELY AFTER THE END OF THE
C    SENTENCE. HOWEVER, IF THE SENTENCE WAS INVALID, JBUF IS POSITIONED
C    AT THE NEXT BLANK-NUMERO OR BLANK-STAR.
C
C  LOCAL VARIABLES.
C  IDEPTH = DEPTH OF BRACKETS (KDLBRA,KDRBRA). ONLY LEVEL 1 BRACKETS
C    DELIMIT COMMENTS. E.G., ((ABC) DEF) IS A SINGLE COMMENT.
C  IEND = HOW LAST SUBGROUP ENDED. 0 - WITH CLOSING BRACKET.
C    1 - WITH OPENING BRACKET. 2 - WITH SOLIDUS.
C  ITS = TYPE OF CURRENT SUBGROUP. 1 - ORDINARY. 0 - COMMENT.
C
      DIMENSION IDAT(LIDAT)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
 
C--   INITIALIZE.
      ISENT = 1
      IF (JIDAT.GE.LIDAT)  GOTO 1100
      JIDAT = JIDAT + 1
      JG = JIDAT
      ITS = 1
      IDEPTH = 0
      INBRACE = 0
C
C--   GET NEXT SUBGROUP OF SENTENCE.
  100 JSG = JIDAT + 1
        JIDAT = JSG + 1
        CALL SKNONB
C
C-      COPY UP TO SUBGROUP DELIMITER.
  150   IF (JIDAT.GE.LIDAT)  GOTO 1100
          IF (IBUF(JBUF).EQ.KDSTAR.OR.IBUF(JBUF).EQ.KDNUM)  GO TO 160
          IF (IBUF(JBUF).EQ.KDSOL)  GO TO 170
          IF (IBUF(JBUF).EQ.KDLBRA)  GO TO 180
          IF (IBUF(JBUF).EQ.KDRBRA)  GO TO 190
          GO TO 220
C         STAR OR NUMERO. - TREAT SAME AS SOLIDUS, BUT GIVE WARNING IF REQUIRED.
  160     IF (JBUF.LE.JBDAT)  GO TO 165
          IF (IBUF(JBUF-1).EQ.KBLANK)  GO TO 165
          GO TO 220
  165     IF (IFSOL.EQ.1)  THEN
            CALL MESSA (7, 4, JBUF-1)
          ELSE IF (IFSOL.EQ.2)  THEN
            CALL MESSA (98, -4, JBUF-1)
          ENDIF
          GOTO 250
C         SOLIDUS.
  170     IF (IFSOL.LT.0)  GOTO 220
          IF (IBUF(JBUF+1).EQ.KBLANK.OR.IBUF(JBUF+1).EQ.KDSOL)
     *     GO TO 250
          GO TO 220
C         LEFT BRACKET.
  180     IF (JBUF.LE.JBDAT)  GO TO 182
          IF (IBUF(JBUF-1).EQ.KBLANK .OR. IBUF(JBUF-1).EQ.KDLBRA .OR.
     *     IBUF(JBUF-1).EQ.KDRBRA)  GO TO 182
          GO TO 220
  182     IF (IDEPTH.EQ.0.AND.ITS.EQ.1)  GO TO 300
          IDEPTH = IDEPTH + 1
          GO TO 220
C         RIGHT BRACKET.
  190     IF (IBUF(JBUF+1).EQ.KBLANK .OR. IBUF(JBUF+1).EQ.KDRBRA .OR.
     *     IBUF(JBUF+1).EQ.KDLBRA .OR. IBUF(JBUF+1).EQ.KDSOL)  GO TO 192
          GO TO 220
  192     IDEPTH = IDEPTH - 1
          IF (IDEPTH.LT.0)  GO TO 410
          IF (IDEPTH.GT.0)  GO TO 220
          ISTATE = 1
          GOTO 221
C         COPY SYMBOL.
  220     ISTATE = 2
  221     JIDAT = JIDAT + 1
          IF (JIDAT.GT.LIDAT)  GOTO 1100
          IDAT(JIDAT) = IBUF(JBUF)
          JBUF = JBUF + 1
C         Check for matching {}.
          IF (IDAT(JIDAT).EQ.KLBRACE.AND.IDAT(JIDAT-1).NE.KDBSLSH) THEN
            INBRACE = INBRACE + 1
          ELSEIF (IDAT(JIDAT).EQ.KRBRACE.AND.
     *            IDAT(JIDAT-1).NE.KDBSLSH) THEN
            INBRACE = INBRACE - 1
          ENDIF
          IF (ISTATE.EQ.1)  GOTO 300
          IF (JBUF.GT.JEDAT)  CALL RDBUF
          GO TO 150
C
C-      SUBGROUP WAS TERMINATED BY SOLIDUS.
  250   IF (IDEPTH.GT.0)  GO TO 420
        IEND = 2
        IF (IBUF(JBUF).EQ.KDSOL)  JBUF = JBUF + 1
        GO TO 310
C
C-      FINISH SUBGROUP.
  300   IEND = ITS
C
  310   IB = JSG + 2
C       REMOVE TRAILING BLANKS.
  320   IF (JIDAT.LT.IB)  GO TO 340
          IF (IDAT(JIDAT).NE.KBLANK)  GO TO 350
          JIDAT = JIDAT - 1
          GO TO 320
C       NULL SUBGROUP.
  340   JIDAT = JSG - 1
        GO TO 360
C       STORE LENGTH AND TYPE.
  350   IDAT(JSG) = JIDAT - JSG + 1
        IDAT(JSG+1) = ITS
C       PREPARE FOR NEXT SUBGROUP.
  360   IF (IEND.GE.2)  GO TO 1000
        ITS = 1 - IEND
        GO TO 100
C
C--   END OF SENTENCE.
 
C-    ERROR MESSAGES.
  400 ISENT = -1
      GO TO 1000
  410 CALL MESSA (100, 3, JBUF)
      ISENT = -2
      GO TO 450
  420 CALL MESSA (91, 3, JBUF-1)
      ISENT = -3
  450 CALL SKDELW (1)
C-
 1000 IDAT(JG) = JIDAT - JG + 1
      IF (INBRACE.NE.0)  CALL MESSA (110, 3, JBUF-1)
      RETURN
 
 1100 CALL MESSB (35, LIDAT, 1, -1, 0)
 
      END
      SUBROUTINE WSENT (ISEN, LSEN, ICOMM, LOFF, IMARK, INAME, IE,          SENT
     * ITYPMK, LIDAT, LUNTYP)
 
C* REVISED 09-AUG-00.
C* WRITES A SENTENCE.
 
C  ISEN RECEIVES THE SENTENCE (SEE SUBR. SENTNC).
C  LSEN RECEIVES THE LENGTH OF ISEN.
C  ICOMM RECEIVES 0 IF COMMENTS ARE TO BE OMITTED, 1 IF COMMENTS ARE TO
C    BE OUTPUT WITH ANGLE BRACKETS, 2 IF COMMENTS ARE TO BE OUTPUT
C    WITHOUT ANGLE BRACKETS, 3 - IF INNER COMMENTS ARE TO BE OMITTED,
C    4 - IF ANGLE BRACKETS ARE TO BE REPLACED WITH HTML EQUIVALENTS,
C    5 - IF 3 AND 4.
C  LOFF
C    IF +VE, RECEIVES AN OFFSET FROM START OF TEXT AT WHICH OUTPUT IS TO BEGIN.
C    IF -VE, RECEIVES THE POINT AT WHICH A TYPESETTING MARK IS TO BE INSERTED
C     IN THE TEXT.
C  IMARK RECEIVES THE NUMBER OF THE TYPESETTING MARK TO BE INSERTED IF LOFF
C    IS -VE.
C  INAME RECEIVES WHETHER THIS IS A TAXON NAME (NEED TO KNOW FOR TYPSETTING
C   PURPOSES)
C  IE RECEIVES A FLAG SPECIFYING THE ACTION AFTER OUTPUT.
C    NEGATIVE - LAST WORD LEFT UNFINISHED. 0 - LAST WORD FINISHED.
C    POSITIVE - LINE FINISHED, AND (IE-1) EXTRA BLANK LINES.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  LIDAT RECEIVES THE LENGTH OF ITYPMK.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT FOR OUTPUT.
 
      DIMENSION ISEN(LSEN),ITYPMK(LIDAT)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
 
      IF (LOFF.LT.0)  THEN
        INSERT = -LOFF
        IOFF = 0
      ELSE
        INSERT = 0
        IOFF = LOFF
      ENDIF
 
      JSG = 2
      IOUT = 0
   10 IF (JSG.GT.ISEN(1))  GO TO 50
        IF (ICOMM.EQ.0.AND.ISEN(JSG+1).EQ.0)  GO TO 30
        IF (JSG.GT.2.AND.IOUT.NE.0)  THEN
C         Insert blank if output has occurred.
          CALL ENDWD (LUNTYP)
          IOUT = 0
          IF (INSERT.GT.0)  THEN
C           The value of INSERT needs to be adjusted to take account
C           of the inserted blank.
            INSERT = INSERT - 1
            IF (INSERT.EQ.0) THEN
C             Output typesetting mark now.
              CALL JSTTPS (IMARK, ITYPMK, LIDAT, NTYPMK, LUNTYP)
              IMARK = 0
            ENDIF
          ENDIF
        ENDIF
        IB = JSG + 2
        L = ISEN(JSG) - 2
        IF (ISEN(JSG+1).NE.0.OR.ICOMM.EQ.1)  GO TO 20
        IF (ICOMM.EQ.2)  THEN
          IB = IB + 1
          L = L - 2
        ELSEIF (ICOMM.EQ.3.OR.ICOMM.EQ.5)  THEN
          CALL REMNSC (ISEN(IB), L, NEWL)
C         EMPTY COMMENT?
          IF (NEWL.LE.2)  GOTO 30
          L = NEWL
        ENDIF
   20   IF (IOFF.GT.0)  THEN
          IF (IOFF-L.LT.0)  THEN
C           COMMENCE OUTPUT WITHIN THIS SUB-GROUP
            INC = IOFF
          ELSE
            GOTO 25
          ENDIF
        ELSE
          INC = 0
        ENDIF
        IF (L-INC.GT.0) THEN
          IF (INAME.GT.0 .AND. ISEN(JSG+1).NE.0)  THEN
C           TYPSET MARK BEFORE NON-COMMENT SECTION OF A TAXON NAME
            CALL JSTTPS (25, ITYPMK, LIDAT, NTYPMK, LUNTYP)
          ENDIF
          IF (INSERT.GT.0.AND.INSERT-L.LT.0) THEN
            CALL JSTOTP (ISEN(IB), INSERT, -1, ITYPMK, LIDAT,
     *        LUNTYP, 0, IHTMBKT)
            CALL JSTTPS (IMARK, ITYPMK, LIDAT, NTYPMK, LUNTYP)
            INC = INSERT
            IMARK = 0
          ENDIF
          IHTMBKT = 0
          IF (ICOMM.EQ.4.OR.ICOMM.EQ.5)  IHTMBKT = 1
          CALL JSTOTP (ISEN(IB+INC), L-INC, -1, ITYPMK, LIDAT,
     *      LUNTYP, 0, IHTMBKT)
          IOUT = 1
          IF (INAME.GT.0 .AND. ISEN(JSG+1).NE.0)  THEN
C           TYPSET MARK AFTER NON-COMMENT SECTION OF A TAXON NAME
            CALL JSTTPS (26, ITYPMK, LIDAT, NTYPMK, LUNTYP)
            KTYP = 0
          ENDIF
        ENDIF
   25   IOFF = IOFF - L
        INSERT = INSERT - L
   30   JSG = JSG + ISEN(JSG)
        GO TO 10
   50 IF (IE.GE.0)  CALL JSTS (KBLANK, IE, LUNTYP)
      IF (ISEN(1).EQ.1.AND.IE.GT.0)  CALL BLKLIN (1, 0, LUNTYP)
      RETURN
      END
