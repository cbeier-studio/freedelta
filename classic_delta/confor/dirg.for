      SUBROUTINE ALLOC1 (LW)                                                DIRG
 
C* REVISED 14-JUL-98.
C* ALLOCATES STARTING LOCATIONS FOR ALWAYS-SEPARATE ARRAYS.
 
C  IITYPC, ETC, ARE SET.
C  IF THERE IS INSUFFICIENT STORAGE AVAILABLE,
C    A MESSAGE IS PRINTED AND EXECUTION IS TERMINATED.
 
      COMMON /ADRXXX/ IITYPC,IIMC,IIMI,IWTC,IWTI,INSTAT,IKSTAT,
     * INEWOR,INDEC,IICDES,ILCDES,IITMAD,IWW1C,IWW2C,IWW1I,IWW2I,
     * IWW1S,IWW2S,IIDAT,IIDAM,IIDAV,IIPARA,IIEMPF,ILINKC,IICHHD,
     * IITSHD,IISBND,IIVCON,IICDEP,ILSTDE,INEWFL,IIMPL1,IIMPL2,
     * IIMPFL,IISUMM,IICPTW,IICPTB,IITPTR,ILNAME,IINTRL,IMANDC,IRBND,
     * INBND,IITXPT,INORNG,IIOMOR,IIFILS,IIREPS,IIADDT,IIADDC,IIEMPT,
     * IIEMPC,IMINC,IMAXC,INUMRN,INAFLG,ISCALF,IISRTS,IICNOT,IICNGP,
     * IITYMK,IIFMT,IIOMPD,IIOMLO,IICIMG,IICIGP,IITIMG,IITREC,IPCERR,
     * IABERR,IIOMFC,IIALTC,IIADNM,IIADDL,IIEMNM,IIEMPL,IIOUSP,IICSYN,
     * IILANG,IICSTR,IITHD,IITHREC,IICDNAM,IITFIL,IITFREC,IIXHD,IIXHREC,
     * IIFNT,IIUSECC,IIFOFSET,IITLNK,IILREC,IITLNK2,IINAUTOCC,IIOSUBJ,
     * ILAST
      COMMON /DIR1XX/ NCON1,JDIR1(5)
      COMMON /DIMXXX/ NC,MI,MS,LIDAT,LCSTR
C
      IF (JDIR1(1).LE.0)  THEN
        LIDAT = MAX(2000,20*NC)
        LIDAT = MAX(LIDAT,5*MI)
      ENDIF
C
C--   ALWAYS-SEPARATE ARRAYS.
C     ITYPC(NC).
      IITYPC = 1
C     IMC(NC).
      IIMC = IITYPC + NC
C     IMI(MI).
      IIMI = IIMC + NC
C     WTC(NC).
      IWTC = IIMI + MI
C     WTI(MI).
      IWTI = IWTC + NC
C     NSTAT(NC).
      INSTAT = IWTI + MI
C     KSTAT(NC)
      IKSTAT = INSTAT + NC
C     NEWOR(NC)
      INEWOR = IKSTAT + NC
C     NDEC(NC)
      INDEC = INEWOR + NC
C     ICDES(NC).
      IICDES = INDEC + NC
C     LCDES(NC).
      ILCDES = IICDES + NC
C     IITMAD(NC).
      IITMAD = ILCDES + NC
C     WW1C(NC).
      IWW1C = IITMAD + NC
C     WW2C(NC).
      IWW2C = IWW1C + NC
C     WW1I(MI).
      IWW1I = IWW2C + NC
C     WW2I(MI).
      IWW2I = IWW1I + MI
C     WW1S(MS).
      IWW1S = IWW2I + MI
C     WW2S(MS).
      IWW2S = IWW1S + MS
C     IDAT(LIDAT).
      IIDAT = IWW2S + MS
C     IDAM(LIDAT).
      IIDAM = IIDAT + LIDAT
C     IDAV(LIDAT).
      IIDAV = IIDAM + LIDAT
C     LAST(NC).
      ILAST = IIDAV + LIDAT
 
C--   SOMETIMES-SEPARATE ARRAYS.
C     THESE ARRAYS USE THE SAME STORAGE, OF LENGTH NC, UNLESS THE
C     CORRESPONDING DIRECTIVE IS USED. THIS IS POSSIBLE BECAUSE ALL THE
C     NO-ACTION CONDITIONS ARE REPRESENTED BY 0.
      IIPARA = ILAST
      IIEMPF = ILAST
      ILINKC = ILAST
      IICHHD = ILAST
      IITSHD = ILAST
      IISBND = ILAST
      IIVCON = ILAST
      IICDEP = ILAST
      ILSTDE = ILAST
      INEWFL = ILAST
      IIMPL1 = ILAST
      IIMPL2 = ILAST
      IIMPFL = ILAST
      IISUMM = ILAST
      IINTRL = ILAST
      IMANDC = ILAST
      INORNG = ILAST
      IIOMOR = ILAST
      IIFILS = ILAST
      IIADDT = ILAST
      IIADDC = ILAST
      IIEMPT = ILAST
      IIEMPC = ILAST
      ISCALF = ILAST
      IISRTS = ILAST
      IIOMPD = ILAST
      IIOMLO = ILAST
      IIOMFC = ILAST
      IIALTC = ILAST
      IICSYN = ILAST
      IIFOFSET = ILAST
 
C     THESE ARE NOT CHARACTERS ARRAYS BUT ARE SET TO ZERO HERE ANYWAY.
C     THEY USUALLY HAVE FLAGS TO INDICATE WHETHER THEY ARE IN USE.
C     TYPESETTING MARKS.
      IITYMK = ILAST
C     FORMATTING MARKS.
      IIFMT = ILAST
C     ALTERNATE LANGUAGES.
      IILANG = ILAST
C     ITEM HEADINGS.
      IITHD =  ILAST
      IITHREC = ILAST
C     ITEM OUTPUT FILES.
      IITFIL = ILAST
      IITFREC = ILAST

 
C     THE FOLLOWING ARRAYS ARE USED ONLY IN TRANSLATE INTO DIST, KEY,
C     OR INTKEY FORMATS, AND ARE THEN ALLOCATED SEPARATE STORAGE.
      IICPTW = 1
      IICPTB = 1
      IITPTR = 1
      ILNAME = 1
      IRBND = 1
      INBND = 1
      IITXPT = 1
      IMINC = 1
      IMAXC = 1
      INUMRN = 1
      INAFLG = 1
      IICIMG = 1
      IITIMG = 1
      IPCERR = 1
      IABERR = 1
 
      ILAST = ILAST + NC
C     (IICSTR IS ALLOCATED LATER - SEE SUBR. CHKDIR.)
 
C--   CHECK THAT THERE IS ENOUGH STORAGE.
      IF (ILAST.GT.LW)  CALL MORMEM (ILAST, LW)
 
      RETURN
      END
      SUBROUTINE ALLOC2 (LW, IADDR, IDIM)                                   DIRG
 
C* REVISED 6/7/87.
C* ALLOCATES STARTING LOCATIONS OF SOMETIMES-ALLOCATED ARRAYS.
 
C  LW RECEIVES THE LENGTH OF BLANK COMMON.
C  IADDR RETURNS THE ALLOCATED LOCATION.
C  IDIM RECEIVES THE NUMBER OF LOCATIONS REQUIRED.
 
C  ILAST IS SET.
C  IF THERE IS INSUFFICIENT STORAGE AVAILABLE,
C    A MESSAGE IS PRINTED AND EXECUTION IS TERMINATED.
 
      COMMON /ADRXXX/ IITYPC,IIMC,IIMI,IWTC,IWTI,INSTAT,IKSTAT,
     * INEWOR,INDEC,IICDES,ILCDES,IITMAD,IWW1C,IWW2C,IWW1I,IWW2I,
     * IWW1S,IWW2S,IIDAT,IIDAM,IIDAV,IIPARA,IIEMPF,ILINKC,IICHHD,
     * IITSHD,IISBND,IIVCON,IICDEP,ILSTDE,INEWFL,IIMPL1,IIMPL2,
     * IIMPFL,IISUMM,IICPTW,IICPTB,IITPTR,ILNAME,IINTRL,IMANDC,IRBND,
     * INBND,IITXPT,INORNG,IIOMOR,IIFILS,IIREPS,IIADDT,IIADDC,IIEMPT,
     * IIEMPC,IMINC,IMAXC,INUMRN,INAFLG,ISCALF,IISRTS,IICNOT,IICNGP,
     * IITYMK,IIFMT,IIOMPD,IIOMLO,IICIMG,IICIGP,IITIMG,IITREC,IPCERR,
     * IABERR,IIOMFC,IIALTC,IIADNM,IIADDL,IIEMNM,IIEMPL,IIOUSP,IICSYN,
     * IILANG,IICSTR,IITHD,IITHREC,IICDNAM,IITFIL,IITFREC,IIXHD,IIXHREC,
     * IIFNT,IIUSECC,IIFOFSET,IITLNK,IILREC,IITLNK2,IINAUTOCC,IIOSUBJ,
     * ILAST
 
      IADDR = ILAST
      ILAST = ILAST + IDIM
      IF (ILAST.GT.LW) CALL MORMEM (ILAST, LW)
 
      RETURN
      END
      SUBROUTINE ATTCOM (IDAT, LIDAT, JIDAT, IERR)                          DIRG
 
C  REVISED 9-FEB-99.
C  READS AND STORES AN ATTRIBUTE COMMENT.
 
C  IDAT RETURNS THE COMMENT.
C  LIDAT RECEIVES THE LENGTH OF IDAT.
C  JIDAT RECEIVES AND RETURNS THE INDEX OF THE LAST ELEMENT OF IDAT
C    IN USE.
C  IERR RETURNS 0 IF THERE IS NO ERROR, 1 OTHERWISE.
C
C  ON ENTRY, JBUF MUST BE POSITIONED AT THE OPENING BRACKET OF THE
C    COMMENT.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED AND NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED IMMEDIATELY AFTER THE CLOSING BRACKET
C    IF THERE WAS NO ERROR, OTHERWISE AT THE THE ERROR.
 
      DIMENSION IDAT(LIDAT)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
 
C--   START SUBGROUP.
      IERR = 0
      IDEPTH = 1
      INBRACE = 0
      IF (JIDAT+3.GT.LIDAT)  GOTO 1100
      JSG = JIDAT + 1
      IDAT(JSG+1) = 0
      JIDAT = JIDAT + 3
      IDAT(JIDAT) = IBUF(JBUF)
C
C--   COPY COMMENT.
   10 JBUF = JBUF + 1
        IF (JBUF.GT.JEDAT)  CALL RDBUF
        IF (JIDAT.GE.LIDAT) GOTO 1100
        JIDAT = JIDAT + 1
        IDAT(JIDAT) = IBUF(JBUF)
C       Check for matching {}.
        IF (IDAT(JIDAT).EQ.KLBRACE.AND.IDAT(JIDAT-1).NE.KDBSLSH) THEN
          INBRACE = INBRACE + 1
        ELSEIF (IDAT(JIDAT).EQ.KRBRACE.AND.
     *          IDAT(JIDAT-1).NE.KDBSLSH) THEN
          INBRACE = INBRACE - 1
        ENDIF
        IF (IBUF(JBUF).EQ.KDRBRA)  THEN
C         IF (IBUF(JBUF+1).EQ.KBLANK .OR. IBUF(JBUF+1).EQ.KDLBRA .OR.
C    *     IBUF(JBUF+1).EQ.KDRBRA)  THEN
C           ALLOW FOR NESTED COMMENTS.
            IDEPTH = IDEPTH - 1
            IF (IDEPTH.EQ.0)  GOTO 200
C         ELSE
C           IF (IDEPTH.GT.1) GOTO 100
C           GO TO 200
C         ENDIF
        ENDIF
        IF (IBUF(JBUF).EQ.KDLBRA)  THEN
C         IF (IBUF(JBUF-1).EQ.KBLANK .OR.IBUF(JBUF-1).EQ.KDLBRA .OR.
C    *     IBUF(JBUF-1).EQ.KDRBRA)  THEN
C           ALLOW FOR NESTED COMMENTS.
            IDEPTH = IDEPTH + 1
C          ELSE
C            GO TO 20
C         ENDIF
        ENDIF
        IF (IBUF(JBUF).NE.KDSTAR.AND.IBUF(JBUF).NE.KDNUM)  GO TO 20
        IF (JBUF.LE.JBDAT)  GO TO 110
        IF (IBUF(JBUF-1).EQ.KBLANK)  GO TO 110
   20   GO TO 10
 
C--   ERROR MESSAGES.
  100 IPOINT = JBUF
      GO TO 120
  110 IPOINT = JBUF - 1
 
  120 CALL MESSA (91, 3, IPOINT)
      IERR = 1
      JIDAT = JSG - 1
      IDAT(JSG) = 0
      GO TO 300
C
C--
  200 IDAT(JSG) = JIDAT - JSG + 1
      JBUF = JBUF + 1
      IF (INBRACE.NE.0)  CALL MESSA (110, 3, JBUF-1)
  300 RETURN
 
 1100 CALL MESSB (35, LIDAT, 1, -1, 0)
 
      END
      SUBROUTINE ATTSK (INSIDE)                                             DIRG
C
C  REVISED 18/5/80.
C  SKIPS TO END OF ATTRIBUTE.
C
C  INSIDE RECEIVES 1 IF THE CURRENT POSITION OF JBUF IS INSIDE
C    A COMMENT, OTHERWISE 1.
C
C  NEW RECORDS ARE READ IF REQUIRED.
C  ON EXIT, JBUF IS POSITIONED IMMEDIATELY AFTER THE ATTRIBUTE.
C
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
      IN = INSIDE
   10 IF (IBUF(JBUF).EQ.KBLANK.AND.IN.EQ.0)  GO TO 100
        IF (IBUF(JBUF).EQ.KDLBRA)  IN = 1
        IF (IBUF(JBUF).EQ.KDRBRA)  IN = 0
        IF (IBUF(JBUF).NE.KDSTAR.AND.IBUF(JBUF).NE.KDNUM)  GO TO 20
        IF (JBUF.LE.JBDAT)  GO TO 100
        IF (IBUF(JBUF-1).EQ.KBLANK)  GO TO 100
   20   JBUF = JBUF + 1
        IF (JBUF.GT.JEDAT)  CALL RDBUF
        GO TO 10
  100 RETURN
      END
      SUBROUTINE CHDELW (ITERM)                                             DIRG
C
C* REVISED 26-JUL-89.
C* ENSURES THAT NEXT NON-BLANK CHARACTER IS A VALID DELIMITER.
C
C  ITERM RECEIVES 0 IF THE DELIMITER MUST BE STAR (KDSTAR),
C    OR 1 IF THE DELIMITER MAY BE STAR OR NUMERO (KDNUM).
C
C  JBUF IS MOVED TO THE NEXT NON-BLANK CHARACTER. IF THIS IS NOT A
C    VALID DELIMITER, A MESSAGE IS PRINTED, AND JBUF IS MOVED
C    TO THE START OF THE NEXT DELIMITER-WORD.
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
      CALL SKNONB
      IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 100
      IF (IBUF(JBUF).NE.KDNUM)  GO TO 50
      IF (ITERM.NE.0)  GO TO 100
      CALL MESSA (31, 3, JBUF)
      GO TO 70
   50 CALL MESSA (60, 1, 0)
   70 CALL SKDELW (ITERM)
C
  100 RETURN
      END
      FUNCTION   CMPVCB (IBF, L, NWD)
 
C  REVISED 4-MAY-92.
C  COMPARES CONTENTS OF A BUFFER WITH A WORD IN THE VOCABULARY.
 
      COMMON /VWDXXX/ VWORD(18)
        CHARACTER*40 VWORD
      COMMON /VLWXXX/ NVWD,MAXVWD,LVWD(18),IBPUNC,IEPUNC,
     * KVSTOP,KVCOM1,KVCOM2,KVSEMI,KVDEC
 
      DIMENSION IBF(L)
 
      J = L
      K = LVWD(NWD)
      DO I = 1, LVWD(NWD)
        IF (J.LT.1)  GOTO 50
        IF (IBF(J).NE.ICHAR(VWORD(NWD)(K:K)))  GOTO 50
        J = J - 1
        K = K - 1
      END DO
      CMPVCB = 0
      GOTO 100
 
   50 CMPVCB = 1
 
  100 RETURN
      END
      SUBROUTINE CNUM (ICFLAG, IB, IE, IC, NC, JE)                          DIRG
C
C* REVISED 26-JUL-89.
C* DECODES OR GENERATES A CHARACTER NUMBER OR RANGE.
C
C  ICFLAG RECEIVES AND RETURNS AN ARRAY OF FLAGS INDICATING THE
C    STATUS OF THE CHARACTER NUMBER (AND ASSOCIATED VALUES) READ.
C    ICFLAG(IC) NEGATIVE, ZERO, OR POSITIVE INDICATES AN INVALID
C    NUMBER READ, NO NUMBER READ, OR A VALID NUMBER READ, RESPECTIVELY.
C  IB RETURNS THE START OF THE RANGE.
C  IE RETURNS THE END OF THE RANGE.
C  IC RECEIVES AND RETURNS THE LAST CHARACTER NUMBER READ.
C    IF THE NUMBER OR RANGE READ IS INVALID, IC RETURNS -1.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  JE RECEIVES THE LOCATION IN IBUF IMMEDIATELY AFTER THE END OF
C    THE INPUT FIELD TO BE EXAMINED.
C
C  THE INPUT FIELD IS IBUF(JBUF) TO IBUF(JE-1). IF THERE IS A
C    COMMA IN THE FIELD, THAT PART OF THE FIELD BEFORE THE COMMA,
C    IF NON-EMPTY, IS DECODED TO GIVE IC.
C    IF THERE IS NO COMMA, OR IF THE PART OF THE FIELD BEFORE THE
C    COMMA IS EMPTY, IC IS INCREMENTED BY 1.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT WITH A VALID NUMBER, JBUF IS UNALTERED IF THERE WAS NO
C    COMMA, OR IS IMMEDIATELY AFTER THE COMMA IF THERE WAS ONE.
C    ON EXIT WITH AN INVALID NUMBER, JBUF IS SET TO JE.
C
      DIMENSION ICFLAG(NC)
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
C     SEARCH FOR COMMA.
      DO 20 JF = JBUF, JE
        IF (IBUF(JF).EQ.KDCOM)  GO TO 30
   20   CONTINUE
      JF = JBUF - 1
      GO TO 40
   30 IF (JF.EQ.JBUF)  GO TO 40
C
C     COMMA FOUND, PRECEDING FIELD NON-EMPTY. DECODE CHARACTER NUMBER.
      CALL DERNG (IB, IE, NC, JBUF, JF)
      IF (IB.LE.0)  GOTO 150
      GO TO 50
C
C     NO COMMA, OR EMPTY PRECEDING FIELD. INCREMENT IC.
   40 IF (IC.LT.0)  GO TO 110
      IC = IC + 1
      IB = IC
      IE = IC
C
C     CHECK CHARACTER NUMBERS.
   50 DO 55 IC = IB, IE
        IF (IC.LE.0 .OR. IC.GT.NC)  GO TO 120
        IF (ICFLAG(IC).NE.0)  GO TO 130
        ICFLAG(IC) = 1
   55   CONTINUE
      IC = IE
      JBUF = JF + 1
      GO TO 200
 
C     ERROR MESSAGES.
  110 IERRNO = 63
      GO TO 140
  120 IERRNO = 13
      CALL MESSB (IERRNO, NC, 1, 3, JBUF)
      GO TO 150
  130 IERRNO = 64
      CALL MESSB (IERRNO, IC, 1, 3, JBUF)
      ICFLAG(IC) = -1
      GOTO 150
 
  140 CALL MESSA (IERRNO, 3, JBUF)
 
  150 IC = -1
      IB = -1
      IE = -1
      JBUF = JE
C
  200 RETURN
      END
      SUBROUTINE DERNG (IB, IE, IMAX, JB, JE)                               DIRG
C
C* REVISED 26-JUL-89.
C* DECODES A RANGE OF POSITIVE INTEGER VALUES.
C
C  IB RETURNS THE START OF THE RANGE, OR 0 IF THERE ARE ERRORS.
C  IE RETURNS THE END OF THE RANGE.
C  IMAX RECEIVES THE MAXIMUM ALLOWED VALUE.
C  JB RECEIVES THE LOCATION IN IBUF OF THE START OF THE FIELD
C    TO BE DECODED.
C  JE RECEIVES THE LOCATION IN IBUF IMMEDIATELY AFTER THE END OF
C    THE FIELD TO BE DECODED.
C
C  THE TEXT TO BE DECODED IS IN THE INPUT BUFFER BETWEEN IBUF(JB)
C    AND IBUF(JE-1), AND TAKES THE FORM N OR N-M.
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
      IF (JB.GE.JE)  GO TO 240
C-    FIND RANGE SYMBOL, IF ANY.
      DO 30 JF = JB, JE
        IF (IBUF(JF).EQ.KDRANG)  GO TO 40
   30   CONTINUE
C
C-    A SINGLE ELEMENT WAS SPECIFIED.
      CALL IDKOD (IB, IBUF(JB), JE-JB, IERR)
      IF (IERR.NE.0)  GO TO 200
      IF (IB.LT.1 .OR. IB.GT.IMAX)  GO TO 210
      IE = IB
      GO TO 1000
C
C-    A RANGE WAS SPECIFIED.
   40 IF (JB.GE.JF)  GO TO 240
      CALL IDKOD (IB, IBUF(JB), JF-JB, IERR)
      IF (IERR.NE.0)  GO TO 200
      IF (IB.LT.1 .OR. IB.GT.IMAX)  GO TO 210
      JB = JF + 1
      IF (JB.GE.JE)  GO TO 240
      CALL IDKOD (IE, IBUF(JB), JE-JB, IERR)
      IF (IERR.NE.0)  GO TO 200
      IF (IE.LT.1 .OR. IE.GT.IMAX)  GO TO 210
      IF (IE.LE.IB)  GO TO 230
      GO TO 1000
 
C-    ERROR MESSAGES.
  200 IERRNO = 12
      IPOINT = JB + IERR - 1
      GO TO 900
  210 IERRNO = 22
      IPOINT = JB
      GO TO 900
  230 IERRNO = 65
      IPOINT = JB
      GO TO 900
  240 IERRNO = 10
      IPOINT = JB
  900 CALL MESSA (IERRNO, 3, IPOINT)
      IB = 0
C-
 1000 RETURN
      END
      SUBROUTINE EXTRNG (IDAT, LIDAT, JIDAT, JSG, NUMV, IFIRST, ILAST,      DIRG
     * IWRK, IERR)
 
C  REVISED 18/2/88.
C  PROCESSES A SUB-GROUP OF NUMERIC RANGE VALUES.
 
C  IDAT RECEIVES THE ITEM
C  LIDAT RECEIVES THE DIMENSION OF IDAT.
C  JIDAT RECEIVES AND RETURNS THE CURRENT LENGTH OF IDAT.
C  JSG RECEIVES THE SUB-HEADER ADDRESS.
C  NUMV RECEIVES AND RETURNS THE NUMBER OF VALUES.
C  IFIRST RECEIVES WHETHER TO DUPLICATE THE FIRST VALUE.
C  ILAST RECEIVES WHETHER TO DUPLICATE THE LAST VALUE.
C  IWRK RECEIVES THE VALUES.
 
      DIMENSION IDAT(LIDAT),IWRK(5)
 
      IERR = 0
 
C--   PROCESS EXTREME VALUE DATA.
      IF (NUMV.GE.2.AND.NUMV.LE.4)  THEN
        IF (IFIRST.NE.0.AND.ILAST.NE.0)  THEN
          IF (NUMV.EQ.3)  THEN
C           DUPLICATE MIDDLE VALUE.
            NUMV = 4
            IWRK(4) = IWRK(3)
            IWRK(3) = IWRK(2)
          ENDIF
          GOTO 100
        ENDIF
        NDUP = 1
        IF (NUMV.EQ.2)  NDUP = 2
        IF (IFIRST.NE.0)  THEN
C         DUPLICATE LAST VALUE (TWICE IF NUMV=2).
          DO 50 I = 1, NDUP
            NUMV = NUMV + 1
            IWRK(NUMV) = IWRK(NUMV-1)
   50       CONTINUE
        ELSEIF (ILAST.NE.0)  THEN
C         DUPLICATE FIRST VALUE (TWICE IF NUMV=2).
          IB = NDUP + 1
          NUMV = NUMV + NDUP
C         MOVE VALUES DOWN IN ARRAY.
          DO 80 I = NUMV, IB, -1
            IWRK(I) = IWRK(I-NDUP)
   80       CONTINUE
C         DUPLICATE FIRST VALUE(S).
          DO 90 I = IB-1, 1, -1
            IWRK(I) = IWRK(IB)
   90       CONTINUE
        ENDIF
      ENDIF
 
C-    STORE VALUES.
  100 IF (JIDAT+NUMV.GT.LIDAT)  GOTO 200
      CALL COPIA (IWRK, IDAT(JIDAT+1), NUMV)
      JIDAT = JIDAT + NUMV
      IDAT(JSG) = JIDAT - JSG + 1
 
      RETURN
 
  200 IERR = 1
      RETURN
      END
      SUBROUTINE FINDST (IDAT, IC, LIDAT, ITYPC, NSTAT, NC,                 DIRG
     * ISTAT,MS,ITSF)
C
C* REVISED 26/9/84.
C* FINDS WHICH STATES ARE PRESENT IN AN ATTRIBUTE.
C
C  IDAT RECEIVES THE ITEM.
C  IC RECEIVES THE CHARACTER NUMBER.
C  LIDAT RECEIVES THE LENGTH OF IDAT.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  ISTAT RETURNS FLAGS INDICATING WHICH STATES ARE PRESENT.
C  MS RECEIVES THE LENGTH OF ISTAT.
C  ITSF RETURNS FLAGS INDICATING WHICH OF THE PSEUDOVALUE FLAGS ARE
C    PRESENT.
C
      DIMENSION IDAT(LIDAT),ITYPC(NC),NSTAT(NC),ISTAT(MS),
     * ITSF(3)
C
      COMMON /ITSXXX/ ITSS
C
      NS = NSTAT(IC)
      IF (NS.LE.1)  GO TO 1000
      DO 20 IS = 1, NS
   20   ISTAT(IS) = 0
      DO 22 I = 1, 3
   22   ITSF(I) = 0
      IF (IDAT(IC).LE.0)  GO TO 1000
      JG = IDAT(IC)
      JSG = JG + 1
      JGN = JG + IDAT(JG)
      JTYPC = IABS(ITYPC(IC))
C
C---  SCAN GROUPS OF ATTRIBUTE.
   50 IF (JSG.GE.JGN)  GO TO 1000
        ITS = IDAT(JSG+1)
        IF (ITS.LE.0)  GO TO 500
C
C       RECORD PRESENCE OF PSEUDOVALUE.
        IF (ITS.LE.ITSS)  GO TO 100
        I = ITS - ITSS
        ITSF(I) = 1
        GO TO 500
C
  100   JB = JSG + 2
        JE = JSG + IDAT(JSG) - 1
C
C--     STATES.
        IF (JTYPC.EQ.2 .AND.ITS.EQ.1)  GO TO 140
C       UNORDERED MULTISTATE, OR ORDERED MULTISTATE WITH 'AND'.
        DO 122 J = JB, JE
          IS = IDAT(J)
  122     ISTAT(IS) = 1
        GO TO 500
C       ORDERED MULTISTATE WITH 'TO'.
  140   IB = IDAT(JB)
        IE = IDAT(JE)
        DO 142 IS = IB, IE
  142     ISTAT(IS) = 1
C-
  500   JSG = JSG + IDAT(JSG)
        GO TO 50
C--
 1000 RETURN
      END
      FUNCTION IMPNAM (IDAT, LIDAT)                                         DIRG
 
C  REVISED 8-MAR-00.
C  COMPARES TAXON NAME TO A GIVEN STRING.
 
      DIMENSION IDAT(LIDAT)
      CHARACTER*19 IMPLNAME /'Implicit_Attributes'/
 
      IMPNAM = 0
      LNAME = LEN(IMPLNAME)
      LS = 0
 
      JSG = 2
   10 IF (JSG.GT.IDAT(1))  GO TO 50
        IB = JSG + 2
        L = IDAT(JSG) - 2
        IF (L.NE.LNAME) GOTO 100
        DO I = 1, L
          IF (LS+1.GT.LNAME)  GOTO 100
          LS = LS + 1
          IF (CHAR(IDAT(IB+I-1)).NE.IMPLNAME(LS:LS))  GOTO 100
        ENDDO
        JSG = JSG + IDAT(JSG)
        GOTO 10
 
   50 IMPNAM = 1

  100 RETURN
      END
      SUBROUTINE LANGCMT (LLANG, LIDAT, ILANG1, ILANG2, NLANG, IDAT,        DIRG
     * L, NEWL)
 
C  REVISED 26-NOV-99.
C  EXTRACTS SPECIFIED LANGUAGE TEXT FROM A COMMENT.
 
C  THIS CODE ASSUMES ANGLE BRACKETS ARE STILL IN PLACE AND SHOULD BE
C  CALLED BEFORE S/R REPLAB.
 
C  LLANG RECEIVES THE LIST OF LANGUAGES.
C  LIDAT RECEIVES THE (NOMINAL) LENGTH OF LLANG.
C  IUSELNG1 RECEIVES THE NUMBER OF THE LANGUAGE TO BE USED AS A FIRST PREFERENCE.
C  IUSELNG2 RECEIVES THE NUMBER OF THE LANGUAGE TO BE USED IF USELNG1 IS NOT PRESENT.
C  NLANG RECEIVES THE NUMBER OF LANGUAGES DEFINED.
C  IDAT RECEIVES THE COMMENT TO BE PROCESSED.
C  L RECEIVES THE LENGTH OF THE COMMENT.
C  NEWL RETURNS THE LENGTH OF THE COMMENT AFTER PROCESSING.
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /TNAMEX/ TNAME,LTNAME
        CHARACTER*256 TNAME
 
      DIMENSION LLANG(LIDAT),IDAT(L),MATCH(2),LSTR(2)
      CHARACTER STR*60
 
C     KAT = @
      PARAMETER (KAT=64, LENSTR=60)
 
C     FLAG WHICH OF SELECTED LANGUAGES ARE PRESENT.
      MATCH(1) = 0
      MATCH(2) = 0
 
C     FLAG WHETHER '@' OCCURS IN THE COMMENT.
      JAT = 0
 
      I = 0
      DO WHILE (I+1.LE.L)
        I = I + 1
C       Catch terminating right bracket
        IF (I.EQ.L.AND.IDAT(I).EQ.KDRBRA) GOTO 10
        IF (IDAT(I).EQ.KAT.AND.IDAT(I+1).NE.KBLANK)  THEN
          JAT = 1
          IB = I
          IMATCH = 0
C         WHICH LANGUAGE IS THIS?
          DO 20 ILANG = 1, NLANG
            K = I
            IPTR = LLANG(ILANG)
            LEN = LLANG(ILANG+1) - IPTR
            DO J = 1, LEN
              IF (K+1.GT.L.OR.(K+1.EQ.L.AND.IDAT(K+1).EQ.KDRBRA))
     *          GOTO 20
              K = K + 1
              IF (IDAT(K).NE.LLANG(IPTR+J-1)) GOTO 20
            ENDDO
            IMATCH = 1
            IF (ILANG.EQ.ILANG1) THEN
              MATCH(1) = 1
            ELSEIF (ILANG.EQ.ILANG2) THEN
              MATCH(2) = 1
            ENDIF
   20     CONTINUE
          
C         REPORT INVALID LANGUAGE IDENTIFIER
          IF (IMATCH.EQ.0) THEN
            LDAT = 1
            DO J = IB+1, L
              IF (IDAT(J).EQ.KBLANK)  GOTO 30
              LDAT = LDAT + 1
              IF (LDAT.EQ.5)  GOTO 30
            ENDDO
   30       IF (LDAT.GT.0)  THEN  
              LCPY = MIN0(LENSTR-5, LTNAME)
              LSTR(1) = LCPY
              STR(1:LCPY) = TNAME(1:LCPY)
              LSTR(2) = LDAT
              CALL COPIAS (IDAT(IB), STR(LCPY+1:), LDAT)
              CALL MESSC (152, IDUM, 1, 3, 0, STR, LSTR, 2)
            ENDIF
          ENDIF
          
        ENDIF
      ENDDO

C     NO LANGUAGE STRINGS PRESENT
      IF (JAT.EQ.0)  THEN
        NEWL = L
        GOTO 100
      ENDIF 
 
C     SELECT LANGUAGE TO USE.
   10 IF (MATCH(1).NE.0) THEN
        IUSELANG = ILANG1
      ELSEIF (MATCH(2).NE.0) THEN
        IUSELANG = ILANG2
      ELSE
        IUSELANG = ILANG1
      ENDIF
 
      NEWL = 0
      IPTR = LLANG(IUSELANG)
      LUSE = LLANG(IUSELANG+1) - IPTR
      INLANG = 0
      I = 0
      DO WHILE (I+1.LE.L)
        I = I + 1
C       Catch terminating right bracket
        IF (I.EQ.L.AND.IDAT(I).EQ.KDRBRA) INLANG = 0
        IF (IDAT(I).EQ.KAT)  THEN
C         IS THIS THE RIGHT LANGUAGE?
          DO J = 1, LUSE
            IF (I+1.GT.L.OR.(I+1.EQ.L.AND.IDAT(I+1).EQ.KDRBRA)) GOTO 40
            I = I + 1
            IF (IDAT(I).EQ.KBLANK) THEN
              INLANG = 0
              GOTO 40
            ELSE IF (IDAT(I).NE.LLANG(IPTR+J-1)) THEN
              INLANG = -1
              GOTO 40
            ENDIF
          ENDDO
          INLANG = 1
   40     CONTINUE
        ELSEIF (INLANG.GE.0) THEN
          NEWL = NEWL + 1
          IDAT(NEWL) = IDAT(I)
        ENDIF
      ENDDO
 
C     REMOVE LEADING BLANKS.
      IBEGIN = 1
C     Step over leading angle brackets
      DO WHILE (IDAT(IBEGIN).EQ.KDLBRA)
        IBEGIN = IBEGIN + 1
      ENDDO
      NBKT = IBEGIN - 1
      DO I = IBEGIN, NEWL
        IF (IDAT(I).NE.KBLANK)  GOTO 50
      ENDDO
   50 CONTINUE
      IF (I.NE.IBEGIN) THEN
        DO J = 1, NEWL-I+1
          IDAT(NBKT+J) = IDAT(I+J-1)
        ENDDO
        NEWL = NBKT + NEWL - I + 1
      END IF
 
C     REMOVE TRAILING BLANKS.
      IEND = NEWL
C     Ignore terminating angle brackets.
      DO WHILE (IDAT(IEND).EQ.KDRBRA)
        IEND = IEND - 1
      ENDDO
      NBKT = NEWL - IEND
      DO I = IEND, 1, -1
        IF (IDAT(I).NE.KBLANK) GOTO 60
      ENDDO
   60 CONTINUE
      IF (I.NE.IEND)  THEN
        IF (NBKT.GT.0)  CALL COPIA (IDAT(IEND+1), IDAT(I+1), NBKT)
        NEWL = I + NBKT
      ENDIF
 
  100 RETURN
      END
      SUBROUTINE RDATT (ITYPC, NSTAT, NC, IDAT, LIDAT, JIDAT, INKYST,       DIRG
     * IB, IE)
 
C* REVISED 27-OCT-95.
C* READS AN ATTRIBUTE.
 
C  ITYPC RECEIVES THE TYPES OF THE CHARACTERS. 1 - UNORDERED
C    MULTISTATE. 2 - ORDERED MULTISTATE. 3 - NUMERIC INTEGER.
C    4 - NUMERIC REAL. 5 - TEXT. -1 - EXCLUSIVE UNORDERED MULTISTATE.
C    -2 - EXCLUSIVE ORDERED MULTISTATE.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  IDAT RETURNS THE ATTRIBUTE (SEE SUBR. RDITEM).
C  THE MEANINGS OF THE SUBGROUP-TYPE FLAGS ARE AS FOLLOWS.
C    1 - ORDINARY VALUE OR RANGE OF VALUES (-).
C    2 - RANGE OF VALUES (&).
C    3 - INFINITE RANGE (~).
C    6 - VARIABLE.
C    7 - UNKNOWN.
C    8 - NOT APPLICABLE.
C    0 - TEXT COMMENT.
C    LESS THAN 0 - NOT USED. AVAILABLE FOR EXTENSIONS, SUCH AS CODED
C    OR NUMERIC COMMENTS.
C  LIDAT RECEIVES THE LENGTH OF IDAT.
C  JIDAT RECEIVES AND RETURNS THE INDEX OF THE LAST ELEMENT
C    OF IDAT IN USE.
C  INKYST RECEIVES WHETHER A KEY STATES DIRECTIVE IS BEING PROCESSED.
C    IF INKYST=1, INFINITE RANGES (DENOTED BY ~) ARE PERMITTED, AND
C    UNORDERED MULTISTATES MUST BE DELIMITED BY "&" OR "/".
C  IB RETURNS THE FIRST CHARACTER NUMBER OF THE ATTRIBUTE READ.
C  IE RETURNS THE LAST CHARACTER NUMBER OF THE LAST ATTRIBUTE READ.
C
C  ON ENTRY, JBUF MUST BE AT THE START OF AN ATTRIBUTE OR STAR- OR
C    NUMERO-WORD, OR SEPARATED FROM IT ONLY BY BLANKS.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED AND NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED IMMEDIATELY AFTER THE ATTRIBUTE, OR
C    AT THE START OF THE NEXT STAR- OR NUMERO-WORD.
C
C  LOCAL VARIABLES.
C  INFRNG = WHETHER AN INFINITE RANGE DENOTED (I.E.~).
C  ITS = TYPE OF CURRENT SUBGROUP.
C  IV = CURRENT MULTISTATE OR INTEGER VALUE.
C  JG = LOCATION IN IDAT OF START OF GROUP.
C  JSG = LOCATION IN IDAT OF START OF SUBGROUP.
C  RV = CURRENT REAL VALUE.
 
      DIMENSION ITYPC(NC),NSTAT(NC),IDAT(LIDAT)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /NUMXXX/ KNUM(10),KDEC,KMINUS
      COMMON /ULAXXX/ IULA
      COMMON /VALXXX/ KVAR,KUNK,KNA,KVAL(64),LKVAL
 
      DIMENSION IWRK(5)
 
C---  READ CHARACTER NUMBER.
      CALL SKNONB
      IF (IBUF(JBUF).EQ.KDSTAR.OR.IBUF(JBUF).EQ.KDNUM)  GO TO 2000
      IF (JIDAT.GE.LIDAT)  GOTO 2100
      JIDAT = JIDAT + 1
      JG = JIDAT
      JB = JBUF
      IB = 0
      IE = 0
  100 NOWC = IBUF(JBUF)
        IF (NOWC.EQ.KDCOM.OR.NOWC.EQ.KDLBRA.OR.
     *   NOWC.EQ.KBLANK)  GO TO 110
        IF (NOWC.EQ.KDSOL.OR.NOWC.EQ.KDAMP)  GOTO 700
        JBUF = JBUF + 1
        GO TO 100
C
  110 IF (JBUF.EQ.JB)  GO TO 710
      CALL DERNG (IB, IE, NC, JB, JBUF)
      IF (IB.EQ.0)  GOTO 850
      NV = 0
      DO 111 IC = IB, IE
        NV = MAX(NV, NSTAT(IC))
  111 CONTINUE
      JTYPC = ABS(ITYPC(IB))
      IF (IB.EQ.IE)  GOTO 112
      IF (JTYPC.GT.2)  GOTO 112
        MINTYP = 1
        MAXTYP = 2
        GOTO 114
  112 MINTYP = JTYPC
      MAXTYP = JTYPC
  114 DO 120 IC = IB, IE
        KTYPE = ABS(ITYPC(IC))
        IF (KTYPE.LT.MINTYP.OR.KTYPE.GT.MAXTYP)  GOTO 730
        IF (IDAT(IC).EQ.0)  GO TO 116
        IF (IULA.EQ.0)  GO TO 740
        CALL MESSB (64, IC, 1, 4, JB)
  116   IDAT(IC) = JG
  120   CONTINUE
      IF (IBUF(JBUF).NE.KDLBRA)  GO TO 130
      CALL ATTCOM (IDAT, LIDAT, JIDAT, IERR)
      IF (IERR.NE.0)  GO TO 910
      NOWC = IBUF(JBUF)
      IF (NOWC.EQ.KDCOM.OR.NOWC.EQ.KBLANK)  GO TO 130
      IF (NOWC.EQ.KDLBRA.OR.NOWC.EQ.KDSOL.OR.
     * NOWC.EQ.KDRANG.OR.NOWC.EQ.KDAMP)  GO TO 700
      GO TO 750
  130 IF (NOWC.EQ.KBLANK)  GO TO 1000
 
      NUMV = 0
      INBKT = 0
 
C---  READ AND STORE VALUES.
 
  190 IF (NUMV.GT.0.AND.(JTYPC.EQ.3.OR.JTYPC.EQ.4))  THEN
        CALL EXTRNG (IDAT, LIDAT, JIDAT, JSG, NUMV, IFIRST, ILAST,
     *   IWRK, IERR)
        IF (IERR.NE.0)  GOTO 2100
        NUMV = 0
      ENDIF
      JSG = 0
      ICODED = 0
      IVCOD = 0
      IUCOD = 0
      INFRNG = 0
      IFIRST = 0
      ILAST = 0
C
  200 JBUF = JBUF + 1
        JB = JBUF
        IF (KLPAR.NE.0)  THEN
          IF (NUMV.EQ.0)  IFIRST = 1
          IF (NUMV.GT.0)  ILAST = 1
        ENDIF
        KLPAR  = 0
        KRPAR = 0
C
C       FIND NEXT DELIMITER.
  210   NOWC = IBUF(JBUF)
        IF (NOWC.EQ.KBLANK.OR.NOWC.EQ.KDLBRA.OR.
     *   NOWC.EQ.KDSOL.OR.NOWC.EQ.KDRANG
     *   .OR.NOWC.EQ.KDAMP)  GO TO 214
 
C         EXTREME RANGES DENOTED BY "(" AND ")".
          IF (NOWC.EQ.KDLPAR.OR.NOWC.EQ.KDRPAR)  THEN
            IF (JTYPC.EQ.3.OR.JTYPC.EQ.4)  THEN
              IF (NOWC.EQ.KDLPAR)  THEN
C               CASE ( ONLY.
                IF (IBUF(JBUF+1).EQ.KBLANK)  THEN
                  IERRNO = 10
                  IPOINT = JBUF + 1
                  GOTO 800
                ENDIF
C               ALREADY WITHIN BRACKETS?
                IF (INBKT.GT.0)  THEN
                  IPOINT = JBUF
                  GOTO 785
                ENDIF
C               Check that character preceding "(" is numeric
                IF (JBUF.GT.JB.AND.ISNUM(IBUF(JBUF-1)).EQ.0) THEN
                  IPOINT = JBUF - 1
                  GOTO 785
                ENDIF
C               Check for case x(-y)
                IF (JBUF.GT.JB.AND.IBUF(JBUF+1).NE.KDRANG)  THEN
                  IPOINT = JBUF + 1
                  GOTO 785
                ENDIF
                KLPAR = 1
                INBKT = INBKT + 1
              ELSE
C               NO CORRESPONDING LEFT BRACKET.
                IF (INBKT.EQ.0)  THEN
                  IPOINT = JBUF
                  GOTO 785
                ENDIF
C               CASE () OR x(?).
                IF (IBUF(JBUF-1).EQ.KDLPAR .OR.
     *              (IBUF(JBUF-2).EQ.KDLPAR))  THEN
                  IPOINT = JBUF
                  GOTO 785
                ENDIF
C               CHECK FOR CASE (x-)y
                IF (NUMV.EQ.0.AND.IBUF(JBUF-1).NE.KDRANG)  THEN
                  IPOINT = JBUF
                  GOTO 785
                ENDIF
                KRPAR = 1
                INBKT = INBKT - 1
              ENDIF
            ELSE
C             NOT A NUMERIC CHARACTER. ERROR!
              GOTO 700
            ENDIF
            IF (JBUF.EQ.JB)  GOTO 200
            GOTO 230
          ENDIF
          IF (NOWC.EQ.KDCOM)  GO TO 700
C         INFINITE RANGES DENOTED BY "~".
          IF (NOWC.EQ.KDINF)  THEN
            IF (INKYST.EQ.0)  GOTO 780
            INFRNG = 1
            IF (JBUF.EQ.JB)  GOTO 200
            GOTO 230
          ENDIF
          GO TO 220
  214     IF (JBUF.NE.JB)  GO TO 230
          IF (NOWC.EQ.KDRANG.AND.(JTYPC.EQ.3.OR.JTYPC.EQ.4))  THEN
C           CHECK SYNTAX OF EXTREME RANGES.
            IF (INBKT.NE.0.AND.IBUF(JBUF+1).EQ.KBLANK)  THEN
              IERRNO = 10
              IPOINT = JBUF + 1
              GOTO 800
            ENDIF
            IF ((NUMV.GT.0.AND.IBUF(JBUF-1).EQ.KDLPAR) .OR.
     *        (NUMV.EQ.0.AND.IBUF(JBUF+1).EQ.KDRPAR))  GOTO 200
          ENDIF
          IF (NOWC.NE.KMINUS.AND.NOWC.NE.KNA)  GO TO 710
  220     JBUF = JBUF + 1
          GO TO 210
C
  230   LF = JBUF - JB
        IF (NOWC.EQ.KDRANG.AND.(JTYPC.EQ.3.OR.JTYPC.EQ.4))  THEN
C         CHECK SYNTAX OF EXTREME RANGES.
C         CHECK FOR CASE "(-" ONLY.
          IF (INBKT.NE.0.AND.IBUF(JBUF+1).EQ.KBLANK)  THEN
            IERRNO = 10
            IPOINT = JBUF + 1
            GOTO 800
          ENDIF
C         CHECK FOR CASE x(-y-.
          IF (NUMV.GT.0.AND.INBKT.NE.0)  THEN
            IPOINT = JBUF
            GOTO 785
          ENDIF
C         CHECK FOR CASE (x-y.
          IF (NUMV.EQ.0.AND.INBKT.GT.0.AND.IBUF(JBUF+1).NE.KDRPAR)  THEN
            IPOINT = JBUF + 1
            GOTO 785
          ENDIF
        ENDIF
        IF (KLPAR.NE.0.OR.KRPAR.NE.0)  JBUF = JBUF + 1
 
C       *** CHECK SYNTAX OF KEY STATES DIRECTIVE ***
C       IF PROCESSING A KEY STATES DIRECTIVE, UNORDERED MULTISTATES MUST BE
C       SEPARATED BY "&" OR "/", ORDERED MULTISTATES AND NUMERICS MUST BE
C       SEPARATED BY "-" OR "/"
        IF (INKYST.EQ.1)  THEN
          IF (JTYPC.EQ.1)  THEN
            IF (NOWC.NE.KDAMP.AND.NOWC.NE.KDSOL.AND.NOWC.NE.KBLANK)
     *        GOTO 700
          ELSEIF (JTYPC.EQ.2)  THEN 
            IF (NOWC.NE.KDRANG.AND.NOWC.NE.KDSOL.AND.NOWC.NE.KBLANK)
     *        GOTO 700
          ELSE 
            IF (NOWC.NE.KDRANG.AND.NOWC.NE.KDSOL.AND.NOWC.NE.KBLANK
     *        .AND.NOWC.NE.KDINF)  GOTO 700
          ENDIF
        ENDIF
 
        IF (JTYPC.GE.3)  GO TO 260
 
C       DECODE VALUE OF MULTISTATE CHARACTER.
        IF (LKVAL.LE.0)  THEN
          CALL IDKOD (IV, IBUF(JB), LF, IERR)
          IF (IERR.NE.0)  GO TO 300
          IF (IV.LE.0)  GOTO 760
        ELSE
          IF (LF.NE.1)  GO TO 760
          DO 250 IV = 1, NV
            IF (IBUF(JB).EQ.KVAL(IV)) GO TO 252
  250     CONTINUE
          IERR = 1
          GO TO 300
        ENDIF
  252   DO 253 IC = IB, IE
          IF (IV.GT.NSTAT(IC))  GOTO 795
  253   CONTINUE
        GOTO 400
 
  260   IF (JTYPC.EQ.4)  GO TO 280
        IF (JTYPC.EQ.5)  GO TO 315
C
C       DECODE INTEGER NUMERIC VALUE.
        CALL IDKOD (IV, IBUF(JB), LF, IERR)
        IF (IERR.NE.0)  GO TO 300
        GO TO 400
C
C       DECODE REAL NUMERIC VALUE.
  280   CALL RDKOD (RV, IBUF(JB), LF, IERR)
        IF (IERR.NE.0)  GO TO 300
        GO TO 400
C
C       TEST WHETHER VALUE IS VARIABLE, UNKNOWN, OR NOT APPLICABLE.
  300   IF (LF.NE.1)  GO TO 720
        IF (IBUF(JB).NE.KVAR)  GO TO 315
        DO 305 IC = IB, IE
          JTYPC = ITYPC(IC)
          IF (JTYPC.LT.0.OR.JTYPC.EQ.3.OR.JTYPC.EQ.4)  GO TO 760
  305   CONTINUE
C       VARIABLE MULTISTATE - CHECK FOR VALID CODING COMBINATIONS.
        IF (JSG.NE.0)  GOTO 770
        IF (IBUF(JBUF).EQ.KDRANG)  GOTO 700
        IF (ICODED.NE.0)  GOTO 770
C       EXPAND V TO ALL STATES. (SEE CODE AT LABEL 1100 FOR MORE)
        IVCOD = 1
        DO 306 IV = 1, NSTAT(IB)
          IF (JIDAT+3.GT.LIDAT)  GOTO 2100
          JSG = JIDAT + 1
          IDAT(JSG) = 3
          IDAT(JSG+1) = 1
          IDAT(JSG+2) = IV
          JIDAT = JIDAT + 3
306     CONTINUE
        GOTO 510
  315   IF (IBUF(JB).NE.KUNK)  GO TO 320
        IF (ICODED.NE.0)  GOTO 770
        IUCOD = 1
        ITS = 7
        GO TO 350
  320   IF (IBUF(JB).NE.KNA)  GO TO 720
        ITS = 8
  350   IF (JSG.NE.0)  GO TO 770
        IF (IBUF(JBUF).EQ.KDRANG)  GO TO 700
        IF (JIDAT+2.GT.LIDAT)  GOTO 2100
        JSG = JIDAT + 1
        IDAT(JSG+1) = ITS
        JIDAT = JIDAT + 2
        GO TO 500
 
C--     STORE VALID VALUE.
  400   IF (IUCOD.NE.0.OR.IVCOD.NE.0)  GOTO 770
        ICODED = 1
        IF (JSG.GT.0)  GO TO 450
C
C-      VALUE IS A SINGLE VALUE, OR FIRST OF A RANGE.
        IF (JIDAT+2.GT.LIDAT)  GOTO 2100
        JSG = JIDAT + 1
        IDAT(JSG+1) = 1
        IF (IBUF(JBUF).EQ.KDAMP)  IDAT(JSG+1) = 2
        IF (INFRNG.NE.0)  THEN
          IDAT(JSG+1) = 3
          INFRNG = 0
        ENDIF
        JIDAT = JIDAT + 2
        IF (IDAT(JSG+1).EQ.1.AND.JTYPC.GE.3)  GO TO 480
        IF (JIDAT.GE.LIDAT)  GOTO 2100
        JIDAT = JIDAT + 1
        IF (JTYPC.EQ.4)  THEN
          CALL RELOUT (RV, IDAT(JIDAT))
        ELSE
          IDAT(JIDAT) = IV
        ENDIF
        GO TO 500
 
C-      VALUE IS SECOND OR LATER OF A RANGE.
C       CHECK THAT RANGE SEPARATOR IS THE SAME AS THE FIRST ONE.
  450   ITS = IDAT(JSG+1)
        IF (IBUF(JBUF).EQ.KDRANG)  ITS = 1
        IF (IBUF(JBUF).EQ.KDAMP)  ITS = 2
        IF (ITS.NE.IDAT(JSG+1))  GO TO 700
 
        IF (ITS.EQ.1.AND.JTYPC.GE.3)  GO TO 470
 
C       CHECK VALIDITY OF DATA COMBINATION.
 
        IF (JTYPC.EQ.4)  GOTO 465
C
        ILCOM1 = 0
        ILCOM2 = 0
        ILCOM3 = 0
        JFV = JSG + 2
        DO 452 I = JFV, JIDAT
          IF (IV.NE.IDAT(I))  GOTO 452
            ILCOM1 = 1
            GOTO 453
  452     CONTINUE
  453   IF (IV.LE.IDAT(JIDAT))  ILCOM2 = 1
        IF (IV.LT.IDAT(JIDAT))  ILCOM3 = 1
        IF (ILCOM1.NE.0.OR.ILCOM2.NE.0.OR.ILCOM3.NE.0)  THEN
          DO 460 IC = IB, IE
            IF (ITYPC(IC).EQ.1)  THEN
              IF (ILCOM1.EQ.1)  GOTO 770
            ELSEIF (ITYPC(IC).EQ.2)  THEN
              IF (ILCOM2.EQ.1)  GOTO 770
            ELSEIF (ITYPC(IC).EQ.3)  THEN
              IF (ILCOM3.EQ.1)  GOTO 770
            ENDIF
  460     CONTINUE
        ENDIF
        IF (JIDAT.GE.LIDAT)  GOTO 2100
        JIDAT = JIDAT + 1
        IDAT(JIDAT) = IV
        GO TO 500
 
  465   IF (RV.LT.RELIN(IDAT(JIDAT)))  GOTO 770
        IF (JIDAT.GE.LIDAT)  GOTO 2100
        JIDAT = JIDAT + 1
        CALL RELOUT (RV, IDAT(JIDAT))
        GO TO 500
 
C       NUMERIC RANGES.
  470   IF (JTYPC.EQ.3)  THEN
          IF (IV.LT.IWRK(NUMV))  GOTO 770
        ELSE
          IF (RV.LT.RELIN(IWRK(NUMV))) GO TO 770
        ENDIF
  480   NUMV = NUMV + 1
        IF (NUMV.GT.5)  GOTO 790
        IF (JTYPC.EQ.3)  THEN
          IWRK(NUMV) = IV
        ELSE
          CALL RELOUT (RV, IWRK(NUMV))
        ENDIF
        GOTO 510
 
C-      STORE LENGTH OF SUBGROUP.
  500   IDAT(JSG) = JIDAT - JSG + 1
 
C-      READ AND STORE COMMENT (IF PRESENT).
  510   ICMT = 0
        IF (IBUF(JBUF).NE.KDLBRA)  GO TO 520
        IF (NUMV.GT.0.AND.(JTYPC.EQ.3.OR.JTYPC.EQ.4))  THEN
          CALL EXTRNG (IDAT, LIDAT, JIDAT, JSG, NUMV, IFIRST, ILAST,
     *     IWRK, IERR)
          IF (IERR.NE.0)  GOTO 2100
          NUMV = 0
        ENDIF
        ICMT = JIDAT + 1
        CALL ATTCOM (IDAT, LIDAT, JIDAT, IERR)
        IF (IERR.NE.0)  GO TO 910
        NOWC = IBUF(JBUF)
        IF (NOWC.EQ.KBLANK.OR.NOWC.EQ.KDSOL)  GO TO 520
        IF (NOWC.EQ.KDCOM.OR.NOWC.EQ.KDLBRA.OR.
     *   NOWC.EQ.KDRANG.OR.NOWC.EQ.KDAMP)  GO TO 700
        GO TO 750
C-
  520   NOWC = IBUF(JBUF)
        NEXTC = IBUF(JBUF+1)
        IF (NOWC.EQ.KBLANK) GOTO 1000
        IF ((NOWC.EQ.KDINF.AND.NEXTC.EQ.KBLANK) .OR.
     *      (NOWC.EQ.KDLPAR.AND.NEXTC.EQ.KBLANK) .OR.
     *      (NOWC.EQ.KDRPAR.AND.NEXTC.EQ.KBLANK))  THEN
          JBUF = JBUF + 1
          GO TO 1000
        ENDIF
        DO 530 IC = IB, IE
          IF (ITYPC(IC).LT.0)  GO TO 700
  530     CONTINUE
        IF (NOWC.NE.KDRANG.AND.NOWC.NE.KDAMP)  GOTO 190
C--
        GO TO 200
 
C--   ERROR IN CHARACTER OR VALUE.
  700 IERRNO = 31
      IPOINT = JBUF
      GO TO 800
  710 IERRNO = 10
      IPOINT = JBUF
      GO TO 800
  720 IERRNO = 12
      IPOINT = JB + IERR - 1
      GO TO 800
  730 IERRNO = 132
      IPOINT = JB
      GO TO 800
  740 IERRNO = 64
      CALL MESSB (IERRNO, IC, 1, 3, JB)
      GO TO 900
  750 IERRNO = 96
      IPOINT = JBUF
      GO TO 800
  760 IERRNO = 22
      IPOINT = JB
      GO TO 800
  770 IERRNO = 43
      IPOINT = JB
      GOTO 800
  780 IERRNO = 12
      IPOINT = JBUF
      GO TO 800
  785 IERRNO = 109
      GOTO 800
  790 IERRNO = 97
      IPOINT = JBUF
      GO TO 800
  795 IERRNO = 138
      IPOINT = JBUF - 1
      CALL MESSB (IERRNO, NSTAT(IC), 1, 3, IPOINT)
      GO TO 900
 
  800 CALL MESSA (IERRNO, 3, IPOINT)
      GOTO 900
 
  850 IE = 0
C
  900 INSIDE = 0
      GO TO 920
  910 INSIDE = 1
  920 DO 930 IC = IB, IE
        IF (IC.GE.1.AND.IC.LE.NC)  IDAT(IC) = -1
  930     CONTINUE
      JIDAT = JG - 1
      CALL ATTSK (INSIDE)
 
 1000 IF (NUMV.GT.0.AND.(JTYPC.EQ.3.OR.JTYPC.EQ.4))  THEN
        CALL EXTRNG (IDAT, LIDAT, JIDAT, JSG, NUMV, IFIRST, ILAST,
     *   IWRK, IERR)
        IF (IERR.NE.0)  GOTO 2100
        NUMV = 0
      ENDIF
 
C--   STORE LENGTH OF GROUP.
 1100 IDAT(JG) = JIDAT - JG + 1
 
C     CHECK VARIABLE CODED MULTISTATES FOR SAME NUMBERS OF STATES.
      IF (IVCOD.NE.0)  THEN
        DO 1150 IC = IB+1, IE
          IF (NSTAT(IC).EQ.NSTAT(IB))  GOTO 1150
C         CREATE NEW ENTRY IN IDAT.
          JIDAT = JIDAT + 1
          JG = JIDAT
          IDAT(IC) = JG
          DO 1200 IV = 1, NSTAT(IC)
            IF (JIDAT+3.GT.LIDAT)  GOTO 2100
            JSG = JIDAT + 1
            IDAT(JSG) = 3
            IDAT(JSG+1) = 1
            IDAT(JSG+2) = IV
            JIDAT = JIDAT + 3
 1200     CONTINUE
          IF (ICMT.GT.0)  THEN
            CALL COPIA(IDAT(ICMT), IDAT(JIDAT+1), IDAT(ICMT))
            JIDAT = JIDAT + IDAT(ICMT)
          ENDIF
          IDAT(JG) = JIDAT - JG + 1
 1150   CONTINUE
      ENDIF
 
C---
 2000 CONTINUE
      RETURN
 
 2100 CALL MESSB (35, LIDAT, 1, -1, 0)
 
      END
      SUBROUTINE RDINT (NUM, IMIN, IMAX, IDEF)                              DIRG
C
C* REVISED 26-JUL-89.
C* READS A SINGLE INTEGER VALUE.
C
C  NUM RETURNS THE VALUE.
C  IMIN RECEIVES THE MINIMUM ALLOWED VALUE.
C  IMAX RECEIVES THE MAXIMUM ALLOWED VALUE. IF IMAX.LE.IMIN,
C    THERE IS NO MAXIMUM VALUE.
C  IDEF RECEIVES THE DEFAULT VALUE. IF IDEF.LT.IMIN, THERE IS
C    NO DEFAULT.
C
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AFTER THE NUMBER, OR, IF THE NUMBER
C    WAS MISSING, AT THE START OF THE NEXT STAR-WORD.
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
C     LOCATE AND DECODE WORD.
      CALL NEXTWD (JE)
      IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 4
      CALL IDKOD (NUM, IBUF(JBUF), JE-JBUF, IERR)
      IF (IERR.GT.0)  GO TO 20
      IF (NUM.LT.IMIN .OR. (IMAX.GT.IMIN.AND.NUM.GT.IMAX))  GO TO 30
      GO TO 100
C
C     USE DEFAULT.
    4 IF (IDEF.LT.IMIN)  GO TO 10
      NUM = IDEF
      JE = JBUF
      GO TO 100
 
C     ERROR MESSAGES.
   10 IERRNO = 10
      IPOINT = JBUF - 1
      JE = JBUF
      GO TO 40
   20 IERRNO = 66
      IPOINT = JBUF + IERR - 1
      GO TO 40
   30 IERRNO = 67
      IPOINT = JBUF
 
   40 CALL MESSA (IERRNO, 3, IPOINT)
      GOTO 100
 
  100 JBUF = JE
      RETURN
      END
      SUBROUTINE RDTXT (ITERM, IDELIM, ITYPMKS, ICHKBKT, ITXT, LTXT,        DIRG
     * JTXT, IERR)
 
C  REVISED 7-MAR-00.
C  READS LINES OF TEXT UP TO THE NEXT DELIMITER. TRAILING BLANKS ARE
C    REMOVED.
 
C  ITERM RECEIVES
C    0 IF THE DELIMITER MUST BE A BLANK-STAR
C    1 IF IT MAY BE EITHER BLANK-STAR OR BLANK-NUMERO.
C    2 IF THE DELIMITER MUST BE THAT SPECIFIED IN IDELIM
C  IDELIM RECEIVES THE DELIMITER IF ITERM IS 2.
C  ITYPMKS RECEIVES WHETHER THIS IS READING THE "TYPESETTING MARKS" DIRECTIVE.
C   IN BINARY MODE.
C   IF TRUE, THE BLANK NORMALLY APPENDED TO INPUT RECORDS IS IGNORED TO AVOID
C   UNWANTED BLANKS WITHIN THE TYPESETTING STRINGS.
C  ICHKBKT RECEIVES WHETHER TO CHECK FOR MATCHING ANGLE BRACKETS.
C  ITXT RETURNS THE TEXT.
C  LTXT RECEIVES THE LENGTH OF ITXT.
C  JTXT RETURNS THE LENGTH OF TEXT READ.
C  IERR RETURNS 1 IF THE TEXT IS TOO LONG, 0 OTHERWISE.
 
 
      DIMENSION ITXT(LTXT)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /EOFXXX/ IEOF
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
 
      IBKT = 0
      IERR = 0
      JTXT = 3
C     JBTXT = STARTING LOCATION OF TEXT IN ITXT
      JBTXT = 4
      IEND = ITERM
      CALL SKNONB
      NEWREC = 0
      LASTCH = KBLANK
 
      IF (ITYPMKS.NE.0)  THEN
C       CHECK FOR END OF CURRENT ITEM BEFORE REMOVING TRAILING BLANK
        IF (IBUF(JBUF).EQ.KDSTAR .OR. IBUF(JBUF).EQ.KDNUM) GOTO 5
 
C       STRIP TRAILING BLANK IF THIS IS WITHIN "TYPESETTING MARKS" DIRECTIVE.
        IF (IBUF(JEDAT).EQ.KBLANK) JEDAT = JEDAT - 1
      ENDIF
 
    5 IF (IEND.EQ.2)  THEN
        IF (IBUF(JBUF).NE.IDELIM)  THEN
          IEND = 1
        ELSE
          JBUF = JBUF + 1
          IF (JBUF.GT.JEDAT)  THEN
            CALL RDBUF
            NEWREC = 1
C           FORCE END OF TEXT IF END-OF-FILE.
            IF (IEOF.NE.0)  IEND = 1
          ENDIF
        ENDIF
      ENDIF
 
      INBRACE  = 0
      INCMT = 0
   10 IF ((IEND.LE.1.AND.LASTCH.EQ.KBLANK.AND.IBUF(JBUF).EQ.KDSTAR) .OR.
     *    (IEND.EQ.1.AND.LASTCH.EQ.KBLANK.AND.IBUF(JBUF).EQ.KDNUM)) THEN
        GOTO 50
      ELSEIF (IEND.EQ.2.AND.IBUF(JBUF).EQ.IDELIM)  THEN
        GOTO 40
      ENDIF
        IF (JTXT.GE.LTXT)  THEN
          IERR = 1
          GOTO 100
        ENDIF
        IF (ITYPMKS.NE.0 .AND. NEWREC.NE.0) THEN
C         REMOVE TERMINATING BLANK.
          IF (IBUF(JEDAT).EQ.KBLANK) JEDAT = JEDAT - 1
          NEWREC = 0
        ENDIF
        JTXT = JTXT + 1
        ITXT(JTXT) = IBUF(JBUF)
        LASTCH = IBUF(JBUF)
C       Check for matching {}.
        IF (JTXT.EQ.JBTXT) THEN
          IF (ITXT(JTXT).EQ.KLBRACE) THEN
            INBRACE = INBRACE + 1
          ELSEIF (ITXT(JTXT).EQ.KRBRACE) THEN
            INBRACE = INBRACE - 1
          ENDIF
        ELSE
          IF (ITXT(JTXT).EQ.KLBRACE.AND.ITXT(JTXT-1).NE.KDBSLSH) THEN
            INBRACE = INBRACE + 1
          ELSEIF (ITXT(JTXT).EQ.KRBRACE.AND.
     *            ITXT(JTXT-1).NE.KDBSLSH) THEN
            INBRACE = INBRACE - 1
          ENDIF
        ENDIF
C       Check for matching <>.
        IF (ICHKBKT.NE.0) THEN
          IF (JTXT.EQ.1) THEN
            IF (ITXT(JTXT).EQ.KDLBRA) THEN
              INCMT = INCMT + 1
            ELSEIF (ITXT(JTXT).EQ.KDRBRA) THEN
              INCMT = INCMT - 1
            ENDIF
          ELSE
            IF (ITXT(JTXT).EQ.KDLBRA.AND.ITXT(JTXT-1).NE.KVERT) THEN
              INCMT = INCMT + 1
            ELSEIF (ITXT(JTXT).EQ.KDRBRA.AND.ITXT(JTXT-1).NE.KVERT) THEN
              INCMT = INCMT - 1
            ENDIF
          ENDIF
        ENDIF
        JBUF = JBUF + 1
        IF (JBUF.GT.JEDAT)  THEN
          CALL RDBUF
          NEWREC = 1
C         FORCE END OF TEXT IF END-OF-FILE.
          IF (IEND.EQ.2.AND.IEOF.NE.0)  THEN
            IEND = 1
            CALL MESSA (60, 3, JBUF-1)
          ENDIF
        ENDIF
        GOTO 10
 
C     WHEN DELIMITER USED, SKIP TO NEXT * OR #.
   40 JBUF = JBUF + 1
   41 CALL NEXTWD(JE)
        IF (IBUF(JBUF).EQ.KDSTAR .OR. IBUF(JBUF).EQ.KDNUM)  GOTO 70
        JBUF = JE
        GOTO 41
 
C     IF NO DELIMITER, REMOVE TRAILING BLANKS.
   50 L = JTXT
      DO 60 I = L, 4, -1
        IF (ITXT(I).NE.KBLANK)  GOTO 70
        JTXT = JTXT - 1
   60   CONTINUE
 
   70 IF (JTXT.GT.3)  THEN
        ITXT(1) = JTXT
        ITXT(2) = JTXT - 1
        ITXT(3) = 1
      ELSE
        JTXT = 0
      ENDIF
 
C     If this is not a TYPESETTING MARKS directive, report unmatched braces.
      IF (ITYPMKS.EQ.0.AND.INBRACE.NE.0)  CALL MESSA (110, 3, JBUF-1)
 
C     Report unmatched angle brackets.
      IF (INCMT.NE.0)  CALL MESSA (126, 3, JBUF-1)
 
  100 RETURN
      END
      SUBROUTINE SKDELW (ITERM)                                             DIRG
C
C* REVISED 18-OCT-91.
C* SKIPS TO THE START OF THE NEXT WORD STARTING WITH A DELIMITER.
C
C  ITERM RECEIVES 0 IF THE DELIMITER MUST BE STAR (KDSTAR) OR 1 IF THE
C    DELIMITER MAY BE STAR OR NUMERO (KDNUM).
C
C  THE DELIMITER MAY BE AT THE CURRENT POSITION OF JBUF ON ENTRY.
C  NEW RECORDS ARE READ IF REQUIRED.
C  ON EXIT, JBUF IS POSITIONED AT THE DELIMITER.
C
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
 
C     MAXIMUM NUMBER OF WORDS TO BE SKIPPED.
      DATA MAXWSK/1500/
C
      NWSK = 0
      IF (JBUF.EQ.JBDAT)  GO TO 100
      IF (IBUF(JBUF-1).NE.KBLANK)  CALL SKB
C
      knt = 0
 
  100 CALL SKNONB
        IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 200
        IF (IBUF(JBUF).NE.KDNUM)  GO TO 150
        IF (ITERM.NE.0)  GO TO 200
C       CALL MESSA (31, 3, JBUF)
  150   CALL SKB
        NWSK = NWSK + 1
        IF (NWSK.GT.MAXWSK)  GO TO 300
        GO TO 100
C
  200 RETURN
 
  300 CALL BMESS
      CALL MESSB (77, MAXWSK, 1, -3, JBUF)
      STOP
      END
