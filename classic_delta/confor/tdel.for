      SUBROUTINE CMPATT (ITM, LIDAT, IC1, IC2, IMPFLG1, IMPFLG2,            TDEL
     * ISAME)
 
C  REVISED 28-MAR-91.
C  COMPARES THE ATTRIBUTES OF TWO CHARACTERS IN AN ITEM.
 
C  ITM RECEIVES THE ITEM.
C  LIDAT RECEIVES THE LENGTH OF ITM.
C  IC1 RECEIVES THE FIRST CHARACTER NUMBER.
C  IC2 RECEIVES THE SECOND CHARACTER NUMBER.
C  IMPFLG1 RECEIVES THE IMPLICIT FLAG CORRESPONDING TO IC1.
C  IMPFLG2 RECEIVES THE IMPLICIT FLAG CORRESPONDING TO IC2
C  ISAME RETURNS 1 IF THE ATTRIBUTES ARE IDENTICAL, 0 OTHERWISE.
 
      DIMENSION ITM(LIDAT)
 
      ISAME = 0
 
      JG1 = ITM(IC1)
      JG2 = ITM(IC2)
      IF (JG1.EQ.JG2)  GOTO 30
      L1 = ITM(JG1)
      L2 = ITM(JG2)
      IF (L1.NE.L2)  GOTO 100
      L = L1 - 1
      DO 20 I = 1, L
        IF (ITM(JG1+I).NE.ITM(JG2+I))  GOTO 100
   20   CONTINUE
      IF (IMPFLG1.NE.IMPFLG2)  GOTO 100
 
   30 ISAME = 1
 
  100 RETURN
      END
      SUBROUTINE DELA (ITM, IDAT, LIDAT, ITYPC, NSTAT, NDEC, IMPFLG,        TDEL
     * ITMADD, ISRTS, NC, ITYPMK, IC, JC1, JC2, ITIMPL, IOMSTC, IPITEM,
     * JIM, IVARIT, IOUNC, LUNTYP)
 
C* REVISED 21-JUN-99.
C* OUTPUTS AN ATTRIBUTE IN DELTA FORMAT.
 
C  ITM RECEIVES THE ITEM.
C  IDAT RECEIVES WORKING SPACE OF LENGTH LIDAT.
C  LIDAT RECEIVES THE LENGTH OF ITM.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  NSTAT RECEIVES NUMBERS OF STATES.
C  NDEC RECEIVES THE NUMBER OF DECIMAL PLACES FOR OUTPUT.
C  IMPFLG RECEIVES WHETHER IMPLICIT VALUES HAVE BEEN INSERTED.
C  ITMADD RECEIVES WHERE DATA HAS BEEN COPIED INTO A VARIANT ITEM.
C  ISRTS RECEIVES WHETHER TO SORT CHARACTER STATE CODES.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  IC RECEIVES THE OLD CHARACTER NUMBER.
C  JC1 RECEIVES THE FIRST NEW CHARACTER NUMBER OF THE RANGE.
C  JC2 RECEIVES THE LAST NEW CHARACTER NUMBER OF THE RANGE.
C  ITIMPL RECEIVES WHETHER IMPLICIT VALUES ARE TO BE INSERTED ON OUTPUT.
C  IOMSTC RECEIVES WHETHER TO OMIT STATE CODES.
C  IPITEM RECEIVES 1 IF ITEM IS TO BE FORMATTED FOR PRINT FILE, 0 IF
C    FOR OUTPUT FILE.
C  IVARIT RECEIVES 1 IF THE ITEM IS A VARIANT, 0 OTHERWISE.
C  JIM RECEIVES THE MASKED-IN ITEM NUMBER.
C  IOUNC RECEIVES WHETHER TO OUTPUT UNCODED VALUES.
C  LUNTYP RECEIVES THE TYPE OF THE OUTPUT LOGICAL UNIT.
 
      DIMENSION ITM(LIDAT),IDAT(LIDAT),ITYPC(NC),NSTAT(NC),NDEC(NC),
     * IMPFLG(NC),ITMADD(NC),ISRTS(NC),ITYPMK(LIDAT),JVAL(2)
 
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /ITSXXX/ ITSS
      COMMON /TNAMEX/ TNAME,LTNAME
        CHARACTER*256 TNAME
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
      COMMON /VALXXX/ KVAR,KUNK,KNA,KVAL(64),LKVAL
 
C--   CHARACTER NUMBER.
      IF (ITM(IC).EQ.0.AND.IOUNC.EQ.0)  GO TO 2000
      IF (IVARIT.NE.0.AND.ITMADD(IC).EQ.0)  GOTO 5
      IF (IPITEM.EQ.0.AND.IMPFLG(IC).EQ.1.AND.ITIMPL.EQ.0)  GOTO 2000
    5 INFRNG = 0
      IWFLAG = 0
      CALL JSTI (JC1, -1, LUNTYP)
      IF (JC1.EQ.JC2)  GOTO 10
      CALL PRANGE (1, ITYPMK, LIDAT, LUNTYP)
      CALL JSTI (JC2, -1, LUNTYP)
   10 IF (ITM(IC).GT.0)  GO TO 20
      IF (ITM(IC).EQ.0) THEN
C       Output uncoded value.
        CALL JSTS (KDCOM, -1, LUNTYP)
        CALL JSTS (KUNK, -1, LUNTYP)
      ELSE
C       MAKE ATTRIBUTE ILLEGAL (TWO COMMAS).
        CALL JSTS (KDCOM, -1, LUNTYP)
        CALL JSTS (KDCOM, -1, LUNTYP)
      ENDIF
      GO TO 1000
C
C--   VALUES.
   20 JG = ITM(IC)
      JSG = JG + 1
      JGN = JG + ITM(JG)
      ISG = 0
      ICHAR = 1
      JTYPC = ITYPC(IC)
 
C     INSERT NEW STATE ORDER INTO ITEM.
      NSG = 0
      NPSEUD = 0
   30 IF (JSG.GE.JGN)  GOTO 41
        ITS = ITM(JSG+1)
        IF (ITS.LE.0)  GOTO 40
        IF (ITS.GT.ITSS)  THEN
          NPSEUD = NPSEUD + 1
          GOTO 40
        ENDIF
        NSG = NSG + 1
        LASTSG = JSG
        I = JSG + 2
        NE = JSG + ITM(JSG) - 1
        NV = 0
   32   IV = ITM(I)
        NV = NV + 1
        IF (I.GE.NE)  GOTO 38
        I = I + 1
        GOTO 32
   38   IF (ISRTS(IC).NE.0)  CALL SORTI (ITM(JSG+2), NV)
   40   JSG = JSG + ITM(JSG)
        GOTO 30
 
   41 JSG = JG + 1
      JDAT = 1
 
      IF (ISRTS(IC).EQ.0.OR.JTYPC.GE.3.OR.NSG.LE.1)  THEN
        IF (ITM(JG).GT.1)  CALL COPIA (ITM(JSG), IDAT(JDAT), ITM(JG)-1)
      ELSE
C       SORT SUBGROUPS OF ATTRIBUTE.
        KSG = JG + 1
        IF (ITM(KSG+1).EQ.0)  THEN
C         COPY COMMENT ASSOCIATED WITH CHARACTER.
          CALL COPIA (ITM(KSG), IDAT(JDAT), ITM(KSG))
          JDAT = JDAT + ITM(KSG)
          KSG = KSG + ITM(KSG)
        ENDIF
        DO 50 K = 1, NSG
          MIN = NSTAT(IC) + 1
          JSG = KSG
   43     IF (JSG.GE.JGN)  GOTO 45
            ITS = ITM(JSG+1)
            IF (ITS.GT.0.AND.ITS.LE.ITSS)  THEN
              IF (ITM(JSG+2).LT.MIN)  THEN
                MIN = ITM(JSG+2)
                IPTR = JSG
              ENDIF
            ENDIF
            JSG = JSG + ITM(JSG)
            GOTO 43
   45     L = ITM(IPTR)
          CALL COPIA (ITM(IPTR), IDAT(JDAT), L)
          JDAT = JDAT + L
          ITM(IPTR+1) = 0
C         IF NEXT SUBGROUP IS A COMMENT, COPY IT AS WELL.
          NXT = IPTR + L
          IF (NXT.GE.JGN)  GOTO 50
          IF (ITM(NXT+1).EQ.0)  THEN
            IF (IPTR.EQ.LASTSG.AND.K.NE.NSG)  IWFLAG = 1
            L = ITM(NXT)
            CALL COPIA (ITM(NXT), IDAT(JDAT), L)
            JDAT = JDAT + L
          ENDIF
   50   CONTINUE
        IF (NPSEUD.GT.0)  THEN
          JSG = KSG
   55     IF (JSG.GE.JGN)  GOTO 56
            ITS = ITM(JSG+1)
            IF (ITS.GT.ITSS)  THEN
              CALL COPIA (ITM(JSG), IDAT(JDAT), ITM(JSG))
              JDAT = JDAT + ITM(JSG)
            ENDIF
            JSG = JSG + ITM(JSG)
            GOTO 55
        ENDIF
   56   CONTINUE
      ENDIF
 
C     OUTPUT DELTA FORMAT.
      JSG = 1
      JGN = ITM(JG)
   60 IF (JSG.GE.JGN)  GOTO 1000
        ISG = ISG + 1
        ITS = IDAT(JSG+1)
        IF (ITS.GT.0)  GO TO 70
C
C-      COMMENT.
        IF (ITS.LT.0)  GO TO 300
        IF (JTYPC.NE.5.AND.IOUNC.NE.0.AND.ISG.EQ.1) THEN
C         Check for a comment only. If so, output U<comment>
          IF (JSG+IDAT(JSG).GE.JGN) THEN
            CALL JSTS (KDCOM, -1, LUNTYP)
            CALL JSTS (KUNK, -1, LUNTYP)
          ENDIF
        ENDIF
        CALL JSTOTP (IDAT(JSG+2), IDAT(JSG)-2, -1, ITYPMK, LIDAT,
     *   LUNTYP, 0, 0)
        IF (ISG.NE.1)  ICHAR = 0
        GO TO 300
C
   70   IF (IVARIT.NE.0.AND.ITMADD(IC).EQ.0)  GOTO 75
        IF (IPITEM.EQ.0.AND.IMPFLG(IC).GT.0.AND.ITIMPL.EQ.0)  GOTO 1000
   75   IF (ICHAR.EQ.0)  CALL JSTS (KDSOL, -1, LUNTYP)
        IF (ICHAR.NE.0)  CALL JSTS (KDCOM, -1, LUNTYP)
        ICHAR = 0
        IF (ITS.GT.ITSS)  GO TO 200
C
C-    ORDINARY VALUES.
        INFRNG = 0
        IF (ITS.EQ.3)  INFRNG = 1
        I = JSG + 2
        NE = JSG + IDAT(JSG) - 1
        IF (ITS.EQ.1.AND.JTYPC.GE.3) GOTO 180
        IF (JTYPC.GE.4)  GO TO 150
 
   90   IV = IDAT(I)
          IF (JTYPC.GE.3.OR.LKVAL.LE.0.OR.IOMSTC.NE.0)  THEN
            IF (INFRNG.NE.0.AND.ISG.EQ.1)  THEN
              CALL JSTS (KDINF, -1, LUNTYP)
              INFRNG = 0
            ENDIF
            CALL JSTI (IV, -1, LUNTYP)
          ELSE
            CALL JSTS (KVAL(IV), -1, LUNTYP)
          ENDIF
          IF (I.GE.NE)  GO TO 300
          CALL PRANGE (ITS, ITYPMK, LIDAT, LUNTYP)
          I = I + 1
          GO TO 90
 
  150   IF (INFRNG.NE.0.AND.ISG.EQ.1)  THEN
            CALL JSTS (KDINF, -1, LUNTYP)
            INFRNG = 0
          ENDIF
  160     CALL JSTR (RELIN(IDAT(I)), NDEC(IC), -1, LUNTYP, 0)
          IF (I.GE.NE)  GO TO 300
          CALL PRANGE (ITS, ITYPMK, LIDAT, LUNTYP)
          I = I + 1
        GO TO 160
 
C       NUMERIC RANGES.
  180   CALL DELRNG (JTYPC, NDEC(IC), ITYPMK, LIDAT, IDAT(JSG+2),
     *   IDAT(JSG)-2, LUNTYP, 0)
        GOTO 300
C
C-      SPECIAL VALUES.
  200   I = ITS - ITSS
        GO TO (210,220,230), I
  210   CALL JSTS (KVAR, -1, LUNTYP)
        GO TO 300
  220   CALL JSTS (KUNK, -1, LUNTYP)
        GO TO 300
  230   IF (ITPSET.GT.0 .AND. LUNTYP.EQ.3)  GO TO 232
        CALL JSTS (KNA, -1, LUNTYP)
        GO TO 300
C       [X-]
  232   CALL JSTTPS (1, ITYPMK, LIDAT, NTYPMK, LUNTYP)
C-
  300   JSG = JSG + IDAT(JSG)
        GO TO 60
C--
 1000 IF (INFRNG.NE.0)  CALL JSTS (KDINF, -1, LUNTYP)
      CALL ENDWD (LUNTYP)
      IF (IWFLAG.NE.0)  THEN
C        JVAL(1) = JIM
        JVAL(1) = JC1
        CALL MESSC (115, JVAL, 1, 2, 0, TNAME, LTNAME, 1)
      ENDIF
 
 2000 RETURN
      END
      SUBROUTINE DELCHA (ITYPC, NSTAT, KSTAT, ICDES, LCDES, SCALF, NC,      TDEL
     * IKEYCH, IKEYST, KCOM, ICHSEQ, IAS, MS, ISBND, ICHHD, ITYPMK,
     * LIDAT, ICSTR, LCSTR, IC, JC, KS, IPOLD, IOMSTC, ISCALC,
     * JHD, LUNTYP, IOMNSC, IHTMBKT)
 
C* REVISED 20-JUL-98.
C* OUTPUTS A CHARACTER DESCRIPTION, AND HEADING IF REQUIRED.
 
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  KSTAT RECEIVES NUMBERS OF KEY STATES.
C  ICDES RECEIVES THE STARTING POSITIONS OF THE CHARACTER DESCRIPTIONS.
C  LCDES RECEIVES THE LENGTHS OF THE CHARACTER DESCRIPTIONS.
C  SCALF RECEIVES SCALING FACTORS FOR REAL NUMERIC CHARACTERS.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  IKEYCH RECEIVES WHETHER THIS IS A KEY CHARACTER LIST.
C  IKEYST RECEIVES WHETHER TO OUTPUT KEY STATE DESCRIPTIONS.
C  KCOM RECEIVES THE COMMA CHARACTER TO BE USED TO SEPARATE STATE DESCRIPTIONS.
C  ICHSEQ RECEIVES WHETHER CHARACTER SEQUENCE NUMBERS ARE REQUIRED
C    IN DELTA FORMAT OUTPUT.
C  IAS RECEIVES WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C  ISBND RECEIVES KEY STATE BOUNDARIES.
C  ICHHD RECEIVES THE CHARACTER HEADINGS (SEE SUBR. RDSENL).
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  LIDAT RECEIVES THE (MAXIMUM) LENGTH OF ICHHD.
C  ICSTR. IF ISTYPE.EQ.1, ICSTR RECEIVES THE CHARACTER DESCRIPTIONS.
C    IF ISTYPE.NE.1, ICSTR IS WORKING SPACE. SEE SUBR. FETCHC.
C  LCSTR RECEIVES THE LENGTH OF ICSTR.
C  IC RECEIVES THE OLD CHARACTER NUMBER.
C  JC RECEIVES THE NEW CHARACTER NUMBER.
C  KS RECEIVES THE STARTING VALUE FOR STATE NUMBERS.
C  IPOLD RECEIVES A FLAG INDICATING WHETHER THE OLD CHARACTER NUMBER
C    IS TO BE PRINTED.
C  IOMSTC RECEIVES WHETHER TO OMIT STATE CODES.
C  ISCALC RECEIVES WHETHER REAL NUMERIC CHARACTERS HAVE BEEN SCALED.
C  JHD RECEIVES THE LOCATION OF THE HEADING TO BE PRINTED, OR 0 IF NONE.
C   IT RETURNS 0.
C  LUNTYP RECEIVES THE TYPE OF THE OUTPUT LOGICAL UNIT.
C  IOMNSC RECEIVES WHETHER TO OMIT INNER COMMENTS.
C  IHTMBKT RECEIVES WHETHER TO REPLACE ANGLE BRACKETS WITH THEIR HTML EQUIVALENT.
 
      DIMENSION ITYPC(NC),NSTAT(NC),KSTAT(NC),ICDES(NC),LCDES(NC),
     * SCALF(NC),IAS(MS),ISBND(LIDAT),ICHHD(LIDAT),
     * ITYPMK(LIDAT),ICSTR(LCSTR)
 
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
      COMMON /VALXXX/ KVAR,KUNK,KNA,KVAL(64),LKVAL
 
C--   GET CHARACTER DESCRIPTION.
      CALL FETCHC (ICSTR, LCSTR, ICDES, LCDES, NC, IC, IAC, IAS, MS)
 
C--   OUTPUT FEATURE DESCRIPTION AND HEADING (IF REQUIRED).
      PSEQ = 0.
      INDSEQ = 0
      IF (ITPSET.GT.0 .AND. LUNTYP.EQ.3)  GO TO 10
      IF (ICHSEQ.GT.0.AND.LUNTYP.EQ.4)  THEN
        PSEQ = JC
        INDSEQ = 8
      ENDIF
      INDEN(LUNTYP) = 10 + INDSEQ
      IF (JHD.LE.0 .OR. LUNTYP.NE.3)  GO TO 6
      CALL BLKLIN (2, 6, LUNTYP)
      CALL INDENT (0, LUNTYP)
      ICAP = 1
      CALL WSENT (ICHHD(JHD), LIDAT, 0, 0, 0, 0, 0, ITYPMK, LIDAT,
     * LUNTYP)
    6 CALL BLKLIN (1, 3, LUNTYP)
      CALL INDENT (INDSEQ, LUNTYP)
      GO TO 20
   10 INDEN(LUNTYP) = 0
      CALL BLKLIN (1, 0, LUNTYP)
C     [g]
      CALL JSTTPS (2, ITYPMK, LIDAT, NTYPMK, LUNTYP)
      IF (JHD.GT.0)  THEN
C       [0'i][1~p][3g]
        CALL JSTTPS (4, ITYPMK, LIDAT, NTYPMK, LUNTYP)
        CALL WSENT (ICHHD(JHD), LIDAT, 0, 0, 0, 0, 2, ITYPMK, LIDAT,
     *   LUNTYP)
C       [0.5~'p]
        CALL JSTTPS (5, ITYPMK, LIDAT, NTYPMK, LUNTYP)
      ENDIF
C     TYPESETTING MARKS FOR CHARACTERS.
      CALL JSTTPS (6, ITYPMK, LIDAT, NTYPMK, LUNTYP)
   20 CALL JSTS (KDNUM, -1, LUNTYP)
      CALL JSTI (JC, -1, LUNTYP)
      IF (IPOLD.EQ.0)  GO TO 22
      CALL JSTS (KLPAR, -1, LUNTYP)
      CALL JSTI (IC, -1, LUNTYP)
      CALL JSTS (KRPAR, -1, LUNTYP)
   22 IF (ISCALC.NE.0.AND.SCALF(IC).NE.1.)  THEN
        CALL JSTS (KDINF, 0, LUNTYP)
      ELSE
        CALL JSTS (KDSTOP, 0, LUNTYP)
      ENDIF
      IF (LUNTYP.EQ.3)  ICAP = 1
 
C     SET FLAG FOR HANDLING OF COMMENTS. DEFAULT IS TO RETAIN COMMENTS
C     WITH ANGLE BRACKETS. IF "OMIT INNER COMMENTS" IS ACTIVE, INNER 
C     COMMENTS ARE REMOVED.
      ICOMM = 1
      IF (IOMNSC.NE.0)  ICOMM = 3
      IF (IHTMBKT.NE.0)  ICOMM = 4
      IF (IOMNSC.NE.0.AND.IHTMBKT.NE.0)  ICOMM = 5
      CALL WSENT (ICSTR(IAC), LCSTR, ICOMM, 0, 0, 0, -1, ITYPMK, LIDAT,
     *  LUNTYP)
      CALL JSTS (KDSOL, 1, LUNTYP)
 
C--   OUTPUT STATE DESCRIPTIONS.
      NS = NSTAT(IC)
      IF (IKEYCH.NE.0.OR.IKEYST.NE.0)  NS = KSTAT(IC)
      IF (NS.LE.0)  GO TO 1000
C
      JTYPC = IABS(ITYPC(IC))
      IF (ISBND(IC).NE.0.AND.IKEYST.NE.0.AND.IKEYCH.EQ.0)  GOTO 200
      DO 100 IS = 1, NS
        IF (ITPSET.GT.0 .AND. LUNTYP.EQ.3)  GO TO 30
        CALL INDENT (7+INDSEQ, LUNTYP)
        GO TO 40
C       [n][1<]
   30   CALL JSTTPS (7, ITYPMK, LIDAT, NTYPMK, LUNTYP)
   40   IF (JTYPC.GE.3.AND.NS.LE.1)  GO TO 50
        IF (LKVAL.LE.0.OR.IOMSTC.NE.0)  THEN
          CALL JSTI (KS+IS-1, -1, LUNTYP)
        ELSE
          CALL JSTS (KVAL(IS), -1, LUNTYP)
        ENDIF
        CALL JSTS (KDSTOP, 0, LUNTYP)
   50   JS = IS
        I = IAS(JS)
        CALL WSENT (ICSTR(I), LCSTR, ICOMM, 0, 0, 0, -1, ITYPMK, LIDAT,
     *    LUNTYP)
  100   CALL JSTS (KDSOL, 1, LUNTYP)
      GOTO 1000
 
C     KEY STATE DESCRIPTIONS.
  200 JSG = ISBND(IC) + 1
      DO 500 JS = 1, NS
        IF (ITPSET.GT.0 .AND. LUNTYP.EQ.3)  GO TO 210
        CALL INDENT (7+INDSEQ, LUNTYP)
        GO TO 220
C       [n][1<]
  210   CALL JSTTPS (7, ITYPMK, LIDAT, NTYPMK, LUNTYP)
  220   IF (LKVAL.LE.0.OR.IOMSTC.NE.0)  THEN
          CALL JSTI (KS+JS-1, -1, LUNTYP)
        ELSE
          CALL JSTS (KVAL(JS), -1, LUNTYP)
        ENDIF
        CALL JSTS (KDSTOP, 0, LUNTYP)
 
C--     NEW STATES.
        NB = JSG + 2
        NE = JSG + ISBND(JSG) - 1
        ITS = ISBND(JSG+1)
        IF (JTYPC.GE.3)  GOTO 300
C
C-      MULTISTATE.
        DO 230 J = NB, NE
          IS = ISBND(J)
          I = IAS(IS)
          CALL WSENT (ICSTR(I), LCSTR, ICOMM, 0, 0, 0, -1, ITYPMK,
     *     LIDAT, LUNTYP)
          IF (J.EQ.NE)  GOTO 230
          IF (JTYPC.EQ.2)  GOTO 224
          CALL JSTWD (KCOM, 0, ITYPMK, LIDAT, LUNTYP)
          CALL JSTWD (1, 0, ITYPMK, LIDAT, LUNTYP)
          GOTO 230
  224     CALL ENDWD (LUNTYP)
          CALL JSTWD (2, 0, ITYPMK, LIDAT, LUNTYP)
  230     CONTINUE
        GOTO 400
C
C-      NUMERIC.
  300   IF (NSTAT(IC).EQ.1)  I1 = IAS(1)
        IF (JTYPC.EQ.4)  GOTO 310
        VMIN = ISBND(NB)
        VMAX = ISBND(NE)
        GOTO 320
  310   VMIN = RELIN (ISBND(NB))
        VMAX = RELIN (ISBND(NE))
C
 320    IF (NE.GT.NB)  GOTO 340
C       ONE VALUE.
        IE = -1
        IF (JS.EQ.1.AND.ITS.EQ.3)  CALL JSTWD (12, 0, ITYPMK, LIDAT,
     *   LUNTYP)
        CALL JSTR (VMIN, -5, 0, LUNTYP, 1)
        IF (JS.EQ.NS.AND.ITS.EQ.3)  IE = 0
        IF (NSTAT(IC).NE.1)  GOTO 325
        CALL WSENT (ICSTR(I1), LCSTR, ICOMM, 0, 0, 0, IE, ITYPMK, LIDAT,
     *   LUNTYP)
  325   IF (IE.GE.0)  CALL JSTWD (13, 0, ITYPMK, LIDAT, LUNTYP)
        GOTO 400
C
C       MORE THAN ONE VALUE.
  340   CALL JSTR (VMIN, -5, 0, LUNTYP, 1)
        CALL JSTWD (2, 0, ITYPMK, LIDAT, LUNTYP)
        CALL JSTR (VMAX, -5, 0, LUNTYP, 1)
        IF (NSTAT(IC).NE.1)  GOTO 400
        CALL WSENT (ICSTR(I1), LCSTR, ICOMM, 0, 0, 0, -1, ITYPMK, LIDAT,
     *   LUNTYP)
C--
  400   CALL JSTS (KDSOL, 1, LUNTYP)
        IF (ISBND(IC).GT.0)  JSG = JSG + ISBND(JSG)
  500 CONTINUE
 
C--
 1000 INDEN(LUNTYP) = 0
      JHD = 0
      RETURN
      END
      SUBROUTINE DELCRD                                                     TDEL
 
C* REVISED 23-APR-91.
C* OUTPUTS DELTA CONTROL CARDS.
 
C     CHARACTER*10 DAT,TIM
C     CHARACTER*1 KODDEL(4,1)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
 
C     DATA KODDEL(1,1),KODDEL(2,1),KODDEL(3,1),KODDEL(4,1)
C    * /'D','A','T','E'/
 
      CALL ENDLN (4)
      INDEN(4) = 0
C
C--   READ CARD.
   50 CALL CARDI (IOUT(1, 4), ICARD)
        IF (ICARD.LT.0)  GO TO 9000
        IF (ICARD.GT.0)  GO TO 60
        JIOUT(4) = 1
        GO TO 8000
 
C--     CHANGE NUMEROS TO STARS. RECORD POSITION OF LAST STAR.
   60   IB = 0
        DO 100 ICOL = 1, 80
          IF (IOUT(ICOL,4).NE.KDNUM)  GO TO 100
          IF (ICOL.EQ.1)  GO TO 90
          IF (IOUT(ICOL-1,4).EQ.KBLANK)  GO TO 90
          CALL MESSA (41, 3, ICOL)
          GO TO 100
   90     IB = ICOL
          IOUT(ICOL,4) = KDSTAR
  100     CONTINUE
        IF (IB.LE.0)  GO TO 7000
        IF (IB.GE.80)  GO TO 7500
 
C--     CHECK FOR #DATE. (REMOVED 23-APR-91.)
C       CALL CONPHR (KODDEL, 4, 1, 4, IOUT(1,4), IB+1, ICARD, ICPH, JE)
C       IF (ICPH.EQ.0)  GOTO 7000
C
C--     #DATE.
C 500   CALL GTIME (TIM, DAT)
C       JE = IB + 5
C       MAKE SPACE TO INSERT DATE.
C       DO 510 I = ICARD, JE, -1
C         IF (I+4.LE.LWIDTH(4))  IOUT(I+4,4) = IOUT(I,4)
C 510     CONTINUE
C       INSERT DATE.
C       DO 520 I = 1, 9
C         IOUT(IB+I-1,4) = ICHAR(DAT(I:I))
C 520   CONTINUE
C       JIOUT(4) = MIN0 (ICARD+4,LWIDTH(4))
C       GOTO 8000
   
 7000   L = MIN(80,LWIDTH(4))
        DO 7100 I = L, 1, -1
          IF (IOUT(I,4).NE.KBLANK)  THEN
            JIOUT(4) = I
            GOTO 8000
          ENDIF
 7100     CONTINUE
        JIOUT(4) = 1
        GOTO 8000
 
 7500   CALL MESSA (84, 1, 0)
C
 8000   CALL ENDLN (4)
C
 8500   GO TO 50
C--
 9000 RETURN
      END
      SUBROUTINE DELDEP (ITM, IDAT, ICDEP, LIDAT, ITYPC, NSTAT,             TDEL
     * NC, ICSTAT, ISTAT, MS, JI)
 
C  REVISED 21-APR-93.
C  REMOVES EXPLICIT N/A CODING FROM CHARACTERS COVERED BY A
C   DEPENDENCY DECLARATION. THIS IS DONE ONLY FOR CONVERSION TO
C   DELTA FORMAT.
C
C  ITM RECEIVES AND RETURNS THE ITEM.
C  IDAT IS WORKING SPACE OF LENGTH LIDAT.
C  ICDEP RECEIVES THE CHARACTER DEPENDENCIES.
C  LIDAT RECEIVES THE LENGTH OF ITM.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  NSTAT RECEIVES THE NUMBER OF STATES.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  ICSTAT RECEIVES WORKING SPACE OF LENGTH MS.
C  ISTAT RECEIVES WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM OF STATES.
C  JI RECEIVES THE ITEM NUMBER.
C
      COMMON /ITSXXX/ ITSS
C
      DIMENSION ITM(LIDAT),IDAT(LIDAT),ITYPC(NC),NSTAT(NC),
     * ICDEP(LIDAT),ICSTAT(MS),ISTAT(MS),ITSF(3),IVAL(2)
 
C     INITIALIZE NEW ITEM.
      DO 10 IC = 1, NC
        IDAT(IC) = 0
   10   CONTINUE
C
C     COPY TAXON NAME.
      L = ITM(NC+2)
      CALL COPIA (ITM(NC+2), IDAT(NC+2), L)
C
C     CURRENT LENGTH OF NEW ITEM.
      JITM = NC + 1 + L
C
C     DEAL WITH CHARACTER DEPENDENCIES FIRST.
      DO 600 IC = 1, NC
        IF (ICDEP(IC).EQ.0)  GO TO 600
        IF (ITM(IC).EQ.0)  GO TO 600
C
        CALL FINDST (ITM, IC, LIDAT, ITYPC, NSTAT, NC,
     *   ISTAT, MS, ITSF)
C
C       COPY CONTROLLING CHARACTER TO NEW ITEM.
        JGI = JITM + 1
        JG = ITM(IC)
        L = ITM(JG)
        CALL COPIA (ITM(JG), IDAT(JITM+1), L)
        JITM = JITM + L
        IDAT(IC) = JGI
        ITM(IC) = 0
C
        ICDPTR = ICDEP(IC)
        NS = NSTAT(IC)
        IF (NONZER(ISTAT,NS).EQ.0.AND.(ITSF(1).NE.0.OR.ITSF(3).NE.0))
     *   CALL SETIA (ISTAT, NS, 1)
        CALL COPIA (ICDEP(ICDPTR), ICSTAT, NS)
 
        DO 500 IS = 1, NS
          IF (ICSTAT(IS).EQ.0)  GO TO 500
          IF (ISTAT(IS).EQ.0)  GOTO 500
          ICNTRL = ICSTAT(IS)
          NR = ICDEP(ICNTRL)
C
C         CONTROLLING STATE PRESENT, EXAMINE DEPENDENT CHARACTERS.
          DO 250 IR = 1, NR
            IB = ICDEP(ICNTRL+2*IR-1)
            IE = ICDEP(ICNTRL+2*IR)
            DO 200 KC = IB, IE
              IF (ITM(KC).EQ.0)  GO TO 200
              JG = ITM(KC)
              JGN = JG + ITM(JG)
              JSG = JG + 1
              LSG = ITM(JSG)
              JGI = JITM + 1
              IDAT(KC) = JGI
              JITM = JITM + 1
C
  100         IF (JSG.GE.JGN)  GO TO 150
                IF(ITM(JSG+1).NE.ITSS+3)  GO TO 120
C
C               N/A CODING. CHECK FOR ASSOCIATED COMMENT BEFORE OMITTING.
                KSG = JSG + LSG
                IF (KSG.LT.JGN.AND.ITM(KSG+1).EQ.0)  GO TO 120
                IVAL(1) = JI
                IVAL(2) = KC
                CALL MESSB (101, IVAL, 2, 2, 0)
                GO TO 125
C
  120           CALL COPIA (ITM(JSG), IDAT(JITM+1), LSG)
                JITM = JITM + LSG
  125           JSG = JSG + LSG
                LSG = ITM(JSG)
                GO TO 100
C
  150         IF (JITM-JGI.GT.0)  GO TO 160
                IDAT(KC) = 0
                JITM = JITM - 1
                GO TO 170
C
  160         IDAT(JGI) = JITM - JGI + 1
C
  170         ITM(KC) = 0
C
  200         CONTINUE
C
  250       CONTINUE
C
C         TO AVOID DUPLICATION, CLEAR STATES CONTROLLING SAME CHARACTERS.
          DO 300 JS = 1, NS
            IF (ICSTAT(JS).EQ.ICNTRL)  ICSTAT(JS) = 0
  300       CONTINUE
 
  500     CONTINUE
 
  600   CONTINUE
C
C     COPY REST OF ITEM.
      DO 700 IC = 1, NC
       IF (ITM(IC).EQ.0)  GO TO 700
       JG = ITM(IC)
       L = ITM(JG)
       IF (L.LE.0)  GO TO 700
       IF (JITM+L.GT.LIDAT)  CALL MESSB (35, LIDAT, 1, -1, 0)
       IDAT(IC) = JITM + 1
       CALL COPIA (ITM(JG), IDAT(JITM+1), L)
       JITM = JITM + L
  700  CONTINUE
C
C      RETURN TO ORIGINAL ARRAY.
      CALL COPIA (IDAT, ITM, JITM)
      ITM(NC+1) = JITM - NC
C
      RETURN
      END
      SUBROUTINE DELTC (ITYPC, IMC, NSTAT, KSTAT, NEWOR, ICDES, LCDES,      TDEL
     * SCALF, IALTC, NOTES, NOTGRP, NC, IKEYCH, IKEYST, ICHSEQ, MM1S,
     * MS, ISBND, ICHHD, IFMT, ITYPMK, IDAT, LIDAT, ICSTR, LCSTR, IPOLD,
     * IOMSTC, ISCALC, ICNOTE, JPACH, JRECH, NUMST0, LUNTYP, ITRAN,
     * IOMNSC, IHTMBKT)
 
C* REVISED 20-JUL-98.
C* OUTPUTS CHARACTER DESCRIPTIONS IN DELTA FORMAT.
C
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  IMC RECEIVES THE CHARACTER MASK.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  KSTAT RECEIVES THE NUMBERS OF KEY STATES.
C  NEWOR RECEIVES THE NEW CHARACTER ORDER.
C  ICDES RECEIVES THE STARTING POSITIONS OF THE CHARACTER DESCRIPTIONS.
C  LCDES RECEIVES THE LENGTHS OF THE CHARACTER DESCRIPTIONS.
C  SCALF RECEIVES SCALING FACTORS.
C  IALTC RECEIVES WHETHER TO USE THE ALTERNATE COMMA CHARACTER.
C  NOTES RECEIVES RECORD POINTERS TO INTKEY CHARACTER HELP NOTES.
C  NOTGRP RECEIVES THE GROUP TO WHICH A NOTE BELONGS.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  IKEYCH RECEIVES WHETHER A KEY CHARACTER LIST IS BEING USED.
C  IKEYST RECEIVES WHETHER TO OUTPUT KEY STATE DESCRIPTIONS.
C  ICHSEQ RECEIVES WHETHER CHARACTER SEQUENCE NUMBERS ARE REQUIRED
C    IN DELTA FORMAT OUTPUT.
C  MM1S RECEIVES WORDING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C  ISBND RECEIVES KEY STATE BOUNDARIES.
C  ICHHD RECEIVES THE CHARACTER HEADINGS (SEE SUBR. RDSENL).
C  IFMT RECEIVES FORMATTTING MARKS.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  IDAT RECEIVES WORKING SPACE OF LENGTH LIDAT.
C  LIDAT RECEIVES THE DATA BUFFER SIZE.
C  ICSTR. IF ISTYPE.EQ.1, ICSTR RECEIVES THE CHARACTER DESCRIPTIONS.
C    IF ISTYPE.NE.1, ICSTR IS WORKING SPACE. SEE SUBR. FETCHC.
C  LCSTR RECEIVES THE LENGTH OF ICSTR.
C  IPOLD RECEIVES A FLAG INDICATING WHETHER THE OLD CHARACTER NUMBERS
C    ARE TO BE PRINTED.
C  IOMSTC RECEIVES WHETHER TO OMIT STATE CODES.
C  ISCALC RECEIVES WHETHER REAL CHARACTERS HAVE BEEN SCALED.
C  ICNOTE RECEIVES WHETHER THERE ARE CHARACTER HELP NOTES.
C  NOTGRP RECEIVES THE GROUP TO WHICH THE CHARACTER NOTE BELONGS.
C  JPACH RECEIVES A FLAG INDICATING WHETHER MASKED-OUT CHARACTERS
C    ARE TO BE PRINTED.
C  JRECH RECEIVES A FLAG INDICATING HOW CHARACTERS ARE TO BE
C    RENUMBERED. 0 - NO RENUMBERING. 1 - MASKED-IN CHARACTERS NUMBERED
C    CONSECUTIVELY.
C  NUMST0 RECEIVES WHETHER TO NUMBER THE STATES FROM ZERO.
C  LUNTYP RECEIVES THE TYPE OF THE OUTPUT LOGICAL UNIT.
C  ITRAN RECEIVES THE TRANSLATION FLAG.
C  IOMNSC RECEIVES WHETHER TO OMIT INNER COMMENTS.
C  IHTMBKT RECEIVES WHETHER TO REPLACE ANGLE BRACKETS WITH THEIR HTML EQUIVALENT.
 
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /SCR6XX/ LRECS6,IRECS6
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
      COMMON /VLWXXX/ NVWD,MAXVWD,LVWD(18),IBPUNC,IEPUNC,
     * KVSTOP,KVCOM1,KVCOM2,KVSEMI,KVDEC
 
      DIMENSION ITYPC(NC),IMC(NC),NSTAT(NC),KSTAT(NC),NEWOR(NC),
     * ICDES(NC),LCDES(NC),SCALF(NC),IALTC(NC),NOTES(NC),NOTGRP(NC),
     * MM1S(MS),ISBND(LIDAT),ICHHD(LIDAT),IDAT(LIDAT),ICSTR(LCSTR)
 
C     TYPESETTING TABS.
      IF (ITPSET.GT.0.AND.LUNTYP.EQ.3)
     *  CALL JSTTPS (3, ITYPMK, LIDAT, NTYPMK, LUNTYP)
 
      JCM = 0
      IE = 0
      JHD = 0
C
C-    FIND CHARACTER NUMBERS AND WHETHER HEADING IS REQUIRED.
      DO 100 JC = 1, NC
        IC = JC
        IF (JRECH.NE.0)  IC = NEWOR(JC)
        IF (ICHHD(IC).GT.0 .AND. LUNTYP.EQ.3. .AND. JRECH.NE.2)
     *   JHD = ICHHD(IC)
        IF (IMC(IC).EQ.0.AND.JPACH.EQ.0)  GO TO 100
        JCM = JCM + 1
C       SET COMMA CHARACTER TO BE USED.
        IF (IALTC(IC).EQ.0)  THEN
          KCOM = KVCOM1
        ELSE
          KCOM = KVCOM2
        ENDIF
        J = JC
        IF (JRECH.NE.0)  J = JCM
        JS = 1
C       HENNIG FORMAT - CHARACTERS AND STATES RENUMBERED FROM ZERO.
        IF (ITRAN.EQ.2)  THEN
          J = J - 1
          JS = 0
        ENDIF
C       IF 'NUMBER STATES FROM ZERO' DIRECTIVE USED.
        IF (NUMST0.NE.0)  JS = 0
        GO TO 90
 
C-      OUTPUT CHARACTER DESCRIPTION.
   90   CALL DELCHA (ITYPC, NSTAT, KSTAT, ICDES, LCDES, SCALF, NC,
     *  IKEYCH, IKEYST, KCOM, ICHSEQ, MM1S, MS, ISBND, ICHHD, ITYPMK,
     *  LIDAT, ICSTR, LCSTR, IC, J, JS, IPOLD, IOMSTC, ISCALC,
     *  JHD, LUNTYP, IOMNSC, IHTMBKT)
        IF (ICNOTE.NE.0 .AND. NOTES(IC).NE.0)  THEN
C         CHECK IF ALREADY OUTPUT.
          IF (NOTES(NOTGRP(IC)).GT.0)  THEN
            IREC = NOTES(IC)
C           MARK NOTE AS HAVING BEEN OUTPUT
            NOTES(NOTGRP(IC)) = -NOTES(NOTGRP(IC))
            CALL RDDAI (L, 1, LUNS6, LRECS6, IREC)
            IREC = IREC + 1
            CALL RDDAI (IDAT, L, LUNS6, LRECS6, IREC)
            CALL PRNOTE (IDAT, L, IFMT, ITYPMK, LIDAT, LUNTYP)
C           CALL WSENT (IDAT, L, 0, 0, 0, 0, 1, ITYPMK, LIDAT, LUNTYP)
          ENDIF
        ENDIF
  100   CONTINUE
 
C     RESTORE NOTES ARRAY.
      IF (ICNOTE.NE.0)  THEN
       DO IC = 1, NC
         NOTES(IC) = ABS(NOTES(IC))
       ENDDO
      ENDIF
C
      RETURN
      END
      SUBROUTINE DELTI (ITM, IDAM, IDAT, LIDAT, ITYPC, IMC,                 TDEL
     * NDEC, IMPFLG, ITMADD, ISRTS, IWRKC, LSTDEP, NC, ITYPMK, IMI,
     * JI, JIM,
     * IVARIT, MASTIN, ITRAN, IPITEM, JPACH, JRECH, ITIMPL, ICMPRS,
     * ITMSEQ, INSRVA, IOMSTC, IOUNC, LUNTYP, NSTAT, IDEPC, ICDEP,
     * MM1S, MM2S, MS)
 
C* REVISED 22-JUN-99.
C* OUTPUTS ITEM IN DELTA FORMAT.
 
C  ITM RECEIVES THE ITEM.
C  IDAM RECEIVES THE MASTER ITEM.
C  IDAT RECEIVES WORKING SPACE OF LENGTH LIDAT.
C  LIDAT RECEIVES THE LENGTH OF ITM. ITS VALUE MUST
C    BE IDENTICAL WITH THE VALUE IN DIM XXX.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  NDEC RECEIVES THE NUMBER OF DECIMAL PLACES FOR OUTPUT.
C  IMPFLG RECEIVES WHERE IMPLICIT VALUES HAVE BEEN INSERTED IN A
C    MASTER ITEM.
C  ITMADD RECEIVES WHERE DATA HAS BEEN ADDED TO A VARIANT ITEM.
C  ISRTS RECEIVES WHETHER TO SORT CHARACTER STATES.
C  IWRKC RECEIVES WORKING SPACE OF LENGTH NC.
C  LSTDEP RECEIVES WORKING SPACE OF LENGTH NC.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  LIDAT RECEIVES THE LENGTH OF ITYPMK.
C  IMI RECEIVES THE ITEM MASK.
C  JI RECEIVES THE ITEM NUMBER.
C  JIM RECEIVES THE MASKED-IN-ITEM NUMBER, OR 0. IF NON-ZERO,
C    SEQUENCE NUMBERS ARE GENERATED WITH JIM AS THE INTEGER PART.
C  IVARIT RECEIVES 1 IF THE ITEM IS A VARIANT, ELSE 0.
C  MASTIN RECEIVES NON-ZERO IF THE MASTER ITEM IS MASKED IN, ELSE 0.
C  ITRAN RECEIVES THE TRANSLATION FLAG.
C  IPITEM RECEIVES 1 IF ITEM IS TO BE FORMATED FOR PRINT FILE, 0 IF
C    FOR OUTPUT FILE.
C  JPACH RECEIVES A FLAG INDICATING WHETHER MASKED-OUT CHARACTERS
C    ARE TO BE PRINTED.
C  JRECH RECEIVES A FLAG INDICATING WHETHER CHARACTERS ARE TO BE
C    RENUMBERED.
C  ITIMPL RECEIVES WHETHER IMPLICIT VALUES ARE TO BE INSERTED ON OUTPUT.
C  ICMPRS RECEIVES 1 IF DATA IS TO BE COMPRESSED ON OUTPUT, 0 OTHERWISE.
C  ITMSEQ RECEIVES WHETHER ITEM SEQUENCE NUMBERS ARE REQUIRED
C    IN DELTA FORMAT OUTPUT.
C  INSRVA RECEIVES WHETHER TO INSERT REDUNDANT VARIANT ATTRIBUTES.
C  IOMSTC RECEIVES WHETHER TO OMIT STATE CODES.
C  IOUNC RECEIVES WHETHER TO OUTPUT UNCODED VALUES.
C  LUNTYP RECEIVES THE TYPE OF THE OUTPUT LOGICAL UNIT.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  IDEPC RECEIVES 1 IF THERE ARE DEPENDENT CHARACTERS,
C  ICDEP RECEIVES THE CHARACTER DEPENDENCIES.
C  MM1S RECEIVES WORKING SPACE OF LENGTH MS.
C  MM2S RECEIVES WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
 
      DIMENSION ITM(LIDAT),IDAM(LIDAT),IDAT(LIDAT),ITYPC(NC),IMC(NC),
     * NSTAT(NC),NDEC(NC),IMPFLG(NC),ITMADD(NC),ISRTS(NC),IWRKC(NC),
     * LSTDEP(NC),ITYPMK(LIDAT),IMI(JI),ICDEP(LIDAT),MM1S(MS),MM2S(MS)
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
C
      IF (IMI(JI).EQ.0)  GO TO 1000
 
C     Output all uncoded values?
      IF (IOUNC.NE.0)  THEN
        ITIMPL = 1
        INSRVA = 1
      ENDIF
 
      IF (IDEPC.NE.0) THEN
        IF (IOUNC.EQ.0) THEN
C        DELETE REDUNDANT DEPENDENCY CODING.
         CALL DELDEP (ITM, IDAT, ICDEP, LIDAT, ITYPC, NSTAT, NC, MM1S,
     *     MM2S, MS, JI)
        ELSE
C         INSERT INAPPLICABLE CODING.
C         Flag all characters to be processed in the first instance.
          CALL SETIA (LSTDEP, NC, 1)
    5     CALL INSDEP (ITM, ICDEP, LIDAT, ITYPC, NSTAT, IWRKC, LSTDEP,
     *      NC, MM1S, MM2S, MS)
C         LSTDEP flags characters that have been made inapplicable and
C         hence need to looked at again because they are controlling characters..
          IF (NONZER(LSTDEP, NC).NE.0)  GOTO 5
        ENDIF
      ENDIF
C
C--   SET INDENTATION ETC.
      IF (IPITEM.NE.0)  GO TO 20
      CALL BLKLIN (1, 0, LUNTYP)
      PSEQ = 0
      INDSEQ = 0
      IF (ITMSEQ.GT.0)  THEN
        PSEQ = JIM
        INDSEQ = 8
      ENDIF
      INDEN(LUNTYP) = INDSEQ
      GO TO 50
   20 PSEQ = 0
      INDEN(LUNTYP) = 0
      IF (ITRAN.EQ.4)  GO TO 24
      I = 1
      J = 10
      GO TO 30
   24 I = 2
      J = 9
   30 IF (ITPSET.GT.0)  GO TO 34
      CALL BLKLIN (I, 2, LUNTYP)
      GO TO 50
   34 CALL BLKLIN (1, 0, LUNTYP)
C     [g][ ][3g]
      CALL JSTTPS (J, ITYPMK, LIDAT, NTYPMK, LUNTYP)
C
C--   TAXON NAME.
   50 CALL JSTS (KDNUM, -1, LUNTYP)
      IF (IVARIT.NE.0)  CALL JSTS (KDPLUS, -1, LUNTYP)
      CALL ENDWD (LUNTYP)
      CALL WSENT (ITM(NC+2), LIDAT, 1, 0, 0, 1, -1, ITYPMK, LIDAT,
     * LUNTYP)
      CALL JSTS (KDSOL, 1, LUNTYP)
C
C--   ATTRIBUTES.
      IF (ITPSET.GT.0)
     *  CALL JSTTPS (11, ITYPMK, LIDAT, NTYPMK, LUNTYP)
      JCM = 0
      JC = 0
      IB = 0
   60 JC = JC + 1
        IF (JC.LE.NC)  GOTO 65
        IF (IB.EQ.0)  GOTO 100
        GOTO 90
   65   IC = JC
        IF (IMC(IC).EQ.0.AND.JPACH.EQ.0)  GO TO 60
        JCM = JCM + 1
        IF (IVARIT.NE.0)  THEN
          IF (MASTIN.EQ.0)  GOTO 66
          IF (INSRVA.EQ.0)  THEN
            IF (ITMADD(IC).NE.0)  GOTO 95
          ELSE IF (INSRVA.GT.0)  THEN
            GOTO 66
          ELSE IF (INSRVA.LT.0)  THEN
            IF (ITMADD(IC).NE.0)  GOTO 95
            CALL CMPITM (IDAM, ITM, LIDAT, IC, ISAME)
            IF (ISAME.NE.0)  GOTO 95
          ENDIF
        ENDIF
   66   J = JC
        IF (JRECH.NE.0)  J = JCM
        IF (IB.NE.0)  GOTO 70
        IB = IC
        IC1 = J
        IC2 = J
        IF (ICMPRS.EQ.0)  GOTO 90
C       IF (ICMPRS.EQ.0.OR.
C    *     (IPITEM.EQ.0.AND.IMPFLG(IC).NE.0.AND.ITIMPL.EQ.0))  GOTO 90
        GOTO 60
   70   IE = IC
        IF (ITYPC(IE).EQ.ITYPC(IB))  GOTO 72
        IF (ITYPC(IE).LE.2.AND.ITYPC(IB).LE.2)  GOTO 72
        GOTO 80
   72   CALL CMPATT (ITM, LIDAT, IB, IE, IMPFLG(IB), IMPFLG(IE),
     *   ISAME)
        IF (ISAME.EQ.0)  GOTO 80
          IC2 = J
          GOTO 60
   80   JC = JC - 1
        JCM = JCM - 1
   90   CALL DELA (ITM, IDAT, LIDAT, ITYPC, NSTAT, NDEC, IMPFLG, ITMADD,
     *   ISRTS, NC, ITYPMK, IB, IC1, IC2, ITIMPL, IOMSTC, IPITEM, JIM,
     *   IVARIT, IOUNC, LUNTYP)
   95   IB = 0
        GOTO 60
C--
  100 CALL ENDLN (LUNTYP)
      PSEQ = 0.
      INDEN(LUNTYP) = 0
 1000 RETURN
      END
      SUBROUTINE INSDEP (ITM, ICDEP, LIDAT, ITYPC, NSTAT, ICHDEP,           TDEL
     * LSTDEP, NC, ICSTAT, ISTAT, MS)
 
C  REVISED 24-JUN-99.
C  INSERTS THE "NOT APPLICABLE" ATTRIBUTE IN UNCODED CHARACTERS, WHICH ARE
C   SUBJECT TO A DEPENDENCY. THIS IS DONE ONLY FOR CONVERSION TO DELTA FORMAT.

C  ITM RECEIVES AND RETURNS THE ITEM.
C  ICDEP RECEIVES THE CHARACTER DEPENDENCIES.
C  LIDAT RECEIVES THE LENGTH OF ITM.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  NSTAT RECEIVES THE NUMBER OF STATES.
C  ICHDEP RECEIVES WORKING SPACE OF LENGTH NC.
C  LSTDEP RECEIVES AND RETURNS THE LIST OF CHARACTERS TO BE PROCESSED.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  ICSTAT RECEIVES WORKING SPACE OF LENGTH MS.
C  ISTAT RECEIVES WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM OF STATES.
 
      COMMON /ITSXXX/ ITSS
 
      DIMENSION ITM(LIDAT),ITYPC(NC),NSTAT(NC),ICHDEP(NC),LSTDEP(NC),
     * ICDEP(LIDAT),ICSTAT(MS),ISTAT(MS),ITSF(3),IVAL(2)
 
C     CURRENT LENGTH OF ITEM.
      JITEM = NC + ITM(NC+1)
 
C     LOOK AT CHARACTER DEPENDENCIES.
      DO 600 IC = 1, NC
        IF (LSTDEP(IC).EQ.0)  GOTO 600
C       Flag as processed.
        LSTDEP(IC) = 0
        IF (ICDEP(IC).EQ.0)  GO TO 600
        IF (ITM(IC).EQ.0)  GO TO 600
C
        CALL FINDST (ITM, IC, LIDAT, ITYPC, NSTAT, NC,
     *   ISTAT, MS, ITSF)
 
        ICDPTR = ICDEP(IC)
        NS = NSTAT(IC)
        IF (NONZER(ISTAT,NS).EQ.0.AND.(ITSF(1).NE.0.OR.ITSF(3).NE.0))
     *   CALL SETIA (ISTAT, NS, 1)
        CALL COPIA (ICDEP(ICDPTR), ICSTAT, NS)
C       If controlling is inapplicable, dependent characters must be inapplicable.
        IF (ITSF(3).NE.0)  GOTO 410
 
C       Check for presence of any state which allows dependent character
C       to be coded.
        DO 400 IS = 1, NS
          IF (ICSTAT(IS).NE.0)  GO TO 400
          IF (ISTAT(IS).NE.0)  GOTO 600
  400   CONTINUE
 
  410   DO 500 IS = 1, NS
          IF (ICSTAT(IS).EQ.0)  GO TO 500
          IF (ISTAT(IS).EQ.0)  GOTO 500
          ICNTRL = ICSTAT(IS)
          NR = ICDEP(ICNTRL)
 
C         CONTROLLING STATE PRESENT, EXAMINE DEPENDENT CHARACTERS.
          DO 250 IR = 1, NR
            IB = ICDEP(ICNTRL+2*IR-1)
            IE = ICDEP(ICNTRL+2*IR)
            DO 200 KC = IB, IE
              ICMT = 0
              IF (ITM(KC).EQ.0)  GOTO 100
C             Check if just a comment coded. If so, need to insert -<cmt>
              JG = ITM(KC)
              JGN = JG + ITM(JG)
              JSG = JG + 1
              IF (ITM(JSG+1).NE.0)  GOTO 200
              IF (JSG+ITM(JSG).LT.JGN) GOTO 200
              ICMT = 1
 
C             If controlling character is inapplicable, dependents MUST
c             also  be inapplicable
  100         IF (ITSF(3).NE.0)  GOTO 120
 
C             Check if all coded states control this character.
              ICHDEP(KC) = 0
              KNT = 0
              DO 110 JS = 1, NS
                IF (ISTAT(JS).NE.0) THEN
                  KNT = KNT + 1
                  CALL GETDEP (ICDEP, LIDAT, IC, JS, ICHDEP, NC, KNT)
                  IF (ICHDEP(KC).NE.KNT)  GOTO 200
                ENDIF
  110         CONTINUE
 
C             Uncoded dependent character, insert inapplicable value.
  120         IF (JITEM+3.GT.LIDAT)  GOTO 700
              ITM(KC) = JITEM + 1
              JGI = JITEM + 1
              ITM(JITEM+1) = 3
              ITM(JITEM+2) = 2
              ITM(JITEM+3) = ITSS + 3
              JITEM = JITEM + 3
              IF (ICMT.NE.0) THEN
C               Add comment.
                LCMT = ITM(JSG)
                IF (JITEM+LCMT.GT.LIDAT)  GOTO 700
                CALL COPIA (ITM(JSG), ITM(JITEM+1), LCMT)
                JITEM = JITEM + LCMT
C               Update length of character data by adding length of comment.
                ITM(JGI) = ITM(JGI) + LCMT
              ENDIF
C             KC is earlier in the character list and has already been processed.
C             Flag for reprocessing.
              IF (KC.LT.IC.AND.ICDEP(KC).NE.0)  LSTDEP(KC) = 1
  200       CONTINUE
  250     CONTINUE
  500   CONTINUE
  600 CONTINUE
      GOTO 1000
 
C     FATAL ERROR.
  700 CALL MESSB (35, LIDAT, 1, -1, 0)
 
 1000 ITM(NC+1) = JITEM - NC
      RETURN
      END
      SUBROUTINE NXTWRD (ITEXT, LTEXT, IB, IE, ITYPE, ISIZE)                TDEL
 
C  REVISED 11-AUG-98.
C  RETURNS NEXT WORD IN THE TEXT AND ITS TYPE.
 
C  TEXT RECEIVES THE TEXT.
C  LTEXT RECEIVES THE LENGTH OF TEXT.
C  IB RECEIVES THE CURRENT POSITION IN TEXT AND RETURNS THE START
C   POSITION OF THE WORD.
C  IE RETURNS THE FIRST POSITION AFTER THE WORD.
C  ITYPE RETURNS THE TYPE OF WORD.
C  ISIZE RETURNS THE MAGNITUDE ASSOCIATED WITH ANY RECOGNIZED TYPSET
C   COMMAND.
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /NUMXXX/ KNUM(10),KDEC,KMINUS
 
      DIMENSION ITEXT(LTEXT)
      CHARACTER*4 TEMP,RTFWD(4)
      PARAMETER (MAXRTF=4, NRTF=4)
 
      DATA (RTFWD(I),I=1,NRTF)
     */'par ','line','li  ','fi  '/
 
       ITYPE = 0
 
C     FIND NEXT NON-BLANK.
    5 IF (ITEXT(IB).NE.KBLANK)  GOTO 10
        IB = IB + 1
        IF (IB.GT.LTEXT)  GOTO 100
        GOTO 5
 
   10 IE = IB
      ISIZE = 0
 
      IF (ITEXT(IE).EQ.KDBSLSH)  THEN
        NTEMP = 0
   20   IE = IE + 1
        IF (ITEXT(IE).EQ.KBLANK.OR.ISNUM(ITEXT(IE)).NE.0.OR.
     *   ISALPHA(ITEXT(IE)).EQ.0)  GOTO 30
        NTEMP = NTEMP + 1
        IF (NTEMP.LE.MAXRTF) TEMP(NTEMP:NTEMP) = CHAR(ITEXT(IE))
        GOTO 20
 
C       End of RTF. Check for match
   30   MATCH = 0
C        DO II = 1, NRTF
C       Note: we are only recognizing the \par command. Hence, the range 1 to 1
        DO II = 1, 1
          DO JJ = 1, NTEMP
            IF (TEMP(JJ:JJ).NE.RTFWD(II)(JJ:JJ))  GOTO 35
          ENDDO
          MATCH = II
          IF (NTEMP.LT.MAXRTF.AND.
     *      RTFWD(II)(NTEMP+1:NTEMP+1).NE.CHAR(KBLANK))  MATCH = 0
          IF (MATCH.NE.0)  GOTO 40
   35     CONTINUE
        ENDDO
   40   IF (MATCH.EQ.0)  THEN
          ITYPE = 6
        ELSE
          ITYPE = MATCH + 1
C         Line or paragraph indentation?
          IF (ITYPE.EQ.4.OR.ITYPE.EQ.5)  THEN
C           Get numeric value.
            SIZE = 0.
            SIGN = 1.
   41       J = ITEXT(IE)
            IF (J.EQ.KMINUS) THEN
              SIGN = -1
            ELSEIF (ISNUM(J).NE.0) THEN
              SIZE = SIZE*10. + J - ICHAR('0')
            ELSE
              GOTO 45
            ENDIF
            IE = IE + 1
            IF (IE.GT.LTEXT)  GOTO 45
            GOTO 41
   45       SIZE = (SIZE*25.4)/1440.
            ISIZE = MAX(INT ((SIZE+0.5) * SIGN), 0)
            GOTO 100
          ENDIF
        ENDIF
C       Find end of the command.
        DO WHILE (ISNUM(ITEXT(IE)).NE.0)
          IE = IE + 1
          IF (IE.GT.LTEXT) GOTO 100
        ENDDO
        IF (ITEXT(IE).EQ.ICHAR('{'))  IE = IE + 1
        IF (IE.LE.LTEXT.AND.ITEXT(IE).EQ.ICHAR('}'))  IE = IE + 1
        GOTO 100

      ELSE
        ITYPE = 1
   50   IE = IE + 1
        IF (IE.GT.LTEXT)  GOTO 100
        IF (ITEXT(IE).EQ.KBLANK.OR.ITEXT(IE).EQ.KDBSLSH)  GOTO 100
        GOTO 50
      ENDIF

  100 RETURN
      END
C      SUBROUTINE NXTWRD (ITEXT, LTEXT, IB, IE, ITYPE, ISIZE)                TDEL
C 
CC  REVISED 22-OCT-91.
CC  RETURNS NEXT WORD IN THE TEXT AND ITS TYPE.
C 
CC  TEXT RECEIVES THE TEXT.
CC  LTEXT RECEIVES THE LENGTH OF TEXT.
CC  IB RECEIVES THE CURRENT POSITION IN TEXT AND RETURNS THE START
CC   POSITION OF THE WORD.
CC  IE RETURNS THE FIRST POSITION AFTER THE WORD.
CC  ITYPE RETURNS THE TYPE OF WORD.
CC  ISIZE RETURNS THE MAGNITUDE ASSOCIATED WITH ANY RECOGNIZED TYPSET
CC   COMMAND.
C 
C      COMMON /BLKXXX/ KBLANK
C      COMMON /IGNXXX/ ICMD,IGNTYP
C      COMMON /NUMXXX/ KNUM(10),KDEC,KMINUS
C 
C      DIMENSION ITEXT(LTEXT)
C      LOGICAL DEC
C 
C      DIMENSION MAP(8)
C      PARAMETER (APOS = 39)
C 
C      SAVE LTYPE
C 
C      DATA MAP /0,0,6,1,4,2,3,9/
C 
C      ITYPE = 0
C 
CC     FIND NEXT NON-BLANK.
C    5 IF (ITEXT(IB).NE.KBLANK)  GOTO 10
C        IB = IB + 1
C        IF (IB.GT.LTEXT)  GOTO 100
C        GOTO 5
C 
C   10 IE = IB
C      ISTART = -1
C      IEND = -1
C      IFIRST = 1
C      ISIZE = 0
C 
C      DO WHILE (IE.LE.LTEXT)
C 
CC       IGNOR = 0
C        IF (IGNOR(ITEXT(IE)).EQ.0)  THEN
C          IF (ISTART.GT.0)  GOTO 20
C            ITYPE = 1
C 
CC       IGNOR = 1
C        ELSE
C          IF (ISTART.LT.0.AND.IE.GT.IB) THEN
CC           ORDINARY TEXT TO BE PROCESSED FIRST.
C            ITYPE = 1
C            GOTO 100
C  
C          ELSE
C            IF (ICMD.GT.0)  THEN
CC             LOOKING FOR A TYPSET COMMAND
C              IF (IFIRST.EQ.1)  THEN
C                ISTART = IE
C                IEND = IE
C                ITYPE = 6
C                IFIRST = 0
C              ELSE
C                IEND =IE
C              ENDIF
C 
C            ELSE
CC             TYPSET COMMAND OR TERMINATOR FOUND
C              IF (IGNTYP.EQ.2)  THEN
CC               TERMINATOR FOUND.
C                IF (ITYPE.EQ.0)  THEN
C                  ITYPE = 6
C                  IF ((LTYPE.GE.2.AND.LTYPE.LE.5).OR.LTYPE.EQ.9)
C     *              ITYPE = 7
C                ENDIF
C                IE = IE + 1
C                GOTO 20
C              ENDIF 
C              IF (ISTART.GT.0.AND.IE.EQ.IEND+1)  ITYPE = MAP(IGNTYP)
C            ENDIF
C          ENDIF
C   
C        ENDIF
C        IE = IE + 1
C      END DO
C 
C   20 LTYPE = ITYPE
C      IF (((ITYPE.GE.2.AND.ITYPE.LE.5).OR.ITYPE.EQ.9).AND.
C     *  IEND.GT.ISTART)  THEN
CC       LOOK FOR AN APOSTROPHE.
C        IAPOS = 0
C        DO I = ISTART, IEND
C          IF (ITEXT(I).EQ.APOS)  THEN
C            IAPOS = 1
C            GOTO 30
C          ENDIF
C        END DO
C   30   IF (ITYPE.EQ.3)  THEN
CC         [p]
C          IF (IAPOS.GT.0)  ITYPE = 8
C        ELSEIF (ITYPE.EQ.4)  THEN
CC         [i]
C          ITYPE = ITYPE + IAPOS
C        ELSEIF (ITYPE.EQ.9)  THEN
CC         [z]
C          ITYPE = ITYPE + IAPOS
C        ENDIF
CC       LOOK FOR FIRST NUMERIC.
C        DO I = ISTART, IEND
C          J = ITEXT(I)
C          IF ((J.GE.KNUM(1).AND.J.LE.KNUM(10)) .OR.
C     *         J.EQ.KMINUS .OR. J.EQ.KDEC)  GOTO 40
C        END DO
C        GOTO 100
CC       NUMERIC.
C   40   SIGN = 1.
C        SIZE = 0.0
C        DEC = .FALSE.
C   45   J = ITEXT(I)
C          IF (J.EQ.KMINUS)  THEN
C            SIGN = -1.
C          ELSE IF (J.EQ.KDEC)  THEN
C            DEC = .TRUE.
C            FACTOR = 0.1
C          ELSE IF (J.GE.KNUM(1).AND.J.LE.KNUM(10))  THEN
C            IF (DEC)  THEN
C              SIZE = SIZE + (J - ICHAR('0')) * FACTOR
C              FACTOR = FACTOR * 0.1
C            ELSE
C              SIZE = SIZE * 10 + J - ICHAR('0')
C            ENDIF
C          ELSE
C            GOTO 50
C          ENDIF
C          I = I + 1
C          IF (I.LE.IEND)  GOTO 45
C   50   ISIZE = MAX(INT ((SIZE+0.5) * SIGN), 0)
C        GOTO 100
C      ENDIF
C
C  100 RETURN
C      END
      SUBROUTINE PRNOTE (NOTE, LNOTE, IFMT, ITYPMK, LIDAT, LUNTYP)          TDEL
 
C* REVISED 18-MAR-93.
C* PRINTS CHARACTER NOTES.
 
C  NOTE RECEIVES THE NOTE (STORED AS A SENTENCE - SEE SUBR. SENTNC)
C  LNOTE RECEIVES THE LENGTH OF NOTE.
C  IFMT RECEIVES FORMATTTING MARKS.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  LIDAT RECEIVES THE LENGTH OF ITYPMK.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT FOR OUTPUT.
 
      DIMENSION NOTE(LNOTE),IFMT(LIDAT),ITYPMK(LIDAT)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /FMTMKX/ IFMTMK,NFMTMK,FMTWRD(3),LFMTWD(3)
        CHARACTER*20 FMTWRD
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
 
C     TYPSET OUTPUT.
      IF (ITPSET.GT.0)  THEN
        CALL JSTTPS (8, ITYPMK, LIDAT, NTYPMK, LUNTYP)
        CALL ENDLN (LUNTYP)
        CALL WSENT (NOTE, LNOTE, 0, 0, 0, 0, 1, ITYPMK, LIDAT, LUNTYP)
 
      ELSE
C       INITIALIZE LINE INDENTATION, PARAGRAPH INDENTATION, INTERLINE
C       SPACING, INTERPARAGRAPH SPACING.
        INDEN(LUNTYP) = 0
        INDENP = 0
        LINSP = 0
        IPARSP = 0
        NEWLINE = 0
        JSIZE = 0
        JINDEN = 0
 
C       11-AUG-98.
C       With RTF replacing TYPSET for formatting, the FORMATTING MARKS
C       directive is no longer being used.
 
CC       FIRST PROCESS "FORMATTING MARKS"
C        IF (IFMTMK.NE.0.AND.IFMT(1).NE.0)  THEN
C          JSG = IFMT(1) + 1
C          L = IFMT(JSG)
C          IF (L.GT.0)  THEN
C            IB = JSG + 2
C            IE = JSG + L - 1
C            DO WHILE (IB.LE.IE)
C              CALL NXTWRD (IFMT, IE, IB, JE, ITYPE, ISIZE)
CC             NEW LINE.
C              IF (ITYPE.EQ.2)  THEN
C                NEWLINE = 1
C                JSIZE = MAX(JSIZE, ISIZE)
C                JINDEN = INDEN(LUNTYP)
CC             NEW PARAGRAPH.
C              ELSE IF (ITYPE.EQ.3.OR.ITYPE.EQ.8)  THEN
C                NEWLINE = 1
C                JSIZE = MAX(JSIZE, ISIZE+IPARSP)
C                IF (ITYPE.EQ.3)  THEN
CC                 PARAGRAPH INDENTATION.
C                  JINDEN = INDENP
C                ELSE
CC                 LINE INDENTATION.
C                  JINDEN = INDEN(LUNTYP)
C                ENDIF
CC             RUN-ON INDENTATION.
C              ELSE IF (ITYPE.EQ.4)  THEN
C                INDEN(LUNTYP) = ISIZE
CC             PARAGRAPH INDENTATION.
C              ELSE IF (ITYPE.EQ.5)  THEN
C                INDENP = ISIZE
CC             INTERPARAGRAPH SPACING
C              ELSE IF (ITYPE.EQ.10)  THEN
C                IPARSP = MAX(0, ISIZE-1)
C              ENDIF
C              IB = JE
C            END DO
C          ENDIF
C        ENDIF
 
C       NOW PROCESS "CHARACTER NOTES".
        JSG = 2
    5   IF (JSG.GT.NOTE(1))  GO TO 200
          IF (NOTE(JSG+1).EQ.0)  GO TO 150
          IF (JSG.GT.2)  CALL ENDWD (LUNTYP)
          IB = JSG + 2
          L = NOTE(JSG)
          IF (L.GT.0)  THEN
            IE = JSG + L - 1
            DO WHILE (IB.LE.IE)
              CALL NXTWRD (NOTE, IE, IB, JE, ITYPE, ISIZE)
              IENDW = 0
              IF (NOTE(JE).NE.KBLANK)  IENDW = -1
              GOTO (150,10,20,30,40,50,60,100,30,70,80), ITYPE+1
C            ITYPE = 0   1  2  3  4  5  6  7   8, 9,10
      
C             ORDINARY WORD.
   10         IF (NEWLINE.GT.0)  THEN
                CALL BLKLIN (JSIZE, 0, LUNTYP)
                CALL INDENT(JINDEN, LUNTYP)
                IENDWD(LUNTYP) = 0
                NEWLINE = 0
                JSIZE = 0
                JINDEN = 0
              ENDIF
              CALL JSTOUT (NOTE(IB), JE-IB, IENDW, LUNTYP, 0)
              GOTO 100
      
C             NEW LINE.
   20         NEWLINE = 1
              JSIZE = MAX(JSIZE, ISIZE)
              JINDEN = INDEN(LUNTYP)
              GOTO 100
      
C             NEW PARAGRAPH.
   30         NEWLINE = 1
              JSIZE = MAX(JSIZE, ISIZE+IPARSP)
              IF (ITYPE.EQ.3)  THEN
                JINDEN = INDENP
              ELSE
                JINDEN = INDEN(LUNTYP)
              ENDIF
              GOTO 100
      
C             SET RUN-ON INDENTATION.
   40         INDEN(LUNTYP) = ISIZE
              GOTO 100
      
C             SET PARAGRAPH INDENTATION.
   50         INDENP = ISIZE
              GOTO 100
      
C             OTHER TYPESETTING COMMAND.
   60         IF (ITPSET.GE.0)  THEN
                CALL JSTOUT (NOTE(IB), JE-IB, IENDW, LUNTYP, 0)
              ELSE IF (IENDW.EQ.0)  THEN
                CALL ENDWD (LUNTYP)
              ENDIF
              GOTO 100

C             INTERLINE SPACING. (NOT IMPLEMENTED)
   70         GOTO 100
 
C             INTERPARAGRAPH SPACING.
   80         IPARSP = ISIZE
              GOTO 100
      
  100         IB = JE
            END DO
          ENDIF
        
  150     JSG = JSG + NOTE(JSG)
          GO TO 5
      ENDIF
 
  200 CALL ENDLN (LUNTYP)
      RETURN
      END
      SUBROUTINE SORTI (IA, N)                                              TDEL
 
C     SORTS AN INTEGER ARRAY INTO ASCENDING ORDER.
 
      DIMENSION IA(N)
 
      IF (N.EQ.1) RETURN
 
      DO 10 I = 2, N
        DO 5 J = 1, I-1
          IF (IA(I).LT.IA(J)) THEN
            ITEMP=IA(I)
            IA(I)=IA(J)
            IA(J)=ITEMP
          ENDIF
    5   CONTINUE
 10   CONTINUE
 
      RETURN
      END
