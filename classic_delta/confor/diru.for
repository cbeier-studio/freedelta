      SUBROUTINE CIINT (ICFLAG, IVAL, NC, IMIN, IMAX)                      DIR4
C
C* REVISED 26-JUL-89.
C* READS A CHARACTER-INDEXED LIST OF INTEGER VALUES.
C
C  IFLAG RETURNS FLAGS INDICATING THE STATUS OF THE VALUE READ FOR
C    EACH CHARACTER. FOR CHARACTER IC, ICFLAG(IC) NEGATIVE, ZERO, OR
C    POSITIVE INDICATES AN INVALID VALUE READ, NO VALUE READ, OR
C    A VALID VALUE READ, RESPECTIVELY.
C  IVAL RETURNS THE VALUES READ.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  IMIN RECEIVES THE MINIMUM ALLOWED VALUE.
C  IMAX RECEIVES THE MAXIMUM ALLOWED VALUE.
C
C  THE INPUT TAKES THE FORM IC1,IV1 IC2,IV2 ... AND IS TERMINATED
C    BY A STAR-WORD. THE 'ICI,' ARE OPTIONAL (SEE SUBR. CNUM).
C    IVAL(IC1) IS SET TO IV1, ETC.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR.
C
C
      DIMENSION ICFLAG(NC),IVAL(NC)
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
C     INITIALIZE.
      DO 20 I = 1, NC
   20   ICFLAG(I) = 0
      IC = 0
C
C     READ AND DECODE NEXT WORD.
   30 CALL NEXTWD (JE)
        IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 200
        CALL CNUM (ICFLAG, IB, IE, IC, NC, JE)
        IF (IC.LE.0)  GO TO 100
        CALL IDKOD (IVALUE, IBUF(JBUF), JE-JBUF, IERR)
        IF (IERR.NE.0)  GO TO 60
        IF (IVALUE.LT.IMIN .OR. IVALUE.GT.IMAX)  GO TO 50
        DO 40 JC = IB, IE
          IVAL(JC) = IVALUE
   40     CONTINUE
        GO TO 100
C
C       ERROR MESSAGES.
   50   IERRNO = 13
        IPOINT = JBUF + IERR - 1
        CALL MESSB (IERRNO, IMAX, 1, 3, IPOINT)
        GO TO 81
   60   IERRNO = 22
        IPOINT = JBUF
   80   CALL MESSA (IERRNO, 3, IPOINT)
   81   DO 85 JC = IB, IE
          ICFLAG(JC) = -1
   85     CONTINUE
C
  100   JBUF = JE
        GO TO 30
C
  200 RETURN
      END
      SUBROUTINE CIREAL (ICFLAG, VAL, NC, VMIN, VMAX)                       DIR4
C
C* REVISED 26-JUL-89.
C* READS A CHARACTER-INDEXED LIST OF REAL VALUES.
C
C  ICFLAG RETURNS FLAGS INDICATING THE STATUS OF THE VALUE READ FOR
C    EACH CHARACTER. FOR CHARACTER IC, ICFLAG(IC) NEGATIVE, ZERO, OR
C    POSITIVE INDICATES AN INVALID VALUE READ, NO VALUE READ, OR
C    A VALID VALUE READ, RESPECTIVELY.
C  VAL RETURNS THE VALUES READ.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  VMIN RECEIVES THE MINIMUM ALLOWED VALUE.
C  VMAX RECEIVES THE MAXIMUM ALLOWED VALUE.
C
C  THE INPUT TAKES THE FORM IC1,V1 IC2,V2 ... AND IS TERMINATED
C    BY A STAR-WORD. THE 'ICI,' ARE OPTIONAL (SEE SUBR. CNUM).
C    VAL(IC1) IS SET TO V1, ETC.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR.
C
C
      DIMENSION ICFLAG(NC),VAL(NC)
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
C     INITIALIZE.
      DO 20 I = 1, NC
   20   ICFLAG(I) = 0
      IC = 0
C
C     READ AND DECODE NEXT WORD.
   30 CALL NEXTWD (JE)
        IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 200
        CALL CNUM (ICFLAG, IB, IE, IC, NC, JE)
        IF (IC.LE.0)  GO TO 100
        CALL RDKOD (VALUE, IBUF(JBUF), JE-JBUF, IERR)
        IF (IERR.NE.0)  GO TO 50
        IF (VALUE.LT.VMIN)  THEN
          CALL MESSA (61, 4, JBUF)
          VALUE = VMIN
        ELSE IF (VALUE.GT.VMAX)  THEN
          CALL MESSA (62, 4, JBUF)
          VALUE = VMAX
        ENDIF
        DO 40 JC = IB, IE
          VAL(JC) = VALUE
   40     CONTINUE
        GO TO 100
C
C       ERROR MESSAGES.
   50   CALL MESSA (23, 3, JBUF+IERR-1)
        DO 85 JC = IB, IE
          ICFLAG(JC) = -1
   85     CONTINUE
C
  100   JBUF = JE
        GO TO 30
C
  200 RETURN
      END
      SUBROUTINE CSCALE (ICFLAG, ITYPC, VAL, NC)                            DIR4
 
C* REVISED  25-JUL-89.
C* READS A CHARACTER-INDEXED LIST OF REAL VALUES.
 
C  ICFLAG RETURNS FLAGS INDICATING THE STATUS OF THE VALUE READ FOR
C    EACH CHARACTER. FOR CHARACTER IC, ICFLAG(IC) NEGATIVE, ZERO, OR
C    POSITIVE INDICATES AN INVALID VALUE READ, NO VALUE READ, OR
C    A VALID VALUE READ, RESPECTIVELY.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  VAL RETURNS THE VALUES READ.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
 
C  THE INPUT TAKES THE FORM IC1,V1 IC2,V2 ... AND IS TERMINATED
C    BY A STAR-WORD. THE 'ICI,' ARE OPTIONAL (SEE SUBR. CNUM).
C    VAL(IC1) IS SET TO V1, ETC.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR.
 
      DIMENSION ICFLAG(NC),ITYPC(NC),VAL(NC)
 
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
 
C     INITIALIZE.
      DO 20 I = 1, NC
        VAL(I) = 1.
   20   ICFLAG(I) = 0
      IC = 0
 
C     READ AND DECODE NEXT WORD.
   30 CALL NEXTWD (JE)
        IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 200
        CALL CNUM (ICFLAG, IB, IE, IC, NC, JE)
        IF (IC.LE.0)  GO TO 100
        CALL RDKOD (VALUE, IBUF(JBUF), JE-JBUF, IERR)
        IF (IERR.NE.0)  GO TO 50
        DO 40 JC = IB, IE
          IF (IABS(ITYPC(JC)).NE.4)  GOTO 60
          VAL(JC) = VALUE
   40     CONTINUE
        GO TO 100
 
C       ERROR MESSAGES.
   50   IERRNO = 23
        IPOINT = JBUF + IERR - 1
        GOTO 70
 
   60   IERRNO = 24
        IPOINT = JBUF
        GOTO 70
 
   70   CALL MESSA (IERRNO, 3, IPOINT)
        DO 85 JC = IB, IE
          ICFLAG(JC) = -1
   85     CONTINUE
 
  100   JBUF = JE
        GO TO 30
C
  200 RETURN
      END
      SUBROUTINE DERNGS (NR, IDAT, LIDAT, IMAX, JE, IASCND)                 DIR4
C
C* REVISED 26-JUL-89.
C* DECODES A SET OF RANGES OF POSITIVE INTEGER VALUES.
C
C  NR RETURNS THE NUMBER OF RANGES, OR 0 IF THERE ARE ERRORS.
C  IDAT RETURNS THE ENDPOINTS OF THE RANGES (SEE BELOW).
C  LIDAT RECEIVES THE LENGTH OF IDAT. ITS VALUE MUST BE IDENTICAL WITH
C    THE VALUE IN DIM XXX.
C  IMAX RECEIVES THE MAXIMUM ALLOWED VALUE.
C  JE RECEIVES THE LOCATION IN IBUF IMMEDIATELY AFTER THE END OF
C    THE INPUT FIELD TO BE EXAMINED.
C  IASCND RECEIVES 1 IF THE NUMBERS MUST BE IN ASCENDING ORDER BETWEEN
C    RANGES, OTHERWISE 0. (THE NUMBERS MUST ALWAYS BE IN ASCENDING ORDER
C    WITHIN RANGES.)
C
C  THE TEXT TO BE DECODED IS IN THE INPUT BUFFER BETWEEN IBUF(JBUF)
C    AND IBUF(JE-1), AND TAKES THE FORM N1-M1:N2-M2:... .
C    THE -M1, -M2, ETC. ARE OPTIONAL. THE VALUES RETURNED IN IDAT ARE
C    N1, M1, N2, M2, ... .
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C
      DIMENSION IDAT(LIDAT)
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
 
      JB = JBUF
      IF (JB.GE.JE)  GO TO 200
      NR = 0
      JMAX = 0
C
C-    FIND NEXT COLON.
   20 IF (JB.GE.JE)  GO TO 1000
        CALL FINDS (KDCOLN, IBUF, JB, JE, JF)
C
C-      DECODE AND STORE RANGE.
        CALL DERNG (IB, IE, IMAX, JB, JF)
        IF (IB.LE.0)  GO TO 1000
        IF (IB.LE.JMAX .AND. IASCND.NE.0)  GO TO 210
        IF (NR.LE.0 .OR. IASCND.NE.0)  GO TO 100
        DO 60 I = 1, NR
          IF (IE.GE.IDAT(2*I-1) .AND. IB.LE.IDAT(2*I))  GO TO 220
   60     CONTINUE
  100   NR = NR + 1
        IF (2*NR.GT.LIDAT)  CALL MESSB (35, LIDAT, 1, -1, 0)
        IDAT(2*NR-1) = IB
        IDAT(2*NR) = IE
        JMAX = MAX0(JMAX,IE)
        JB = JF + 1
        GO TO 20
 
C-    ERROR MESSAGES.
  200 IERRNO = 10
      GO TO 900
  210 IERRNO = 65
      GO TO 900
  220 IERRNO = 39
  900 CALL MESSA (IERRNO, 3, JB)
      NR = 0
C-
 1000 RETURN
      END
      SUBROUTINE INIFMT (IW, LW, IIFMT)
 
C  REVISED 18-MAR-93.
C  INITIALIZES DEFAULT FORMATTING MARKS FOR CHARACTER NOTES.
 
      COMMON /FMTMKX/ IFMTMK,NFMTMK,FMTWRD(3),LFMTWD(3)
        CHARACTER*20 FMTWRD
 
      DIMENSION IW(LW)
 
      LFMT  = NFMTMK
      DO I = 1, NFMTMK
        LFMT = LFMT + LFMTWD(I) + 3
      ENDDO
      CALL ALLOC2 (LW, IIFMT, LFMT)
      LFMT = NFMTMK
      DO I = 1, NFMTMK
        J = LFMT + 1
        IW(IIFMT+I-1) = J
        IW(IIFMT+J-1) = LFMTWD(I) + 3
        IW(IIFMT+J) = LFMTWD(I) + 2
        IW(IIFMT+J+1) = 1
        CALL COPSIA (FMTWRD(I), IW(IIFMT+J+2), LFMTWD(I))
        LFMT = LFMT + LFMTWD(I) + 3
      ENDDO
      IFMTMK = 1
 
      RETURN
      END
      FUNCTION LOOKUP (INAM, LNAM, ITXNAM, LTXNAM, NUMNAM,                  ITEM
     * IDAT, LIDAT, LUNS, LRECS, ITINDX)
 
C  REVISED 05-FEB-99.
C  COMPARES THE NAME IN INAM WITH THOSE ON A SCRATCH FILE.
C  THE NAMES HAVE HAD TYPESETTING MARKS REMOVED, SO ONLY NAMES OF EQUAL LENGTH
C  CAN POSSIBLY MATCH.
C  IF THE NAME IS FOUND, RETURNS THE SCRATCH FILE RECORD NUMBER,
C  OTHERWISE ZERO.
 
C  INAM RECEIVES THE FULL TAXON NAME FROM THE ITEMS FILE.
C  LNAM RECEIVES THE LENGTH OF INAM.
C  JI RECEIVES THE ITEM NUMBER.
C  ITXNAM RECEIVES RECORD POINTERS TO TAXON NAMES ON LUNS.
C  LTXNAM RECEIVES THE LENGTHS OF TAXON NAMES ON LUNS.
C  NUMNAM RECEIVES THE NUMBER OF TAXON NAME RECORDS.
C  IDAT RECEIVES WORKING SPACE.
C  LIDAT RECEIVES THE LENGTH OF IDAT.
C  LUNS RECEIVES THE UNIT NUMBER CONTAINING THE NAMES.
C  LRECS RECEIVES THE RECORD LENGTH FOR LUNS.
C  ITXINDX RECEIVES THE AND RETURNS THE INDEX OF THE LAST NAME IN THE LIST
C   THAT WAS MATCHED.
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
 
      DIMENSION INAM(LNAM),ITXNAM(NUMNAM),LTXNAM(NUMNAM),IDAT(LIDAT)

C     The last index value is saved between calls, so that next search will
C     begin after the current match.
C     If names in the directive are in the same order as in the
C     items file, the search will be more efficient.
 
      LOOKUP = 0
 
      DO 500 JJJ = 1, NUMNAM
  
      ITINDX = ITINDX +1
      IF (ITINDX.GT.NUMNAM) ITINDX = 1
 
      LEN = LTXNAM(ITINDX)
      IF (LEN.NE.LNAM) GOTO 500

      KREC = IABS(ITXNAM(ITINDX))
 
C     READ LENGTH OF NAME.
C      CALL RDDAI (LEN, 1, LUNS, LRECS, KREC)
 
C     READ NAME.
      KREC1 = KREC + 1
      CALL RDDAI (IDAT, LEN, LUNS, LRECS, KREC1)
      KREC1 = KREC1 + (LRECS + LEN - 1)/LRECS
 
C     COMPARE NAMES, INCLUDING COMMENTS - A COMPLETE MATCH IS REQUIRED.
      IG = 1
      ISG = IG + 1
      IGN = IG + INAM(IG)
      JG = 1
      JSG = JG + 1
      JGN = JG + IDAT(JG)
      MISMATCH = 0
   20 IF (MISMATCH.NE.0.OR.ISG.GE.IGN.OR.JSG.GE.JGN)  GOTO 100
C       CHECK FOR COMMENTS IN BOTH NAMES.
        IF (INAM(ISG+1).NE.IDAT(JSG+1))  THEN
          MISMATCH = 1
          GOTO 20
        ELSE
          IF (INAM(ISG+1).EQ.0)  THEN
            INCMT = 1
          ELSE
            INCMT = 0
          ENDIF
          IB = ISG + 2
          IE = ISG + INAM(ISG) - 1
          JB = JSG + 2
          JE = JSG + IDAT(JSG) - 1
        ENDIF
C       FIRST REMOVE ANY TYPESETTING MARKS FROM THE NAME IN IDAT WHICH
C       WAS READ FROM THE SCRATCH FILE.
C       CAN'T REMOVE TYPESETTING MARKS FROM INAM BY THIS METHOD, BECAUSE THIS
C       IS PART OF THE CODED ITEM (NOT A COPY). WE WILL IGNORE TYPESETTING
C       MARKS AS WE PROCESS INAM.
        I1 = JB
        DO I = JB, JE
          IF (IGNOR(IDAT(I)).EQ.0)  THEN
            IDAT(I1) = IDAT(I)
            I1 = I1+1
          ENDIF
        ENDDO
        JE = I1 - 1
        I = IB
        J = JB
        LASTI = 0
        LASTJ = 0
C       IGNORE TYPESETTING MARKS AND MULTIPLE BLANKS IN COMMENTS.
        DO WHILE (MISMATCH.EQ.0.AND.I.LE.IE.AND.J.LE.JE)
          INCI = 1
          INCJ = 1
          IF (INCMT.GT.0)  THEN
            IF ((INAM(I).EQ.KBLANK.AND.LASTI.EQ.KBLANK) .OR.
     *          (INAM(I).EQ.KBLANK.AND.LASTI.EQ.KDLBRA) .OR.
     *          (INAM(I).EQ.KBLANK.AND.INAM(I+1).EQ.KDRBRA) .OR.
     *          (IGNOR(INAM(I)).NE.0))  THEN
              INCJ = 0
            ELSE IF ((IDAT(J).EQ.KBLANK.AND.LASTJ.EQ.KBLANK) .OR.
     *          (IDAT(J).EQ.KBLANK.AND.LASTJ.EQ.KDLBRA) .OR.
     *          (IDAT(J).EQ.KBLANK.AND.IDAT(J+1).EQ.KDRBRA)) THEN
              INCI = 0
            ENDIF
          ELSE
C           NOT IN COMMENT, STILL CHECK FOR TYPSET MARKS.
            IF (IGNOR(INAM(I)).NE.0)  INCJ = 0
          ENDIF
          IF (INCI+INCJ.EQ.2.AND.INAM(I).NE.IDAT(J))  THEN
            MISMATCH = 1
          ELSE
            LASTI = INAM(I)
            LASTJ = IDAT(J)
            IF (INCI.NE.0)  I = I + 1
            IF (INCJ.NE.0)  J = J + 1
          ENDIF
        END DO
C       STEP OVER ANY FURTHER TYPESETTING MARKS IN INAM.
   30   IF (I.LE.IE) THEN
          IF (IGNOR(INAM(I)).EQ.0) GOTO 40
          I = I + 1
          GOTO 30
        ENDIF
   40   IF (I.GT.IE.AND.J.GT.JE) THEN
          JSG = JSG + IDAT(JSG)
          ISG = ISG + INAM(ISG)
        ELSE
          MISMATCH = 1
        ENDIF
        GOTO 20
 
C     CHECK IF NAMES COMPLETELY MATCHED
  100 IF (MISMATCH.EQ.0)  THEN
        IF (ISG.LT.IGN .OR.JSG.LT.JGN)  MISMATCH = 1
      ENDIF
 
      IF (MISMATCH.EQ.0)  THEN
        CALL RDDAI (KREC2, 1, LUNS, LRECS, KREC1)
        LOOKUP = KREC2
        GOTO 1000
      ENDIF
 
  500 CONTINUE
 
 1000 RETURN
      END
      SUBROUTINE REMTPS (NAM, LNAM, NEWNAM, LNEW, IOWR)
 
C  REVISED 09-FEB-99.
C  REMOVES TYPESETTING MARKS FROM TAXON NAMES (IN FACT FROM ANY SENTENCE).
 
C  NAM RECEIVES THE ORIGINAL NAME.
C  LNAM RECEIVES THE LENGTH OF NAM. IF IOWR IS NOT ZERO, LNAM RETURNS THE NEW LENGTH.
C  NEWNAM RETURNS THE NAME WITHOUT TYPESETTING MARKS.
C  LNEW RECEIVES THE LENGTH OF NEWNAM.
C  IOWR RECEIVES WHETHER TO OVERWRITE THE ORIGINAL NAME WITH THE MODIFIED NAME.
 
      COMMON /IGNXXX/ ICMD,IGNTYP
 
      DIMENSION NAM(LNAM),NEWNAM(LNEW)
 
C     Initialize ICMD to zero i.e. not within RTF command string
      ICMD = 0
 
      JSG = 2
      KSG = 2
   10 IF (JSG.GT.NAM(1))  GOTO 100
C       COPY TYPE.
        NEWNAM(KSG+1) = NAM(JSG+1)
        JB = JSG + 2
        KB = KSG + 2
        L = NAM(JSG) - 2
        DO 50 I = 1, L
          J = JB+I-1
          IF (IGNOR(NAM(J)).NE.0)  GOTO 50
          NEWNAM(KB) = NAM(J)
          KB = KB + 1
   50     CONTINUE
        NEWNAM(KSG) = KB - KSG
        KSG = KB
        JSG = JSG + NAM(JSG)
        GOTO 10
 
  100 NEWLNAM = KSG - 1
      NEWNAM(1) = NEWLNAM
 
C     Overwrite old name with new.
      IF (IOWR.NE.0)  THEN
        CALL COPIA (NEWNAM, NAM, NEWLNAM)
        LNAM = NEWLNAM
      ENDIF
  
      RETURN
      END
      SUBROUTINE RDCDEP (ITYPC, NSTAT, ICFLAG, NC, MM1S, MM2S, MS,          DIR4
     * IDEP, IDAT, LIDAT, JIDAT, ISETAP)
 
C  REVISED 25-JUL-89.
C  READS CHARACTER DEPENDENCY INFORMATION.
C
C  ITYPC RECEIVES THE TYPES OF THE CHARACTERS. 1 - UNORDERED
C    MULTISTATE. 2 - ORDERED MULTISTATE. 3 - NUMERIC INTEGER.
C    4 - NUMERIC REAL. 5 - TEXT. -1 - EXCLUSIVE UNORDERED MULTISTATE.
C    -2 - EXCLUSIVE ORDERED MULTISTATE.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  ICFLAG RECEIVES WORKING SPACE OF LENGTH NC.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  MM1S RECEIVES WORKING SPACE OF LENGTH MS.
C  MM2S RECEIVES WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C  IDEP RETURNS THE DEPENDENCY INFORMATION.
C  IDAT IS WORKING SPACE.
C  LIDAT RECEIVES THE LENGTH OF IDAT AND IDEP.
C  JIDAT RETURNS THE INDEX OF LAST ELEMENT OF IDEP USED.
C  ISETAP RECEIVES WHETHER PROCESSING "APPLICABLE CHARACTERS" DIRECTIVE.
 
C  LOCAL VARIABLES.
C  ISPTR = POINTER TO THE FIRST STATE OF CURRENT CHARACTER.
C  IV = CURRENT MULTISTATE OR INTEGER VALUE.
C  JPTR = POINTER TO NEXT AVAILABLE LOCATION IN IDAT.
 
C  CHARACTER DEPENDENCY INFORMATION WILL BE STORED IN THE ARRAY ICDEP.
C  THE FIRST NC LOCATIONS IN ICDEP ARE POINTERS TO DEPENDENCY DATA
C  ASSOCIATED WITH EACH CHARACTER. IF THE POINTER VALUE IS ZERO, NO
C  OTHER CHARACTERS ARE CONTROLLED BY THAT CHARACTER. OTHERWISE, THE
C  POINTER INDICATES THE STARTING LOCATION OF THE ENTRY FOR THE
C  CONTROLLING STATES OF THAT CHARACTER. THERE ARE NSTAT(IC) POINTERS.
C  IF A STATE POINTER VALUE IS ZERO, NO CHARACTERS ARE CONTROLLED BY
C  THAT STATE. OTHERWISE, THE POINTER IS THE LOCATION IN ICDEP
C  CONTAINING THE NUMBER OF RANGES OF DEPENDENT CHARACTERS, WHICH IS
C  FOLLOWED BY THE PAIRS OF VALUES DELIMITING EACH RANGE.
 
      DIMENSION ITYPC(NC),NSTAT(NC),ICFLAG(NC),MM1S(MS),MM2S(MS),
     * IDAT(LIDAT),IDEP(LIDAT)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /VALXXX/ KVAR,KUNK,KNA,KVAL(64),LKVAL
 
      IF (NC.GT.LIDAT)  GOTO 3000
      CALL SETIA (IDAT, NC, 0)
      JPTR = NC + 1
C
C---  READ CHARACTER NUMBER.
  100 CALL SKNONB
      IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 1000
      JB = JBUF
  110 IF (IBUF(JBUF).EQ.KDCOM)  GO TO 120
      IF (IBUF(JBUF).EQ.KBLANK)  GO TO 710
        IF (IBUF(JBUF).EQ.KDSOL.OR.IBUF(JBUF).EQ.KDRANG
     *   .OR.IBUF(JBUF).EQ.KDAMP)  GO TO 700
        JBUF = JBUF + 1
        GO TO 110
C
  120 IF (JBUF.EQ.JB)  GO TO 710
      CALL IDKOD (IC, IBUF(JB), JBUF-JB, IERR)
      IF (IERR.NE.0)  GO TO 720
      IF (IC.LT.1.OR.IC.GT.NC)  GO TO 730
      IF (ITYPC(IC).GE.3)  GO TO 750
      NV = NSTAT(IC)
      IF (IDAT(IC).GT.0)  GO TO 150
C
C-    INITIALISE SPACE FOR STATES OF CHARACTER #IC.
      IDAT(IC) = JPTR
      IF (JPTR+NV.GT.LIDAT)  GOTO 3000
      CALL SETIA (IDAT(JPTR),NV, 0)
      JPTR = JPTR + NV
C
  150 ISPTR = IDAT(IC)
      IRANG = 0
C
C---  READ AND STORE VALUES.
C
  200 JBUF = JBUF + 1
        JB = JBUF
C
C       FIND NEXT DELIMITER.
  210   IF (IBUF(JBUF).EQ.KDSOL.OR.IBUF(JBUF).EQ.KDRANG.OR.
     *   IBUF(JBUF).EQ.KDCOLN)  GO TO 214
          IF (IBUF(JBUF).EQ.KDCOM.OR.IBUF(JBUF).EQ.KBLANK)  GO TO 700
          JBUF = JBUF + 1
          GO TO 210
  214     IF (JBUF.EQ.JB)  GO TO 710
C
        LF = JBUF - JB
        IF (IRANG.GT.0)  IRANG = IRANG + 1
        IF (IBUF(JBUF).EQ.KDRANG)  IRANG = 1
C
C       DECODE VALUE OF MULTISTATE CHARACTER.
        IF (LKVAL.GT.0)  GO TO 240
        CALL IDKOD (IV, IBUF(JB), LF, IERR)
        IF (IERR.NE.0)  GO TO 720
        IF (IV.LE.0.OR.IV.GT.NV)  GO TO 740
        GO TO 400
  240   IF (LF.NE.1)  GO TO 740
        DO 250 IV = 1, NV
          IF (IBUF(JB).EQ.KVAL(IV)) GO TO 400
  250     CONTINUE
        GO TO 720
C
C--     STORE VALUE.
C
  400   IF (IRANG.EQ.0)  THEN
          IF (IDAT(ISPTR+IV-1).NE.0)  GOTO 760
          IDAT(ISPTR+IV-1) = JPTR
        ENDIF
        IF (IRANG.EQ.1)  IV1 = IV
        IF (IRANG.LT.2)  GO TO 420
          DO 410 J = IV1, IV
            IF (IDAT(ISPTR+J-1).NE.0)  GOTO 760
            IDAT(ISPTR+J-1) = JPTR
  410     CONTINUE
        IRANG = 0
  420   IF (IBUF(JBUF).NE.KDCOLN)  GO TO 200
C
C--     DECODE RANGES.
        JBUF = JBUF + 1
        CALL NEXTWD(JE)
        IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 1000
          CALL DERNGS (NR, IDAT(JPTR+1), LIDAT-JPTR, NC, JE, 1)
          IF (NR.GT.0)  GO TO 500
            JBUF = JE
            GO TO 100
  500   IDAT(JPTR) = NR
        JPTR = JPTR + 2*NR + 1
        JBUF = JE
        GO TO 100
 
C--   ERROR IN CHARACTER OR VALUE.
  700 IERRNO = 31
      IPOINT = JBUF
      GO TO 800
  710 IERRNO = 10
      IPOINT = JBUF
      GO TO 800
  720 IERRNO = 12
      IPOINT = JB + IERR - 1
      GO TO 800
  730 IERRNO = 13
      IPOINT = JBUF
      CALL MESSB (IERRNO, NC, 1, 3, IPOINT)
      GO TO 1900
  740 IERRNO = 22
      IPOINT = JBUF
      GO TO 800
  750 IERRNO = 33
      IPOINT = JB
      GOTO 800
  760 IERRNO = 34
      IPOINT = JB
      GOTO 800
 
  800 CALL MESSA (IERRNO, 3, IPOINT)
      GOTO 1900
C
C---
 1000 JIDAT = JPTR - 1
      IF (ISETAP.EQ.0)  THEN
        CALL COPIA (IDAT, IDEP, JIDAT)
        GOTO 2000
      ENDIF
 
C---  TRANSLATE APPLICABLE CHARACTERS TO INAPPLICABLE EQUIVALENT.
      CALL SETIA (IDEP, NC, 0)
      JPTR = NC + 1
 
      DO 1500 IC = 1, NC
        IF (IDAT(IC).EQ.0)  GOTO 1500
        ISPTR = IDAT(IC)
 
C-      COMPILE LIST OF CONTROLLED CHARACTERS.
        CALL SETIA (ICFLAG, NC, 0)
        KNTAPP = 0
        NS = NSTAT(IC)
        DO 1100 IS = 1, NS
          IF (IDAT(ISPTR+IS-1).EQ.0)  GOTO 1100
          IRPTR = IDAT(ISPTR+IS-1)
          NR = IDAT(IRPTR)
          DO 1050 IR = 1, NR
            IB = IDAT(IRPTR+2*IR-1)
            IE = IDAT(IRPTR+2*IR)
            DO 1040 KC = IB, IE
              ICFLAG(KC) = 1
              KNTAPP = KNTAPP + 1
 1040         CONTINUE
 1050       CONTINUE
 1100     CONTINUE
 
C-      USE THIS LIST TO DETERMINE SET OF INAPPLICABLE CHARACTERS
C        FOR EACH STATE.
        IDEP(IC) = JPTR
        CALL SETIA (IDEP(JPTR), NS, 0)
        JSPTR = JPTR
        JPTR = JPTR + NS
 
        CALL COPIA (IDAT(ISPTR), MM1S, NS)
        DO 1300 IS = 1, NS
          IF (MM1S(IS).LT.0)  GOTO 1300
          INAPP = KNTAPP
          IRPTR = MM1S(IS)
          CALL SETIA (MM2S, NS, 0)
          MM2S(IS) = 1
C         CHECK FOR STATES POINTING TO SAME SET OF RANGES.
          DO 1120 KS = IS+1, NS
            IF (MM1S(KS).NE.IRPTR)  GOTO 1120
            MM2S(KS) = 1
            MM1S(KS) = -1
 1120       CONTINUE
          NR = IDAT(IRPTR)
          DO 1150 IR = 1, NR
            IB = IDAT(IRPTR+2*IR-1)
            IE = IDAT(IRPTR+2*IR)
            DO 1140 KC = IB, IE
              INAPP = INAPP - 1
              ICFLAG(KC) = -ICFLAG(KC)
 1140         CONTINUE
 1150       CONTINUE
 
C         SET STATE POINTER TO RANGES.
 1160     IF (INAPP.LE.0)  GOTO 1210
          DO 1165 KS = 1, NS
            IF (MM2S(KS).NE.0)  IDEP(JSPTR+KS-1) = JPTR
 1165       CONTINUE
 
C-        POSITIVE CHARACTER FLAGS REPRESENT INAPPLICABLE CHARACTERS.
          IB = 0
          NR = 0
          DO 1200 KC = 1, NC
            IF (ICFLAG(KC).LE.0)  GOTO 1180
            IF (IB.LE.0)  IB = KC
            IE = KC
            IF (KC.LT.NC)  GOTO 1200
 1180       IF (IB.LE.0)  GOTO 1200
C           OUTPUT RANGE.
            NR = NR + 1
            IDEP(JPTR+2*NR-1) = IB
            IDEP(JPTR+2*NR) = IE
            IB = 0
 1200       CONTINUE
 
          IDEP(JPTR) = NR
          JPTR = JPTR + 2 * NR + 1
 
C         REINITIALIZE CHARACTER LIST.
 1210     DO 1250 KC = 1, NC
            ICFLAG(KC) = IABS(ICFLAG(KC))
 1250       CONTINUE
 
 1300     CONTINUE
 
 1500   CONTINUE
 
 1900 JIDAT = JPTR - 1
 
 2000 RETURN
 
 3000 CALL MESSB (35, LIDAT, 1, -1, 0)
 
      END
      SUBROUTINE TCMASK (MSKADD, ITAXA, NI, ICHARS, JCHARS, NC,             DIRU
     * IDAT, IDAT1, LIDAT,
     * NAMTXT, LNAMTXT, NTXT, LUNTS, IRECS, FNAME, ISCRNO, LUNTST,
     * IRECST, FNAMET, ISCRNOT)
 
C* REVISED 05-FEB-99.
C* READS A CHARACTER MASK ASSOCIATED WITH A PARTICULAR TAXON.
 
C  MSKADD RECEIVES 1 IF INFORMATION IS TO BE ADDED TO AN EXISTING MASK,
C   0 IF A NEW MASK IS BEING CREATED.
C  ITAXA RETURNS RECORD ADDRESSES OF CHARACTER MASKS.
C  NI RECEIVES THE NUMBER OF TAXA.
C  ICHARS RECEIVES WORKING SPACE OF LENGTH NC.
C  JCHARS RECEIVES WORKING SPACE OF LENGTH NC.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  IDAT RECEIVES WORKING SPACE OF LENGTH OF LIDAT.
C  IDAT1 RECEIVES WORKING SPACE OF LENGTH OF LIDAT.
C  LIDAT RECEIVES THE LENGTH OF IDAT.
C  NAMTXT RETURNS POINTERS TO TAXON NAME RECORDS.
C  LNAMTXT RETURNS THE LENGTHS OF THE STORED TAXON NAMES.
C  NTXT RETURNS THE NUMBER OF TAXON NAME RECORDS.
C  LUNTS RECEIVES THE TYPE OF SCRATCH UNIT FOR THE CHARACTER NUMBERS.
C  IRECS RECEIVES AND RETURNS THE LAST USED RECORD ON THE CHARACTER NUMBER SCRATCH FILE.
C  FNAME RECEIVES THE FILE NAME FOR THE SCRATCH FILE FOR THE CHARACTER NUMBERS.
C  ISCRNO RECEIVES THE THE SCRATCH FILE NUMBER.
C  LUNTST RECEIVES THE TYPE OF SCRATCH UNIT FOR THE TAXON NAMES.
C  IRECST RECEIVES AND RETURNS THE LAST USED RECORD ON THE TAXON NAME SCRATCH FILE.
C  FNAMET RECEIVES THE FILE NAME FOR THE SCRATCH FILE FOR THE TAXON NAMES.
C  ISCRNOT RECEIVES THE THE SCRATCH FILE NUMBER FOR TAXON NAMES.
 
C  THE INPUT TAKES THE FORM #T1. N1-M1 N2-M2 ... #T2. N1-M1 N2-M2 ...
C     AND IS TERMINATED BY A STAR-WORD. THE -M1, -M2, ... ARE OPTIONAL.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR OF THE STAR-WORD.
 
      DIMENSION ITAXA(NI),ICHARS(NC),JCHARS(NC),IDAT(LIDAT),
     * IDAT1(LIDAT),NAMTXT(NI),LNAMTXT(NI)
      CHARACTER*(*) FNAME
      CHARACTER*(*) FNAMET
 
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
      COMMON /SCRCXX/ LRECSC
 
      CHARACTER*60 FSPEC
 
      IF (MSKADD.EQ.0)  THEN
 
C-      OPEN SCRATCH FILE FOR CHARACTER NUMBERS.
        LRECS = LRECSC
        CALL GETAU (LUN)
        FSPEC = FNAME
        CALL SETLUN (FSPEC, LUN, LUNTS)
        CALL UOPEN (LUN, LUNUSE(LUN), FSPEC, LRECS, IERR)
        IF (IERR.NE.0)  CALL MESSB (20, ISCRNO, 1, -1, 0)
 
C       SET RECORD POINTER FOR SCRATCH FILE.
        IRECS = 0
 
C-      INITIALIZE TAXON RECORD POINTERS.
        CALL SETIA (ITAXA, NI, 0)
 
      ELSE
 
        IF (ISCRNO.EQ.4)  THEN
          LUN = LUNS4
        ELSE
          LUN = LUNS5
        ENDIF
        LRECS = LRECSC
 
      ENDIF
 
C-    OPEN SCRATCH FILE FOR TAXON NAMES.
      IF (LUNS7.LT.0)  THEN
        LRECST = 32
        CALL GETAU (LUNNAM)
        FSPEC = FNAMET
        CALL SETLUN (FSPEC, LUNNAM, LUNTST)
        CALL UOPEN (LUNNAM, LUNUSE(LUNNAM), FSPEC, LRECST, IERR)
        IF (IERR.NE.0)  CALL MESSB (20, ISCRNOT, 1, -1, 0)
 
C       SET RECORD POINTER FOR SCRATCH FILE.
        IRECST = 0
      ELSE
        LUNNAM = LUNS7
        LRECST = 32
      ENDIF

      IFIRST = 1
      ITINDX = 0
 
C-    GET NEXT WORD AND CHECK FOR STAR OR NUMERO.
   20 CALL NEXTWD (JE)
 
   30   IF (IBUF(JBUF).EQ.KDSTAR.OR.IBUF(JBUF).EQ.KDNUM)  THEN
 
C         OUTPUT PREVIOUS DIAGNOSTIC CHARACTER SET (IF NON-EMPTY).
          IF (IFIRST.EQ.0.AND.NONZER(JCHARS, NC).GT.0)  THEN
            IF (IT1.GT.0)  THEN
C             TAXON RANGE.
              DO IT = IT1, IT2
                IF (IT.GT.0.AND.ITAXA(IT).EQ.0)  THEN
                  CALL COPIA (JCHARS, ICHARS, NC)
                ELSE IF (IT.GT.0.AND.ITAXA(IT).NE.0) THEN
C                 ADD TO EXISTING LIST OF CHARACTERS.
                  IREC = ITAXA(IT)
                  CALL RDDAI (ICHARS, NC, LUN, LRECS, IREC)
                  DO IC = 1, NC
                    IF (JCHARS(IC).NE.0) ICHARS(IC) = 1
                  ENDDO
                ENDIF
                IF (ITAXA(IT).EQ.0)  THEN
                  IRECO = IRECS
                  IRECS = IRECS + (NC+LRECS-1)/LRECS
                  ITAXA(IT) = IRECO + 1
                ELSE
                  IRECO = ITAXA(IT) - 1
                ENDIF
C               WRITE CHARACTER LIST.
                CALL WRDAI (ICHARS, NC, LUN, LRECS, IRECO)
              ENDDO
            ELSE
C             TAXON NAME.
              MATCHREC = 0
              CALL REMTPS (IDAT, JIDAT, IDAT1, LIDAT, 1)
              IF (NTXT.GT.0) MATCHREC =  LOOKUP (IDAT, JIDAT, NAMTXT,
     *          LNAMTXT, NTXT, IDAT1, LIDAT, LUNNAM, LRECST, ITINDX)
              IF (MATCHREC.EQ.0)  THEN
C               A new taxon name.
                IRECO = IRECST
                NTXT = NTXT + 1
C               Fatal error: more names than MI - will overflow array.
                IF (NTXT.GT.NI) CALL MESSA (125, -2, 0)
                NAMTXT(NTXT) = IRECO + 1
                LNAMTXT(NTXT) = JIDAT
                CALL WRDAI (JIDAT, 1, LUNNAM, LRECST, IRECO)
                CALL WRDAI (IDAT, JIDAT, LUNNAM, LRECST, IRECO)
C               RECORD LOCATION OF ASSOCIATED INFORMATION.
                CALL WRDAI (IRECS+1, 1, LUNNAM, LRECS, IRECO)
                IRECST = IRECO
                IRECO = IRECS
                IRECS = IRECS + (NC+LRECS-1)/LRECS
C               WRITE CHARACTER LIST.
                CALL WRDAI (JCHARS, NC, LUN, LRECS, IRECO)
              ELSE
C               Taxon name already on list.
                CALL RDDAI (ICHARS, NC, LUN, LRECS, MATCHREC)
                DO IC = 1, NC
                  IF (JCHARS(IC).NE.0)  ICHARS(IC) = 1
                ENDDO
                CALL WRDAI (ICHARS, NC, LUN, LRECS, MATCHREC-1)
              ENDIF
            ENDIF
 
          ENDIF
          IF (IBUF(JBUF).EQ.KDSTAR)  GOTO 1000
 
C         READ TAXON NAME OR NUMBER.
          JBUF = JBUF + 1
          CALL READT (JE, IT1, IT2, NI, IDAT, LIDAT, JIDAT, INAME)
          IF (IT1.GT.0)  THEN
            CONTINUE
          ELSE IF (INAME.EQ.1)  THEN
            JE = JBUF
          ELSE IF (INAME.EQ.-1)  THEN
            CALL MESSA(98, 3, JBUF)
            CALL SKDELW (1)
            GOTO 20
          ELSE
            CALL SKDELW (1)
            GOTO 20
          ENDIF
 
          CALL SETIA (JCHARS, NC, 0)
          IFIRST = 0
 
        ELSE
 
          IF (IFIRST.NE.0)  GOTO 75
C-        DECODE CHARACTER RANGE.
   40     CALL DERNG (IB, IE, NC, JBUF, JE)
          IF (IB.LE.0)  GO TO 60
 
C-        SET VALUES.
          DO 50 I = IB, IE
            JCHARS(I) = 1
   50     CONTINUE
 
        ENDIF
 
C-      PREPARE FOR NEXT WORD.
   60   JBUF = JE
        GO TO 20
 
C-    INVALID TAXON NUMBER - SKIP TO NEXT STAR OR NUMERO.
   70 IERRNO = 37
      IPOINT = JBUF
      GOTO 77
   75 IERRNO = 38
      IPOINT = JBUF
      GOTO 77
   76 IERRNO = 72
      IPOINT = JE
      JBUF = JE
 
   77 CALL MESSA (IERRNO, 3, IPOINT)
 
   80 CALL NEXTWD (JE)
        IF (IBUF(JBUF).EQ.KDSTAR)  GOTO 1000
        IF (IBUF(JBUF).EQ.KDNUM)  GOTO 30
        JBUF = JBUF + 1
        GOTO 80
 
 1000 RETURN
      END
C      SUBROUTINE TCMASK (MSKADD, ITAXA, NI, ICHARS, JCHARS, NC,             DIRU
C     * IDAT, LIDAT,
C     * NAMTXT, NTXT, LUNTS, IRECS, FNAME, ISCRNO, LUNTST, IRECST,
C     * FNAMET, ISCRNOT)
C 
CC* REVISED 04-FEB-99.
CC* READS A CHARACTER MASK ASSOCIATED WITH A PARTICULAR TAXON.
C 
CC  MSKADD RECEIVES 1 IF INFORMATION IS TO BE ADDED TO AN EXISTING MASK,
CC   0 IF A NEW MASK IS BEING CREATED.
CC  ITAXA RETURNS RECORD ADDRESSES OF CHARACTER MASKS.
CC  NI RECEIVES THE NUMBER OF TAXA.
CC  ICHARS RECEIVES WORKING SPACE OF LENGTH NC.
CC  JCHARS RECEIVES WORKING SPACE OF LENGTH NC.
CC  NC RECEIVES THE NUMBER OF CHARACTERS.
CC  IDAT RECEIVES WORKING SPACE OF LENGTH OF LIDAT.
CC  LIDAT RECEIVES THE LENGTH OF IDAT.
CC  NAMTXT RETURNS POINTERS TO TAXON NAME RECORDS.
CC  NTXT RETURNS THE NUMBER OF TAXON NAME RECORDS.
CC  LUNTS RECEIVES THE TYPE OF SCRATCH UNIT FOR THE CHARACTER NUMBERS.
CC  IRECS RECEIVES AND RETURNS THE LAST USED RECORD ON THE CHARACTER NUMBER SCRATCH FILE.
CC  FNAME RECEIVES THE FILE NAME FOR THE SCRATCH FILE FOR THE CHARACTER NUMBERS.
CC  ISCRNO RECEIVES THE THE SCRATCH FILE NUMBER.
CC  LUNTST RECEIVES THE TYPE OF SCRATCH UNIT FOR THE TAXON NAMES.
CC  IRECST RECEIVES AND RETURNS THE LAST USED RECORD ON THE TAXON NAME SCRATCH FILE.
CC  FNAMET RECEIVES THE FILE NAME FOR THE SCRATCH FILE FOR THE TAXON NAMES.
CC  ISCRNOT RECEIVES THE THE SCRATCH FILE NUMBER FOR TAXON NAMES.
C 
CC  THE INPUT TAKES THE FORM #T1. N1-M1 N2-M2 ... #T2. N1-M1 N2-M2 ...
CC     AND IS TERMINATED BY A STAR-WORD. THE -M1, -M2, ... ARE OPTIONAL.
CC  NEW RECORDS ARE READ IF REQUIRED.
CC  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
CC    NCERR IS INCREMENTED.
CC  ON EXIT, JBUF IS POSITIONED AT THE STAR OF THE STAR-WORD.
C 
C      DIMENSION ITAXA(NI),ICHARS(NC),JCHARS(NC),IDAT(LIDAT),NAMTXT(NI)
C      CHARACTER*(*) FNAME
C      CHARACTER*(*) FNAMET
C 
C      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
C     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
C      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
C     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
C      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
C     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
C      COMMON /SCRCXX/ LRECSC
C 
C      CHARACTER*60 FSPEC
C 
C      IF (MSKADD.EQ.0)  THEN
C 
CC-      OPEN SCRATCH FILE FOR CHARACTER NUMBERS.
C        LRECS = LRECSC
C        CALL GETAU (LUN)
C        FSPEC = FNAME
C        CALL SETLUN (FSPEC, LUN, LUNTS)
C        CALL UOPEN (LUN, LUNUSE(LUN), FSPEC, LRECS, IERR)
C        IF (IERR.NE.0)  CALL MESSB (20, ISCRNO, 1, -1, 0)
C 
CC       SET RECORD POINTER FOR SCRATCH FILE.
C        IRECS = 0
C 
CC-      INITIALIZE TAXON RECORD POINTERS.
C        CALL SETIA (ITAXA, NI, 0)
C 
C      ELSE
C 
C        IF (ISCRNO.EQ.4)  THEN
C          LUN = LUNS4
C        ELSE
C          LUN = LUNS5
C        ENDIF
C        LRECS = LRECSC
C 
C      ENDIF
C 
CC-    OPEN SCRATCH FILE FOR TAXON NAMES.
C      IF (LUNS7.LT.0)  THEN
C        LRECST = 32
C        CALL GETAU (LUNNAM)
C        FSPEC = FNAMET
C        CALL SETLUN (FSPEC, LUNNAM, LUNTST)
C        CALL UOPEN (LUNNAM, LUNUSE(LUNNAM), FSPEC, LRECST, IERR)
C        IF (IERR.NE.0)  CALL MESSB (20, ISCRNOT, 1, -1, 0)
C 
CC       SET RECORD POINTER FOR SCRATCH FILE.
C        IRECST = 0
C      ELSE
C        LUNNAM = LUNS7
C        LRECST = 32
C      ENDIF
C
C      IFIRST = 1
C 
CC-    GET NEXT WORD AND CHECK FOR STAR OR NUMERO.
C   20 CALL NEXTWD (JE)
C 
C   30   IF (IBUF(JBUF).EQ.KDSTAR.OR.IBUF(JBUF).EQ.KDNUM)  THEN
C 
CC         OUTPUT PREVIOUS DIAGNOSTIC CHARACTER SET.
C          IF (IFIRST.EQ.0)  THEN
C            IF (IT1.GT.0)  THEN
CC             TAXON RANGE.
C              DO IT = IT1, IT2
C                IF (IT.GT.0.AND.ITAXA(IT).EQ.0)  THEN
C                  CALL COPIA (JCHARS, ICHARS, NC)
C                ELSE IF (IT.GT.0.AND.ITAXA(IT).NE.0) THEN
CC                 ADD TO EXISTING LIST OF CHARACTERS.
C                  IREC = ITAXA(IT)
C                  CALL RDDAI (ICHARS, NC, LUN, LRECS, IREC)
C                  DO IC = 1, NC
C                    IF (JCHARS(IC).NE.0) ICHARS(IC) = 1
C                  ENDDO
C                ENDIF
C                IF (ITAXA(IT).EQ.0)  THEN
C                  IRECO = IRECS
C                  IRECS = IRECS + (NC+LRECS-1)/LRECS
C                  ITAXA(IT) = IRECO + 1
C                ELSE
C                  IRECO = ITAXA(IT) - 1
C                ENDIF
CC               WRITE CHARACTER LIST.
C                CALL WRDAI (ICHARS, NC, LUN, LRECS, IRECO)
C              ENDDO
C            ELSE
CC             TAXON NAME.
C              IRECO = IRECST
C              NTXT = NTXT + 1
C              NAMTXT(NTXT) = IRECO + 1
C              CALL WRDAI (JIDAT, 1, LUNNAM, LRECST, IRECO)
C              CALL WRDAI (IDAT, JIDAT, LUNNAM, LRECST, IRECO)
CC             RECORD LOCATION OF ASSOCIATED INFORMATION.
C              CALL WRDAI (IRECS+1, 1, LUNNAM, LRECS, IRECO)
C              IRECST = IRECO
C              IRECO = IRECS
C              IRECS = IRECS + (NC+LRECS-1)/LRECS
CC             WRITE CHARACTER LIST.
C              CALL WRDAI (JCHARS, NC, LUN, LRECS, IRECO)
C            ENDIF
C 
C          ENDIF
C          IF (IBUF(JBUF).EQ.KDSTAR)  GOTO 1000
C 
CC         READ TAXON NAME OR NUMBER.
C          JBUF = JBUF + 1
C          CALL READT (JE, IT1, IT2, NI, IDAT, LIDAT, JIDAT, INAME)
C          IF (IT1.GT.0)  THEN
C            CONTINUE
C          ELSE IF (INAME.EQ.1)  THEN
C            JE = JBUF
C          ELSE IF (INAME.EQ.-1)  THEN
C            CALL MESSA(98, 3, JBUF)
C            CALL SKDELW (1)
C            GOTO 20
C          ELSE
C            CALL SKDELW (1)
C            GOTO 20
C          ENDIF
C 
C          CALL SETIA (JCHARS, NC, 0)
C          IFIRST = 0
C 
C        ELSE
C 
C          IF (IFIRST.NE.0)  GOTO 75
CC-        DECODE CHARACTER RANGE.
C   40     CALL DERNG (IB, IE, NC, JBUF, JE)
C          IF (IB.LE.0)  GO TO 60
C 
CC-        SET VALUES.
C          DO 50 I = IB, IE
C            JCHARS(I) = 1
C   50     CONTINUE
C 
C        ENDIF
C 
CC-      PREPARE FOR NEXT WORD.
C   60   JBUF = JE
C        GO TO 20
C 
CC-    INVALID TAXON NUMBER - SKIP TO NEXT STAR OR NUMERO.
C   70 IERRNO = 37
C      IPOINT = JBUF
C      GOTO 77
C   75 IERRNO = 38
C      IPOINT = JBUF
C      GOTO 77
C   76 IERRNO = 72
C      IPOINT = JE
C      JBUF = JE
C 
C   77 CALL MESSA (IERRNO, 3, IPOINT)
C 
C   80 CALL NEXTWD (JE)
C        IF (IBUF(JBUF).EQ.KDSTAR)  GOTO 1000
C        IF (IBUF(JBUF).EQ.KDNUM)  GOTO 30
C        JBUF = JBUF + 1
C        GOTO 80
C 
C 1000 RETURN
C      END
      SUBROUTINE RDGRPS (IGRP, NC, IDAT, LIDAT)                             DIR4
 
C* REVISED 25-JUL-89.
C* READS CHARACTER GROUPINGS.
 
C  IGRP RETURNS THE GROUPS (SEE BELOW).
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  IDAT IS WORKING SPACE.
C  LIDAT RECEIVES THE LENGTH OF IDAT. THIS MUST BE IDENTICAL WITH THE
C  VALUE IN DIM XXX.
 
C  THE DATA ARE SETS OF RANGES OF THE FORM N1-M1:N2-M2:... (SEE
C    SUBR. DERNGS), AND ARE TERMINATED BY A STAR-WORD.
C    THE ELEMENTS OF LINKC ARE INITIALIZED TO 0, THEN,
C    FOR EACH SET OF RANGES, LINKC(N1) TO LINKC(M1), LINKC(N2) TO
C    LINKC(M2), ETC., ARE SET TO 1, 2, 3, ETC.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR OF THE STAR-WORD.
 
      DIMENSION IGRP(NC),IDAT(LIDAT)
 
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
 
      CALL SETIA (IGRP, NC, 0)
      NGRP = 0
 
C-    GET NEXT WORD, AND DECODE RANGES.
   20 CALL NEXTWD (JE)
        IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 1000
        CALL DERNGS (NR, IDAT, LIDAT, NC, JE, 1)
        IF (NR.LE.0)  GO TO 300
 
C-      SET GROUPS.
        NGRP = NGRP + 1
        DO 40 J = 1, NR
          IB = IDAT(2*J-1)
          IE = IDAT(2*J)
          DO 30 I = IB, IE
            IF (IGRP(I).NE.0)  GO TO 200
   30       IGRP(I) = NGRP
   40     CONTINUE
        GO TO 300
 
C-      ERROR MESSAGE.
  200   CALL MESSA (39, 3, JBUF)
 
C-      PREPARE FOR NEXT WORD.
  300   JBUF = JE
        GO TO 20
 
 1000 RETURN
      END
      SUBROUTINE RDIMGD (IREC, IDAT, LIDAT)                                DIR4
 
C* REVISED 9-MAR-96.
C* READS TEXT DATA AND WRITES TO A SCRATCH FILE.
C  THE TEXT IS ASSOCIATED WITH EITHER STARTUP IMAGES, CHARACTER KEYWORD IMAGES,
C  OR TAXON KEYWORD IMAGES.
 
C  IREC RETURNS THE RECORD POINTER TO THE STRING.
C  IDAT RECEIVES WORKING SPACE.
C  LIDAT RECEIVES THE LENGTH OF IDAT. ITS VALUE MUST BE IDENTICAL WITH
C    THE VALUE IN DIMXXX.
 
C  INPUT IS TERMINATED BY A STAR-WORD.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR OF THE STAR-WORD.
 
      DIMENSION IDAT(LIDAT)
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
      COMMON /SCRNMX/ SCRNAM(7)
        CHARACTER*8 SCRNAM
      COMMON /SCRXXX/ LUNTS1,LUNTS2,LUNTS3,LUNTS4,LUNTS5,LUNTS6,LUNTS7
      COMMON /SCR6XX/ LRECS6,IRECS6
 
      CHARACTER FSPEC*60
 
      IREC = 0
 
      IF (LUNS6.LT.0) THEN
C       OPEN SCRATCH FILE 6 TO STORE INTERMEDIATE DATA.
        IRECS6 = 0
        LRECS6 = 32
        CALL GETAU (LUN)
        FSPEC = SCRNAM(6)
        CALL SETLUN (FSPEC, LUN, LUNTS6)
        CALL UOPEN (LUN, LUNUSE(LUN), FSPEC, LRECS6, IERR)
        IF (IERR.NE.0)  CALL MESSB (20, 6, 1, -1, 0)
      ENDIF

C-    READ TEXT.
      JIDAT = 0
      CALL SENTNC (IDAT, LIDAT, -1, JIDAT, IERR)
      IF (IERR.LT.0)  GOTO 1000
C     OUTPUT ITEM TO SCRATCH FILE.
      IF (JIDAT.GT.3)  THEN
        IREC = IRECS6 + 1
        CALL WRDAI (JIDAT, 1, LUNS6, LRECS6, IRECS6)
        CALL WRDAI (IDAT, JIDAT, LUNS6, LRECS6, IRECS6)
      ENDIF
 
      GOTO 1000
C-    
C-
C  500 CALL MESSA (76, 1, 0)
 
 1000 RETURN
      END
      SUBROUTINE RDIMP (IMPL1, IMPL2, ITYPC, NSTAT, NC)                     DIR4
 
C* REVISED 30-MAR-93.
C* READS IMPLICIT VALUES.
 
C  IMPL1(IC) RETURNS THE IMPLICIT VALUE TO BE USED WHEN CHARACTER IC
C    IS MISSING FROM AN ITEM DESCRIPTION.
C  IMPL2(IC) RETURNS THE IMPLICIT VALUE TO BE USED WHEN CHARACTER IC
C    IS SPECIFIED IN AN ITEM DESCRIPTION WITHOUT A VALUE.
C  ITYPC RECEIVES THE CHARACTER TYPES. -1 - EXCLUSIVE UNORDERED
C    MULTISTATE. -2 - EXCLUSIVE ORDERED MULTISTATE. 1 - UNORDERED
C    MULTISTATE. 2 - ORDERED MULTISTATE. 3 - INTEGER NUMERIC.
C    4 - REAL NUMERIC. 5 - TEXT.
C  NSTAT RECEIVES THE NUMBER OF STATES.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C
C  THE DATA IS OF THE FORM IC1-IC2,IV1:IV2. THE ELEMENTS OF IMPL1,IMPL2
C  ARE INITIALISED TO 0, THEN, FOR EACH SET OF RANGES IC1 TO IC2, THE
C  ELEMENTS OF IMPL1(IC1) TO IMPL1(IC2) ARE SET TO IV1 AND IMPL2(IC1) TO
C  IMPL2(IC2) ARE SET TO IV2.
C
 
      DIMENSION IMPL1(NC),IMPL2(NC),ITYPC(NC),NSTAT(NC)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /VALXXX/ KVAR,KUNK,KNA,KVAL(64),LKVAL
 
      CALL SETIA (IMPL1, NC, 0)
      CALL SETIA (IMPL2, NC, 0)
 
C---  READ CHARACTER RANGES.
10    CALL SKNONB
      IF (IBUF(JBUF).EQ.KDSTAR.OR.IBUF(JBUF).EQ.KDNUM)  GO TO 1000
      JB = JBUF
 
   20 IF (IBUF(JBUF).EQ.KDCOM)  GO TO 30
        IF (IBUF(JBUF).EQ.KDCOLN.OR.IBUF(JBUF).EQ.KBLANK)  GO TO 500
        JBUF = JBUF + 1
        GO TO 20
 
   30 IF (JBUF.EQ.JB)  GO TO 510
      CALL DERNG (IB, IE, NC, JB, JBUF)
      IF (IB.EQ.0)  GO TO 170
      DO 40 IC = IB, IE
        IF (ITYPC(IC).GE.3)  GO TO 540
        IF (IMPL1(IC).NE.0)  GO TO 550
   40   CONTINUE
C
C---  READ AND STORE IMPLICIT VALUES.
      ISET = 1
   50 JBUF = JBUF + 1
      JB = JBUF
C
C     FIND NEXT DELIMITER.
   55 IF (IBUF(JBUF).EQ.KBLANK)  GO TO 60
      IF (IBUF(JBUF).EQ.KDCOLN.AND.ISET.EQ.1)  GO TO 60
        IF (IBUF(JBUF).EQ.KDCOLN.OR.IBUF(JBUF).EQ.KDCOM
     *   .OR.IBUF(JBUF).EQ.KDSOL)  GO TO 500
        JBUF = JBUF + 1
        GO TO 55
C
   60 IF (JBUF.EQ.JB)  GO TO 510
      LF = JBUF - JB
C
C     DECODE VALUES.
      IF (LKVAL.GT.0)  GO TO 70
      CALL IDKOD (IV, IBUF(JB), LF, IERR)
      IF (IERR.NE.0)  GO TO 100
      DO 65 IC = IB, IE
        IF (IV.LT.1.OR.IV.GT.NSTAT(IC))  GO TO 560
   65   CONTINUE
      GO TO 130
C
   70 IF (LF.NE.1)  GO TO 560
      DO 75 IV = 1, LKVAL
        IF (IBUF(JB).EQ.KVAL(IV)) GO TO 80
   75   CONTINUE
      IERR = 1
      GO TO 100
C
   80 DO 85 IC = IB, IE
        IF (IV.GT.NSTAT(IC))  GO TO 560
   85   CONTINUE
      GO TO 130
C
C     TEST WHETHER VARIABLE, UNKNOWN OR NOT APPLICABLE.
  100 IF (LF.NE.1)  GOT O 520
      IF (IBUF(JB).NE.KVAR)  GO TO 110
      DO 105 IC = IB, IE
        IF (ITYPC(IC).LT.0)  GO TO 560
  105   CONTINUE
      IV = -3
      GO TO 130
  110 IF (IBUF(JB).NE.KUNK)  GO TO 120
        IV = -2
        GO TO 130
  120 GOTO 520
C
C     SET FIRST IMPLICIT VALUE
  130 IF (ISET.NE.1)  GO TO 140
      DO 135 IC = IB, IE
        IMPL1(IC) = IV
  135   CONTINUE
      ISET = 2
      IF (IBUF(JBUF).EQ.KBLANK)  GO TO 10
      GO TO 50
C
C     SET SECOND IMPLICIT VALUE.
  140 DO 145 IC = IB, IE
        IMPL2(IC) = IV
  145   CONTINUE
C
C---  SKIP TO NEXT BLANK DELIMITER OR END OF RECORD.
  170 IF (IBUF(JBUF).EQ.KBLANK.OR.JBUF.EQ.JEDAT)  GO TO 10
        JBUF = JBUF + 1
        GO TO 170
 
C---  ERRORS.
  500 IERRNO = 31
      IPOINT = JBUF
      GO TO 600
  510 IERRNO = 10
      IPOINT = JBUF
      GO TO 600
  520 IERRNO = 12
      IPOINT = JB + IERR - 1
      GO TO 600
C  530 IERRNO =
C      IPOINT = JB
C      GO TO 600
  540 IERRNO = 33
      IPOINT = JB
      GO TO 600
  550 IERRNO = 39
      IPOINT = JBUF
      GO TO 600
  560 IERRNO = 22
      IPOINT = JB
      GO TO 600
 
  600 CALL MESSA (IERRNO, 3, IPOINT)
      CALL SKB
      GOTO 10
C
 1000 RETURN
      END
      SUBROUTINE RDLANG (IDAT1, IDAT2, LIDAT, JIDAT, NLANG)                 DIR4
 
C  REVISED 31-JUL-97.
C  READS NAMES OF ALTERNATE LANGUAGES USED IN COMMENTS
 
C  INPUT CONSISTS OF WORDS, EACH NAMING A LANGUAGE USED IN COMMENTS
C  E.G. ENGLISH FRENCH SPANISH
 
C  IDAT1 RECEIVES WORKING SPACE OF LENGTH LIDAT.
C  IDAT1 RECEIVES WORKING SPACE OF LENGTH LIDAT. IT IS USED TO RETURN THE
C   LIST OF LANGUAGES.
C  LIDAT RECEIVES THE LENGTH OF IDAT1, IDAT2.
C  NLANG RETURNS THE NUMBER OF LANGUAGES LISTED.
 
      COMMON /BLKXXX/ KBLANK
 
      DIMENSION IDAT1(LIDAT),IDAT2(LIDAT)
 
      NLANG = 0
 
C     READ THE TEXT
      CALL RDTXT (0, IDUM, 0, 0, IDAT1, LIDAT, JIDAT, IERR)
      IF (JIDAT.EQ.0) RETURN
 
C     PROCESS THE TEXT - COUNT THE NUMBER OF WORDS AND THE NUMBER OF NON-BLANK
C     CHARACTERS.
      LASTC = 0
      J = 0
C     FIND BEGINNING AND END OF TEXT
      JSG = 2
      IB = JSG + 2
      L = IDAT1(JSG)
      IE = JSG + L - 1
      DO I = IB, IE
        IF (IDAT1(I).NE.KBLANK) THEN
          IF (LASTC.EQ.0.OR.LASTC.EQ.KBLANK) THEN
C           STORE POINTERS TO START OF EACH WORD
            NLANG = NLANG + 1
            IDAT2(NLANG) = J + 1
          ENDIF
C         REMOVE BLANKS FROM STRING
          J = J + 1
          IDAT1(J) = IDAT1(I)
        ENDIF
        LASTC = IDAT1(I)
      ENDDO
 
C     ADD THIS EXTRA POINTER SO WE CAN CALCULATE LENGTHS OF LANGUAGE NAMES
C     BY GETTING DIFFERENCE BETWEEN ADJACENT POINTERS
      IDAT2(NLANG+1) = J + 1
 
C     OFFSET POINTERS BY NLANG+1
      DO I = 1, NLANG+1
        IDAT2(I) = IDAT2(I) + NLANG + 1
      ENDDO
 
C     COPY WORDS (I.E. LANGUAGE NAMES)
      CALL COPIA (IDAT1, IDAT2(NLANG+2), J)
      JIDAT = NLANG + 1 + J
 
      RETURN
      END
      SUBROUTINE RDULANG (IDAT1, IDAT2, LIDAT, LLANG, NLANG, LANG1,         DIR4
     * LANG2)
 
C  REVISED 12-SEP-97.
C  READS THE NAMES OF LANGUAGES TO BE USED.
  
C  IDAT1 RECEIVES WORKING SPACE OF LENGTH LIDAT.
C  IDAT2 RECEIVES WORKING SPACE OF LENGTH LIDAT.
C  LIDAT RECEIVES THE LENGTH OF IDAT1, IDAT2.
C  LLANG RECEIVES THE LIST OF DEFINED LANGUAGES.
C  NLANG RECEIVES THE NUMBER OF DEFINED LANGUAGES.
C  LANG1 RETURNS THE FIRST LANGUAGE NAMED.
C  LANG2 RETURNS THE SECOND LANGUAGE NAMED.

      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /TNAMEX/ TNAME,LTNAME
        CHARACTER*256 TNAME
 
      DIMENSION IDAT1(LIDAT),IDAT2(LIDAT),LLANG(LIDAT),LANG(2)
      CHARACTER STR*5
 
      CALL RDLANG (IDAT1, IDAT2, LIDAT, JIDAT, NFND)
 
      LANG(1) = 0
      LANG(2) = 0
      KNT = 0
 
      IF (NFND.GT.0) THEN
        NFND = MIN0(NFND, 2)
        DO 20 K = 1, NFND
          IPTR1 = IDAT2(K)
          LEN1 = IDAT2(K+1) - IPTR1
          DO 10 I = 1, NLANG
            IPTR2 = LLANG(I)
            LEN2 = LLANG(I+1) - IPTR2
            IF (LEN1.NE.LEN2)  GOTO 10
            DO J = 1, LEN1
              IF (LLANG(IPTR2+J-1).NE.IDAT2(IPTR1+J-1))  GOTO 10
            ENDDO
            KNT = KNT + 1
            LANG(KNT) = I
            GOTO 20
   10     CONTINUE
C         NO NAME MATCH FOUND.
          LDAT = MIN0(LEN1, 5)
          CALL COPIAS (IDAT2(IPTR1), STR, LDAT)
          CALL MESSC (153, IDUM, 1, 3, 0, STR, LDAT, 1)
   20   CONTINUE
      ENDIF
 
      LANG1 = LANG(1)
      LANG2 = LANG(2)
 
      RETURN
      END
      SUBROUTINE RDLNK (LINKC, NC, IDAT, LIDAT)                             DIR4
C
C* REVISED 25-JUL-89.
C* READS FEATURE LINKAGES.
C
C  LINKC RETURNS THE LINKAGES (SEE BELOW).
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  IDAT IS WORKING SPACE.
C  LIDAT RECEIVES THE LENGTH OF IDAT. THIS MUST BE IDENTICAL WITH THE
C  VALUE IN DIM XXX.
C
C  THE DATA ARE SETS OF RANGES OF THE FORM N1-M1:N2-M2:... (SEE
C    SUBR. DERNGS), AND ARE TERMINATED BY A STAR-WORD.
C    THE ELEMENTS OF LINKC ARE INITIALIZED TO 0, THEN,
C    FOR EACH SET OF RANGES, LINKC(N1) TO LINKC(M1), LINKC(N2) TO
C    LINKC(M2), ETC., ARE SET TO N1.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR OF THE STAR-WORD.
C
      DIMENSION LINKC(NC),IDAT(LIDAT)
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
      CALL SETIA (LINKC, NC, 0)
C
C-    GET NEXT WORD, AND DECODE RANGES.
   20 CALL NEXTWD (JE)
        IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 1000
        CALL DERNGS (NR, IDAT, LIDAT, NC, JE, 1)
        IF (NR.LE.0)  GO TO 300
C
C-      SET LINKAGE.
        DO 40 J = 1, NR
          IB = IDAT(2*J-1)
          IE = IDAT(2*J)
          DO 30 I = IB, IE
            IF (LINKC(I).NE.0)  GO TO 200
   30       LINKC(I) = IDAT(1)
   40     CONTINUE
        GO TO 300
C
C-      ERROR MESSAGE.
  200   CALL MESSA (39, 3, JBUF)
C
C-      PREPARE FOR NEXT WORD.
  300   JBUF = JE
        GO TO 20
C-
 1000 RETURN
      END
      SUBROUTINE RDMSK (ISET, MSK, LMSK, INCL)                              DIR4
C
C* REVISED 26-JUL-89.
C* READS A MASK.
C
C  ISET RECEIVES A FLAG INDICATING THE VALUES TO BE SET IN THE MASK.
C    POSITIVE - 1 SET. ZERO - 0 SET. NEGATIVE - FIRST VALUE OF EACH
C    RANGE SET.
C  MSK RETURNS THE MASK (SEE BELOW).
C  LMSK RECEIVES THE LENGTH OF MSK.
C  INCL RETURNS THE NUMBER OF ELEMENTS OF MSK WITH NON-ZERO VALUES.
C
C  THE INPUT TAKES THE FORM N1-M1 N2-M2 ... AND IS TERMINATED BY A
C    STAR-WORD. THE -M1, -M2, ... ARE OPTIONAL.
C  MSK(N1) TO MSK(M1), ETC., ARE SET TO THE VALUE SPECIFIED BY ISET.
C    THE REST ARE SET TO 0 IF ISET IS NON-ZERO, OR 1 IF ISET IS ZERO.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR OF THE STAR-WORD.
C
      DIMENSION MSK(LMSK)
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
      JSET = MIN0(1,IABS(ISET))
      JPRE = 1 - JSET
      CALL SETIA (MSK, LMSK, JPRE)
C
C-    GET NEXT WORD AND CHECK FOR STAR.
   20 CALL NEXTWD (JE)
        IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 1000
C
C-      DECODE RANGE.
        CALL DERNG (IB, IE, LMSK, JBUF, JE)
        IF (IB.LE.0)  GO TO 300
C
C-      SET VALUES.
        IF (ISET.LT.0)  JSET = IB
        DO 150 I = IB, IE
          IF (MSK(I).NE.JPRE)  GO TO 200
  150     MSK(I) = JSET
        GO TO 300
C
C-      ERROR MESSAGE.
  200   CALL MESSA (39, 3, JBUF)
 
C-      PREPARE FOR NEXT WORD.
  300   JBUF = JE
        GO TO 20
C
C-    COUNT NUMBER OF NON-ZERO VALUES.
 1000 INCL = NONZER(MSK,LMSK)
      RETURN
      END
      SUBROUTINE RDNOTE (ICTXT, ICGRP, IMAX, IDAT1, IDAT2, IDAT3,           DIR4
     * LLANG, LIDAT, IREMC, IFLANG)
 
C* REVISED 7-MAR-00.
C* READS A LIST OF NUMBERED TEXT STRINGS.
 
C  ICTXT RETURNS RECORD POINTERS TO THE CHARACTER STRINGS.
C  ICGRP RETURNS THE GROUP TO WHICH EACH CHARACTER STRING BELONGS.
C  IMAX RECEIVES THE LARGEST PERMITTED STRING NUMBER.
C  IDAT1 RETURNS THE STRINGS (SEE BELOW).
C  IDAT2 RECEIVES WORKING SPACE.
C  IDAT3 RECEIVES WORKING SPACE.
C  LLANG RECEIVES LANGUAGE INFORMATION AS PER "ALTERNATE LANGUAGES".
C  LIDAT RECEIVES THE LENGTH OF IDAT1, IDAT2. ITS VALUE MUST BE IDENTICAL WITH
C    THE VALUE IN DIM XXX.
C  IREMC RECEIVES WHETHER TO REMOVE COMMENTS.
C  IFLANG RECEIVES WHETHER TEXT SHOULD BE FILTERED FOR LANGUAGE.
 
C  THE INPUT TAKES THE FORM  
C       #C1(-C2:C3-C4:...). STRING1
C       #C1(-C2:C3-C4:...). STRING2  ETC.,
C   AND IS TERMINATED BY A STAR-WORD.
C  THE STRINGS (SEE SUBR. SENTNC) ARE STORED FROM IDAT(IMAX+1) ON.
C    IDAT(N) POINTS TO THE STARTING LOCATION OF SENTENCE N.
C    A NEGATIVE VALUE INDICATES AN INVALID SENTENCE.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR OF THE STAR-WORD.
 
      DIMENSION ICTXT(IMAX),ICGRP(IMAX),IDAT1(LIDAT),IDAT2(LIDAT),
     * IDAT3(LIDAT),LLANG(LIDAT)
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
      COMMON /SCRNMX/ SCRNAM(7)
        CHARACTER*8 SCRNAM
      COMMON /SCRXXX/ LUNTS1,LUNTS2,LUNTS3,LUNTS4,LUNTS5,LUNTS6,LUNTS7
      COMMON /SCR6XX/ LRECS6,IRECS6
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
 
      CHARACTER FSPEC*60
 
      CALL SETIA (ICTXT, IMAX, 0)
 
      IF (LUNS6.LT.0) THEN
C       OPEN SCRATCH FILE 6 TO STORE INTERMEDIATE DATA.
        IRECS6 = 0
        LRECS6 = 32
        CALL GETAU (LUN)
        FSPEC = SCRNAM(6)
        CALL SETLUN (FSPEC, LUN, LUNTS6)
        CALL UOPEN (LUN, LUNUSE(LUN), FSPEC, LRECS6, IERR)
        IF (IERR.NE.0)  CALL MESSB (20, 6, 1, -1, 0)
      ENDIF

C-    FIND AND DECODE NUMBER.
  100 CALL NEXTWD (JE)
        IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 1000
        IF (IBUF(JE-1).NE.KDSTOP)  GO TO 200
        IF (IBUF(JBUF).EQ.KDNUM)  JBUF = JBUF + 1
        IF (JE-JBUF.LE.1)  GO TO 210
        CALL DERNGS (NR, IDAT3, LIDAT, IMAX, JE-1, 1)
        DO J = 1, NR
          IB = IDAT3(2*J-1)
          IE = IDAT3(2*J)
          DO K = IB, IE
            IF (ICTXT(K).NE.0)  GO TO 240
            ICGRP(K) = IDAT3(1)
          ENDDO
        ENDDO
 
C-      READ TEXT ASSOCIATED WITH NUMBER.
        JBUF = JE
        JIDAT = 0
        CALL SENTNC (IDAT2, LIDAT, -1, JIDAT, IERR)
        IF (IERR.LT.0)  GOTO 500
C       REMOVE COMMENTS, IF APPROPRIATE.
        IF (IREMC.NE.0)  THEN
          CALL RMBCMT (IDAT1, IDAT2, JIDAT, KIDAT)
        ELSE
          CALL COPIA(IDAT2, IDAT1, JIDAT)
          KIDAT = JIDAT
        ENDIF
        IF (IFLANG.NE.0)  THEN
          CALL LANGSEN (IDAT1, KIDAT, LLANG, LIDAT, 2)
          KIDAT = IDAT1(1)
        ENDIF
C       OUTPUT ITEM TO SCRATCH FILE.
        IF (KIDAT.GT.3)  THEN
          DO J = 1, NR
            IB = IDAT3(2*J-1)
            IE = IDAT3(2*J)
            DO K = IB, IE
              ICTXT(K) = IRECS6 + 1
            ENDDO
          ENDDO
          CALL WRDAI (KIDAT, 1, LUNS6, LRECS6, IRECS6)
          CALL WRDAI (IDAT1, KIDAT, LUNS6, LRECS6, IRECS6)
        ENDIF
        GO TO 300
 
C-      ERROR MESSAGES.
  200   IERRNO = 72
        IPOINT = JE - 1
        JBUF = JBUF + 1
        GO TO 290
  210   IERRNO = 73
        IPOINT = JBUF
        GO TO 290
  220   IERRNO = 74
        IPOINT = JBUF + IERR - 1
        GO TO 290
  230   IERRNO = 75
        IPOINT = JBUF
        GO TO 290
  240   IERRNO = 64
        CALL MESSB (IERRNO, K, 1, 3, JBUF)
        GOTO 295
 
  290   CALL MESSA (IERRNO, 3, IPOINT)
  295   CALL SKDELW (1)
C-
  300   GO TO 100
C-
C  500   CALL MESSA (76, 1, 0)
 
  500   DO J = 1, NR
          IB = IDAT3(2*J-1)
          IE = IDAT3(2*J)
          DO K = IB, IE
            IDAT1(K) = -1
          ENDDO
        ENDDO
 
 1000 RETURN
      END
      SUBROUTINE RDREAL (R, XMIN, XMAX, DEF)                                DIR4
C
C* REVISED 26-JUL-89.
C* READS A SINGLE REAL VALUE.
C
C  R RETURNS THE VALUE.
C  XMIN RECEIVES THE MINIMUM ALLOWED VALUE.
C  XMAX RECEIVES THE MAXIMUM ALLOWED VALUE. IF XMAX.LE.XMIN,
C    THERE IS NO MAXIMUM VALUE.
C  DEF RECEIVES THE DEFAULT VALUE. IF DEF.LT.XMIN, THERE IS
C    NO DEFAULT.
C
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AFTER THE NUMBER, OR, IF THE NUMBER
C    WAS MISSING, AT THE START OF THE NEXT STAR-WORD.
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
C     LOCATE AND DECODE WORD.
      CALL NEXTWD (JE)
      IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 4
      CALL RDKOD (R, IBUF(JBUF), JE-JBUF, IERR)
      IF (IERR.GT.0)  GO TO 20
      IF (R.LT.XMIN .OR. (XMAX.GT.XMIN.AND.R.GT.XMAX))  GO TO 30
      GO TO 100
C
C     USE DEFAULT.
    4 IF (DEF.LT.XMIN)  GO TO 10
      R = DEF
      JE = JBUF
      GO TO 100
 
C     ERROR MESSAGES.
   10 IERRNO = 10
      IPOINT = JBUF - 1
      JE = JBUF
      GO TO 40
   20 IERRNO = 71
      IPOINT = JBUF + IERR - 1
      GO TO 40
   30 IERRNO = 67
      IPOINT = JBUF
 
   40 CALL MESSA (IERRNO, 3, IPOINT)
      GOTO 100
 
  100 JBUF = JE
      RETURN
      END
      SUBROUTINE RDSENL (IDAT, LIDAT, IMAX, IEMPTY, ITYPMRK, JIDAT)         DIR4
 
C* REVISED 25-OCT-00.
C* READS A LIST OF NUMBERED TEXT STRINGS.
 
C  IDAT RETURNS THE STRINGS (SEE BELOW).
C  LIDAT RECEIVES THE LENGTH OF IDAT. ITS VALUE MUST BE IDENTICAL WITH
C    THE VALUE IN DIM XXX.
C  IMAX RECEIVES THE LARGEST PERMITTED STRING NUMBER.
C  IEMPTY RECEIVES WHETHER TO ALLOW EMPTY STRINGS. (USED FOR VOCABULARY)
C  ITYPMRK RECEIVES WHETHER THIS IS PROCESSING THE "TYPESETTING MARKS"
C    DIRECTIVE, IN BINARY OUTPUT MODE.
C   IF TRUE, THE BLANK NORMALLY APPENDED TO INPUT RECORDS IS IGNORED TO AVOID
C   UNWANTED BLANKS WITHIN THE TYPRSETTING STRINGS.
C  JIDAT RETURNS THE POSITION OF THE LAST ELEMENT OF IDAT USED.
 
C  THE INPUT TAKES THE FORM  N1. STRING1 N2. STRING2  ETC., AND IS
C   TERMINATED BY A STAR-WORD.
C  THE STRINGS (SEE SUBR. SENTNC) ARE STORED FROM IDAT(IMAX+1) ON.
C    IDAT(N) POINTS TO THE STARTING LOCATION OF SENTENCE N.
C    A NEGATIVE VALUE INDICATES AN INVALID SENTENCE.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR OF THE STAR-WORD.
 
      DIMENSION IDAT(LIDAT)
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /EOFXXX/ IEOF
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
      PARAMETER (MAXWSK=1500)
 
      CALL SETIA (IDAT, IMAX, 0)
      JIDAT = IMAX
 
C     CHECK FOR PRESENCE OF OPTIONAL DELIMITER.
      CALL NEXTWD (JE)
        IF (IBUF(JBUF).EQ.KDSTAR)  GOTO 600
        IF (IBUF(JBUF).EQ.KDNUM)  THEN
          IEND = 1
        ELSEIF (JE-JBUF.GT.1)  THEN
          IEND = 1
          GOTO 250
        ELSEIF (IBUF(JBUF).EQ.KDLBRA.OR.IBUF(JBUF).EQ.KDRBRA) THEN
          IEND = 1
          GOTO 260
        ELSE
          IDELIM = IBUF(JBUF)
          IEND = 2
          JBUF = JE
        ENDIF
 
C-    FIND AND DECODE NUMBER.
  100 CALL NEXTWD (JE)
  101   IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 600
        IF (IBUF(JE-1).NE.KDSTOP)  GO TO 200
        IF (IBUF(JBUF).EQ.KDNUM)  JBUF = JBUF + 1
        IF (JE-JBUF.LE.1)  GO TO 210
        CALL IDKOD (IN, IBUF(JBUF), JE-JBUF-1, IERR)
        IF (IERR.NE.0)  GO TO 220
        IF (IN.LT.1)  GOTO 230
        IF (IN.GT.IMAX)  GO TO 231
        IF (IDAT(IN).NE.0)  GO TO 240
 
C       CHECK FOR PRESENCE OF COMMENT.
        JBUF = JE
        CALL NEXTWD (JE)
        IF (IBUF(JBUF).NE.KDLBRA)  GOTO 150
        
C       LOOK FOR CLOSING BRACKET.
        NSKIP = 0
  120   IF (IBUF(JBUF).EQ.KDSTAR.OR.IBUF(JBUF).EQ.KDNUM) GOTO 270
        IF (IBUF(JE-1).EQ.KDRBRA)  THEN
          JBUF = JE
          GOTO 150
        ELSE
          JBUF = JE
          CALL NEXTWD (JE)
          NSKIP = NSKIP + 1
          IF (IEOF.NE.0)  GOTO 700
          IF (NSKIP.GT.MAXWSK)  GOTO 710
          GOTO 120
        ENDIF
 
C-      READ TEXT ASSOCIATED WITH NUMBER.
  150   CALL RDTXT (IEND, IDELIM, ITYPMRK, 0, IDAT(JIDAT+1),
     *   LIDAT-JIDAT, LEN, IERR)
        IF (LEN.GT.0)  THEN
          IDAT(IN) = JIDAT + 1
          JIDAT = JIDAT + LEN
        ELSE
          IF (IEMPTY.NE.0) THEN
C           Set flag to mark empty string
            IDAT(IN) = -1
          ELSE
            IDAT(IN) = 0
          ENDIF
        ENDIF
        IF (IERR.NE.0)  GOTO 500
        GO TO 100
 
C-      ERROR MESSAGES.
  200   IERRNO = 72
        IPOINT = JE - 1
        JBUF = JBUF + 1
        GO TO 300
  210   IERRNO = 73
        IPOINT = JBUF
        GO TO 300
  220   IERRNO = 74
        IPOINT = JBUF + IERR - 1
        GO TO 300
  230   IERRNO = 61
        IPOINT = JBUF
        GO TO 300
  231   IERRNO = 62
        IPOINT = JBUF
        GO TO 300
  240   IERRNO = 147
        CALL MESSB(IERRNO, IN, 1, 3, JBUF)
        GOTO 305
  250   IERRNO = 128
        IPOINT = JBUF
        GOTO 300
  260   IERRNO = 31
        IPOINT = JBUF
        GOTO 300
  270   IERRNO = 91
        IPOINT = JBUF - 1
        GOTO 300
 
  300   CALL MESSA (IERRNO, 3, IPOINT)
  305   CALL SKDELW (1)
        GOTO 100
  
  500   CALL MESSB (35, LIDAT, 1, -1, 0)
        IDAT(IN) = -1
 
  600 RETURN
 
  700 CALL BMESS
      CALL MESSA (91, -1, JBUF-1)
 
  710 CALL BMESS
      CALL MESSB (129, MAXWSK, 1, -3, JBUF)
 
      END
      SUBROUTINE RDTTXT (ITMTXT, ITMREC, IMAX, IDAT1, IDAT2, IDAT3,         DIRU
     * LIDAT, NTEXT, MTEXT, IRECS7)
 
C* REVISED 05-JUL-00.
C* READS A LIST OF TAXON NAMES OR TAXON NUMBERS AND ASSOCIATED TEXT STRINGS.
C  THE INFORMATION IS STORED ON SCRATCH FILES FOR LATER USE.
 
C  ITMTXT RETURNS RECORD POINTERS TO THE NAMES AND TEXT
C  ITMREC RETURNS RECORD POINTERS TO IMAGE TEXT ASSOCIATED WITH A TAXON NUMBER.
C  IMAX RECEIVES THE MAXIMUM NUMBER OF LIST ITEMS
C  IDAT1 RECEIVES WORKING SPACE.
C  IDAT2 RECEIVES WORKING SPACE.
C  IDAT3 RECEIVES WORKING SPACE.
C  LIDAT RECEIVES THE LENGTH OF IDAT1, IDAT2, IDAT3. ITS VALUE MUST BE IDENTICAL
C    WITH THE VALUE IN DIM XXX.
C  NTEXT RETURNS THE TOTAL NUMBER OF TAXON TEXT RECORDS.
C  MTEXT RETURNS THE NUMBER OF TAXON TEXT RECORDS SPECIFIED BY NAME.
C  RECEIVES AND RETURNS THE LAST RECORD USED ON SCRATCH UNIT 7.
 
C  THE INPUT TAKES THE FORM  
C       #NAME1/ STRING1
C       #NAME2/ STRING2  ETC.,
C   AND IS TERMINATED BY A STAR-WORD.
C  THE NAMES AND STRINGS (SEE SUBR. SENTNC) ARE STORED FROM IDAT(IMAX+1) ON.
C    IDAT(N) POINTS TO THE STARTING LOCATION OF SENTENCE N.
C    A NEGATIVE VALUE INDICATES AN INVALID SENTENCE.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR OF THE STAR-WORD.
 
      DIMENSION ITMTXT(IMAX),ITMREC(IMAX),IDAT1(LIDAT),IDAT2(LIDAT),
     * IDAT3(LIDAT)
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
      COMMON /SCRNMX/ SCRNAM(7)
        CHARACTER*8 SCRNAM
      COMMON /SCRXXX/ LUNTS1,LUNTS2,LUNTS3,LUNTS4,LUNTS5,LUNTS6,LUNTS7
      COMMON /SCR6XX/ LRECS6,IRECS6
 
      CHARACTER FSPEC*60
 
      CALL SETIA (ITMTXT, IMAX, 0)
      NTEXT = 0
      MTEXT = 0
 
      IF (LUNS6.LT.0) THEN
C       OPEN SCRATCH FILE 6 TO STORE INTERMEDIATE DATA.
        IRECS6 = 0
        LRECS6 = 32
        CALL GETAU (LUN)
        FSPEC = SCRNAM(6)
        CALL SETLUN (FSPEC, LUN, LUNTS6)
        CALL UOPEN (LUN, LUNUSE(LUN), FSPEC, LRECS6, IERR)
        IF (IERR.NE.0)  CALL MESSB (20, 6, 1, -1, 0)
      ENDIF
 
      IF (LUNS7.LT.0) THEN
C       OPEN SCRATCH FILE 7 TO STORE TAXON NAMES.
        IRECS7 = 0
        LRECS7 = 32
        CALL GETAU (LUNNAM)
        FSPEC = SCRNAM(7)
        CALL SETLUN (FSPEC, LUNNAM, LUNTS7)
        CALL UOPEN (LUNNAM, LUNUSE(LUNNAM), FSPEC, LRECS7, IERR)
        IF (IERR.NE.0)  CALL MESSB (20, 7, 1, -1, 0)
      ELSE
        LRECS7 = 32
      ENDIF

C     CHECK FOR PRESENCE OF OPTIONAL DELIMITER.
      CALL NEXTWD (JE)
        IF (IBUF(JBUF).EQ.KDSTAR)  GOTO 1000
        IF (IBUF(JBUF).EQ.KDNUM)  THEN
          IEND = 1
        ELSEIF (JE-JBUF.GT.1)  THEN
          IEND = 1
          GOTO 260
        ELSEIF (IBUF(JBUF).EQ.KDLBRA.OR.IBUF(JBUF).EQ.KDRBRA) THEN
          IEND = 1
          GOTO 270
        ELSE
          IDELIM = IBUF(JBUF)
          IEND = 2
          JBUF = JE
        ENDIF
 
C     Count number of items.
      ITCNT = 0
 
C-    READ NAME OR TAXON NUMBER.
  100 CALL NEXTWD (JE)
        IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 1000
        IF (IBUF(JBUF).NE.KDNUM)  GOTO 200
  110   JBUF = JBUF + 1
        ISTEXT = 0
        CALL READT (JE, IT1, IT2, IMAX, IDAT1, LIDAT, JIDAT, INAME)
        IF (IT1.GT.0)  THEN
          JBUF = JE
          GOTO 130
        ELSE IF (INAME.EQ.1)  THEN
C         A TAXON NAME.
          ISTEXT = 1
        ELSE IF (INAME.EQ.-1)  THEN
          IERRNO = 98
          GOTO 290
        ELSE
          GOTO 295
        ENDIF

  130   ITCNT = ITCNT + 1
        IF (ITCNT.GT.IMAX) THEN
          CALL MESSA (46, 3, JBUF)
          CALL SKDELW (0)
          GOTO 1000
        ENDIF
 
C-      READ TEXT ASSOCIATED WITH NAME.

        KIDAT = 0
        CALL RDTXT (IEND, IDELIM, 0, 1, IDAT2, LIDAT, KIDAT, IERR)
        IF (IERR.NE.0)  GOTO 300
C       OUTPUT NAME AND ASSOCIATED TEXT TO SCRATCH FILE.
        IF (KIDAT.GT.3)  THEN
          NTEXT = NTEXT + 1
          IF (ISTEXT.NE.0)  THEN
            MTEXT = MTEXT + 1
            ITMTXT(MTEXT) = IRECS7 + 1
C           NAME.
C           Remove typesetting marks before saving.
            CALL REMTPS (IDAT1, JIDAT, IDAT3, LIDAT, 1)
            CALL WRDAI (JIDAT, 1, LUNS7, LRECS7, IRECS7)
            CALL WRDAI (IDAT1, JIDAT, LUNS7, LRECS7, IRECS7)
C           RECORD LOCATION OF ASSOCIATED INFORMATION.
            CALL WRDAI (IRECS6+1, 1, LUNS7, LRECS7, IRECS7)
          ELSE
C           RANGE.
            DO IT = IT1, IT2
              IF (IT.GT.0.AND.IT.LE.IMAX)  ITMREC(IT) = IRECS6 + 1
            ENDDO
          ENDIF
C         TEXT.
          CALL WRDAI (KIDAT, 1, LUNS6, LRECS6, IRECS6)
          CALL WRDAI (IDAT2, KIDAT, LUNS6, LRECS6, IRECS6)
        ENDIF
        GO TO 300
 
C-      ERROR MESSAGES.
  200   IERRNO = 38
        IPOINT = JE - 1
        JBUF = JBUF + 1
        GO TO 290
  210   IERRNO = 73
        IPOINT = JBUF
        GO TO 290
  220   IERRNO = 74
        IPOINT = JBUF + IERR - 1
        GO TO 290
  230   IERRNO = 75
        IPOINT = JBUF
        GO TO 290
  240   IERRNO = 64
        CALL MESSB (IERRNO, K, 1, 3, JBUF)
        GOTO 295
  250   CALL MESSA (98, -3, JBUF)
        GOTO 295
  260   IERRNO = 128
        IPOINT = JBUF
        GO TO 290
  270   IERRNO = 31
        IPOINT = JBUF
        GO TO 290
 
  290   CALL MESSA (IERRNO, 3, IPOINT)
  295   CALL SKDELW (1)
C-
  300   GO TO 100
 
 1000 RETURN
      END
      SUBROUTINE RDVCON (IDAT, LIDAT, ITYPC, NC, JIDAT)                     DIR4
C
C* REVISED 25-JUL-89.
C* READS CONSTRAINTS ON VALUES OF NUMERIC CHARACTERS.
C
C  IDAT RETURNS THE CONSTRAINTS (SEE BELOW).
C  LIDAT RECEIVES THE LENGTH OF IDAT. ITS VALUE MUST BE IDENTICAL WITH
C    THE VALUE IN DIM XXX.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  JIDAT RETURNS THE POSITION OF THE LAST ELEMENT OF IDAT USED.
C
C  THE INPUT TAKES THE FORM IC1,VL1:VU1:VI1 ... IC,VL:VU:VI ... AND IS
C    TERMINATED BY A STAR-WORD.
C    VL AND VU ARE THE LOWER AND UPPER LIMITS FOR VALUES OF CHARACTER
C    IC, AND VI, IF NON-ZERO, IS THE ALLOWED INCREMENT, I.E., THE
C    PERMITTED VALUES ARE VL, VL+VI, VL+2*VI, ... VU.
C    THE THREE CONSTRAINING VALUES ARE STORED AS REALS IN IDAT,
C    STARTING AT THE LOCATION SPECIFIED IN IDAT(IC).
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR.
C
C
      DIMENSION IDAT(LIDAT),ITYPC(NC),V(3)
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
 
C-    INITIALIZE.
      DO 20 I = 1, NC
   20   IDAT(I) = 0
      JIDAT = NC
      IC = 0
C
C-    READ AND DECODE NEXT WORD.
C     GET NEXT WORD.
   30 CALL NEXTWD (JE)
        IF (IBUF(JBUF).EQ.KDSTAR)  GO TO 500
C       DECODE AND CHECK CHARACTER NUMBER.
        CALL CNUM (IDAT, IB, IE, IC, NC, JE)
        IF (IC.LE.0)  GO TO 400
        IF (IB.NE.IE)  GOTO 250
        IF (ITYPC(IC).NE.3 .AND. ITYPC(IC).NE.4)  GO TO 200
        IF (JIDAT+3.GT.LIDAT)  CALL MESSB (35, LIDAT, 1, -1, 0)
        IDAT(IC) = JIDAT + 1
        JB = JBUF
C       DECODE AND CHECK CONSTRAINING VALUES.
        DO 150 IN = 1, 3
          CALL FINDS (KDCOLN, IBUF, JB, JE, JF)
          IF (JB.GE.JF .AND. IN.LE.2)  GO TO 210
          IF (JB.GE.JF)  GO TO 80
          IF (ITYPC(IC).EQ.4)  GO TO 70
          CALL IDKOD (I, IBUF(JB), JF-JB, IERR)
          V(IN) = I
          GO TO 72
   70     CALL RDKOD (V(IN), IBUF(JB), JF-JB, IERR)
   72     IF (IERR.NE.0)  GO TO 220
          GO TO 90
   80     V(IN) = 0.
   90     IF (IN.EQ.1)  GO TO 140
          IF (IN.EQ.3)  GO TO 100
          IF (V(2).LE.V(1))  GO TO 230
          GO TO 140
  100     IF (V(3).LT.0.)  GO TO 240
          IF (V(3).EQ.0.)  GO TO 140
          X = (V(2)-V(1))/V(3)
          IF (ABS(X-AINT(X)).GT.0.001)  GO TO 230
C         STORE VALUE
  140     CALL RELOUT (V(IN), IDAT(JIDAT+1))
          JIDAT = JIDAT + 1
          JB = JF + 1
  150     CONTINUE
        GO TO 400
 
C-      ERROR MESSAGES.
  200   IERRNO = 42
        IPOINT = JBUF - 1
        GO TO 300
  210   IERRNO = 10
        IPOINT = JB
        GO TO 300
  220   IERRNO = 12
        IPOINT = JB + IERR - 1
        GO TO 300
  230   IERRNO = 43
        IPOINT = JB
        GO TO 300
  240   IERRNO = 22
        IPOINT = JB
        GOTO 300
  250   CALL MESSA (41, 3, JB)
        GOTO 400
  300   CALL MESSA (IERRNO, 3, IPOINT)
        IDAT(IC) = -1
C
  400   JBUF = JE
        GO TO 30
C
  500 RETURN
      END
      SUBROUTINE READT (JE, IT1, IT2, NI, IDAT, LIDAT, JIDAT, INAME)        DIR4
 
C  REVISED 03-DEC-98.
C  READS A TAXON NAME OR RANGE.
 
C  JE POINTS TO THE POSITION IN IBUF IMMEDIATELY AFTER THE CURRENT WORD.
C  IT1 RETURN THE START OF THE TAXON RANGE, IF A NUMBER IS FOUND. 0 OTHERWISE.
C  IT2 RETURN THE END OF THE TAXON RANGE.
C  NI RECEIVES THE MAXIMUM ITEM NUMBER.
C  IDAT RETURNS THE TAXON NAME, IF A NAME IS FOUND.
C  LIDAT RECEIVES THE LENGTH OF LIDAT.
C  JIDAT RETURNS THE LENGTH OF THE TAXON NAME.
C  INAME RETURNS A STATUS FLAG FOR THE NAME. 1=OK
 
C  INPUT IS OF THE FORM #name/ OR #t.
C  THIS CODE ASSUMES JBUF IS SETUP CORRECTLY I.E. JBUF POINTS TO
C  THE CHARACTER AFTER THE #.
 
      DIMENSION IDAT(LIDAT)
 
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
 
      IT1 = 0
      IF (IBUF(JE-1).NE.KDSTOP)  GOTO 50
      CALL DERNG(IT1, IT2, NI, JBUF, JE-1)
      IF (IT1.NE.0)  THEN
C        JBUF = JE
        GOTO 100
      ENDIF

   50 JIDAT = 0
      CALL SENTNC(IDAT, LIDAT, 2, JIDAT, INAME)
 
  100 RETURN
      END
      SUBROUTINE RMBCMT (JSEN, ISEN, LSEN, JOUT)                                  DIR4
 
C  REVISED 4-MAR-93.
C  REMOVES BLANKS AND COMMENTS FROM A SENTENCE.
 
C  JSEN RETURNS THE EDITED SENTENCE.
C  ISEN RECEIVES THE SENTENCE.
C  LSEN RECEIVES THE LENGTH OF ISEN, JSEN.
C  JOUT RETURNS THE LENGTH OF THE EDITIED SENTENCE.
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
 
      DIMENSION JSEN(LSEN),ISEN(LSEN)
 
      LASTC = 0
 
      JSG = 2
      IBOUT = 2
      IOUT = 1
 
      DO WHILE (JSG.LE.ISEN(1))
C       OMIT COMMENTS.
        IF (ISEN(JSG+1).EQ.0)  GOTO 30
        IB = JSG + 2
        L = ISEN(JSG)
        LENSUB = 2
        JSEN(IBOUT+1) = ISEN(JSG+1)
        IOUT = IBOUT + 1
        IF (L.GT.0)  THEN
          IE = JSG + L - 1
          DO 20 IN = IB, IE
            IF (ISEN(IN).EQ.KBLANK.AND.LASTC.EQ.KBLANK)  GOTO 20
            IOUT = IOUT + 1
            LENSUB = LENSUB + 1
            JSEN(IOUT) = ISEN(IN)
            LASTC = JSEN(IOUT)
   20     CONTINUE
        ENDIF
        JSEN(IBOUT) = LENSUB
        IBOUT = IOUT + 1
   30   JSG = JSG + ISEN(JSG)
      END DO
 
      JSEN(1) = IOUT
      JOUT = IOUT
      RETURN
      END
      SUBROUTINE SBOUND (IDAT, LIDAT, ITYPC, NSTAT, KSTAT, JTYPC,           DIR4
     * NC, MS, JIDAT)
C
C* REVISED 28-MAY-93.
C* READS SPECIFICATIONS OF NEW STATES.
C
C  IDAT RETURNS THE NEW STATES, STORED (FORMALLY) AS ATTRIBUTES
C    (SEE SUBR. RDITEM).
C  LIDAT RECEIVES THE LENGTH OF IDAT. ITS VALUE MUST BE IDENTICAL WITH
C    THE VALUE IN DIM XXX.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  KSTAT RETURNS THE NEW NUMBERS OF STATES.
C  JTYPC IS WORKING SPACE.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C
C  THE INPUT FOR EACH CHARACTER TO BE SPECIFIED TAKES THE FORM
C    IC,V11-V12-..V1N/V21-V22-..V2M/...
C    AND IS TERMINATED BY A STAR-WORD.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR.
C
      DIMENSION IDAT(LIDAT),ITYPC(NC),NSTAT(NC),KSTAT(NC),JTYPC(NC)
C
      COMMON /BLKXXX/ KBLANK
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /ITSXXX/ ITSS
C
      DO 20 IC = 1, NC
   20   JTYPC(IC) = IABS(ITYPC(IC))
C
      IF (NC.GT.LIDAT)  CALL MESSB (35, LIDAT, 1, -1, 0)
      CALL SETIA (IDAT, NC, 0)
      JIDAT = NC
C
  100 CALL RDATT (JTYPC, NSTAT, NC, IDAT, LIDAT, JIDAT, 1, IC1, IC2)
        IF (IBUF(JBUF).NE.KBLANK)  GO TO 1000
        IF (IDAT(IC1).LE.0)  GO TO 200
        JG = IDAT(IC1)
        JSG = JG + 1
        KS = 0
  120   IF (JSG.GT.JIDAT)  GO TO 130
          IF (IDAT(JSG+1).LE.0.OR.IDAT(JSG+1).GT.ITSS)  GO TO 150
          KS = KS + 1
          JSG = JSG + IDAT(JSG)
          GO TO 120
  130   IF (KS.GT.MS)  GO TO 160
        IF (KS.LT.2)  GO TO 150
        DO 140 IC = IC1, IC2
          KSTAT(IC) = KS
  140     CONTINUE
        GO TO 200
 
  150   IERRNO = 41
        IPOINT = JBUF - 1
        CALL MESSA (IERRNO, 3, IPOINT)
        GOTO 180
  160   IERRNO = 138
        IPOINT = JBUF - 1
        CALL MESSB (IERRNO, MS, 1, 3, IPOINT)
  180   DO 190 IC = IC1, IC2
          IDAT(IC) = -1
          KSTAT(IC) = 0
  190     CONTINUE
C
  200   GO TO 100
C
 1000 RETURN
      END
