      FUNCTION IEMPTYCMT (IDAT, L)                                          TNAT
 
C  REVISED 13-SEP-95.
C  CHECKS IF A COMMENT IS BLANK.
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
 
      DIMENSION IDAT(L)
 
      IEMPTYCMT = 1
 
      DO I = 1, L
        IF (IDAT(I).NE.KBLANK .AND.
     *      IDAT(I).NE.KDLBRA .AND.
     *      IDAT(I).NE.KDRBRA)  GOTO 10
      ENDDO
      GOTO 100
 
   10 IEMPTYCMT = 0
 
  100 RETURN
      END
      FUNCTION ICHKFEAT (IFEAT, LFEAT, IFETO, LNKC, KLINKC,                 TNAT
     * LSTCHO, IOFFSET)
C     * LSTCHO, IDES, LDES)
 
C  REVISED 18-JUL-00.
C  RETURNS WHETHER THE TEXT OF A FEATURE IS EMPTY, ASSUMING COMMENTS ARE NOT
C  OUTPUT. THIS CODE TAKES INTO ACCOUNT THE EFFECTS OF CHARACTER LINKING,
C  WHICH CAUSES IDENTICAL FEATURE TEXT IN LINKED CHARACTERS TO BE OMITTED.
 
C  IFEAT RECEIVES THE FEATURE.
C  LFEAT RECEIVES THE LENGTH OF IFEAT.
 
      DIMENSION IFEAT(LFEAT)
C      ,IDES(LDES)
 
      ICHKFEAT = 0
 
      IF (IFETO.EQ.0 .OR.
     *    (LNKC.GT.0.AND.IFETO.EQ.KLINKC.AND.LSTCHO.LT.IFETO))  THEN
        ICHKFEAT = ICHKSTATE (IFEAT, LFEAT)
      ELSE
C       COMPARE FIRST AND CURRENT CHARACTER DESCRIPTIONS IN A LINKED SET.
        ICHKFEAT = 1
C        CALL CMPCHR (IDES, LDES, IFEAT, LFEAT, IOFFST)
C       IOFFSET is calculated for each character before the item description
C       is output.
        IF (IOFFSET.LT.0)  ICHKFEAT = 0
      ENDIF
 
      RETURN
      END
      FUNCTION ICHKSTATE (ISTATE, LEN)                                      TNAT
 
C  REVISED 26-APR-96.
C  RETURNS WHETHER THE TEXT OF A STATE IS EMPTY, ASSUMING COMMENTS ARE NOT
C  OUTPUT.
 
C  ISTATE RECEIVES THE STATE INFORMATION
C  LEN RECEIVES THE LENGTH OF ISTATE.
 
      DIMENSION ISTATE(LEN)
 
      ICHKSTATE = 0
 
      JSG = 2
 
   10 IF (JSG.GT.ISTATE(1)) GOTO 100
        IF (ISTATE(JSG+1).EQ.0)  GOTO 20
        L = ISTATE(JSG) - 2
        IF (L.GT.0)  THEN
          ICHKSTATE = 1
          GOTO 100
        ENDIF
   20   JSG = JSG + ISTATE(JSG)
        GOTO 10
 
  100 RETURN
      END
C      FUNCTION ICMPTYP (NTYP, ITYPMK, LIDAT, NTYPMK, IHD, LHD)                                   TNAT
C 
CC  REVISED 7-SEP-99.
CC  COMPARES A TYPESETTING MARK AND AN ITEM SUBHEADING. 
C 
C      COMMON /BLKXXX/ KBLANK
C 
C      DIMENSION ITYPMK(LIDAT),IHD(LHD)
C 
CC     UNEQUAL IS THE DEFAULT.
C      ICMPTYP = 1
C 
C      IF (NTYP.LE.0.OR.NTYP.GT.NTYPMK) RETURN
C 
C      IB1 = ITYPMK(NTYP)
C      LEN1 = ITYPMK(IB1) - 3
C      IF (LEN1.EQ.0) RETURN
CC     Remove trailing spaces.
C      IB1 = IB1 + 3
C   10 IF (ITYPMK(IB1+LEN1-1).EQ.KBLANK) THEN
C        LEN1 = LEN1 - 1
C        IF (LEN1.EQ.0) RETURN
C        GOTO 10
C      ENDIF
C 
C      J = 2
C      IB2 = J + 2
C      LEN2 = IHD(J) - 2
C      IF (LEN2.LT.LEN1) RETURN
C 
C      DO I = 1, LEN1
C        IF (ITYPMK(IB1+I-1).NE.IHD(IB2+I-1))  GOTO 100
C      ENDDO
CC     EQUAL FOR LENGTH OF ITYPMK
C      ICMPTYP = 0
C 
C  100 RETURN
C      END
      SUBROUTINE CMPCHR (ISTR1, LSTR1, ISTR2, LSTR2, IDIFF)                 TNAT
 
C  REVISED 27-AUG-99.
C  COMPARES THE TEXT OF TWO LINKED FEATURE DESCRIPTIONS. COMMENTS ARE IGNORED.
 
C  ISTR1 RECEIVES THE FIRST DESCRIPTION.
C  LSTR1 RECEIVES THE LENGTH OF ISTR1.
C  ISTR2 RECEIVES THE SECOND DESCRIPTION.
C  LSTR2 RECEIVES THE LENGTH OF ISTR2.
C  IDIFF RETURNS -1 IF THERE IS NO DIFFERENCE, OR THE OFFSET FROM THE 
C   START OF THE SECOND DESCRIPTION WHERE THE FIRST WORD DIFFERENCE OCCURS.
 
      COMMON /BLKXXX/ KBLANK
      COMMON /IGNXXX/ ICMD,IGNTYP
 
      DIMENSION ISTR1(LSTR1),ISTR2(LSTR2)
 
      IDIFF = -1
      NSAME = 0
      NEW1 = 1
      NEW2 = 1
      NEXT1 = 0
      NEXT2 = 0
      IOFF = 0
 
      IE1 = ISTR1(1)
      IE2 = ISTR2(1)
      JSG1 = 2
      JSG2 = 2
 
   20 IF (JSG1.GT.IE1.OR.JSG2.GT.IE2)  GOTO 100
        IF (NEW1.NE.0)  THEN
          IF (ISTR1(JSG1+1).EQ.0)  THEN
C         IGNORE COMMENTS.
            NEXT1 = 1
            NEXT2 = 0
            GOTO 30
          ENDIF
          IB1 = JSG1 + 2
          L1 = ISTR1(JSG1) - 2
          NEW1 = 0
        ENDIF
        IF (NEW2.NE.0)  THEN
          IF (ISTR2(JSG2+1).EQ.0)  THEN
C         IGNORE COMMENTS.
            NEXT2 = 1
            NEXT1 = 0
            GOTO 40
          ENDIF
          IB2 = JSG2 + 2
          L2 = ISTR2(JSG2) - 2
          NEW2 = 0
        ENDIF
        ICMD1 = 0
        ICMD2 = 0
        NEXT1 = 0
        NEXT2 = 0
        IOFF = NSAME
        N1 = 0
        N2 = 0
        NCMP = MIN(L1, L2)
        DO WHILE (N1.LT.NCMP.AND.N2.LT.NCMP)
C         Restore value of ICMD for ISTR1.
          ICMD = ICMD1
          IF (IGNOR(ISTR1(IB1)).NE.0)  THEN
            IB1 = IB1 + 1
            ICMD1 = ICMD
            N1 = N1 + 1
            GOTO 10
          ENDIF
C         Restore value of ICMD for ISTR2.
          ICMD = ICMD2
          IF (IGNOR(ISTR2(IB2)).NE.0)  THEN
            NSAME = NSAME + 1
            IB2 = IB2 + 1
            ICMD2 = ICMD
            N2 = N2 + 1
            GOTO 10
          ENDIF
          IF (ISTR1(IB1).NE.ISTR2(IB2))  GOTO 50
          NSAME = NSAME + 1
          IF (ISTR1(IB1).EQ.KBLANK)  IOFF = NSAME
          IB1 = IB1 + 1
          IB2 = IB2 + 1
          N1 = N1 + 1
          N2 = N2 + 1
   10     CONTINUE
        ENDDO
        L1 = L1 - N1
        L2 = L2 - N2
        IF (L1.EQ.L2)  THEN
          NEXT1 = 1
          NEXT2 = 1
          IOFF = NSAME
        ELSE IF (L1.EQ.0)  THEN
C         STR1 IS SHORTER.
C         IF NEXT CHARACTER IN STR2 IS NOT A BLANK, THEN LAST WORD IS NOT
C         COMPLETELY MATCHED.
C         FIRST, SKIP OVER ANY TYPESETTING MARKS
          ICMD = ICMD2
   15     IF (L2.GT.0.AND.IGNOR(ISTR2(IB2)).NE.0)  THEN
            NSAME = NSAME + 1
            ICMD2 = ICMD
            IB2 = IB2 + 1
            L2 = L2 - 1
            IF (L2.EQ.0) NEXT2 = 1
            GOTO 15
          ENDIF
          IF (L2.GT.0.AND.ISTR2(IB2).NE.KBLANK)  GOTO 50
          IOFF = NSAME
C         OTHERWISE, PROCEED WITH MATCHING
          NEXT1 = 1
          IF (L2.EQ.0)  GOTO 30
C         SKIP ANY BLANKS IN STR2. NOTE IF END OF WORD.
   25     IF (ISTR2(IB2).NE.KBLANK)  GOTO 30
            NSAME = NSAME + 1
            IOFF = NSAME
            IB2 = IB2 + 1
            L2 = L2 - 1
            IF (L2.EQ.0) THEN
              NEXT2 = 1
              GOTO 30
            ENDIF
            GOTO 25
        ELSE
C         STR2 IS SHORTER.
C         IF NEXT CHARACTER IN STR1 IS NOT A BLANK, THEN LAST WORD IS NOT
C         COMPLETELY MATCHED.
C         FIRST, SKIP OVER ANY TYPESETTING MARKS
          ICMD = ICMD1
   17     IF (L1.GT.0.AND.IGNOR(ISTR1(IB1)).NE.0)  THEN
            IB1 = IB1 + 1
            ICMD1 = ICMD
            L1 = L1 - 1
            IF (L1.EQ.0) NEXT1 = 1
            GOTO 17
          ENDIF
          IF (L1.GT.0.AND.ISTR1(IB1).NE.KBLANK)  GOTO 50
C         OTHERWISE, PROCEED WITH MATCHING
          NEXT2 = 1
          IF (L1.EQ.0)  GOTO 30
C         SKIP ANY BLANKS IN STR1. NOTE IF END OF WORD.
   26     IF (ISTR1(IB1).NE.KBLANK)  GOTO 30
            IOFF = NSAME
            IB1 = IB1 + 1
            L1 = L1 - 1
            IF (L1.EQ.0) THEN
              NEXT1 = 1
              GOTO 30
            ENDIF
            GOTO 26
        ENDIF
   30   IF (NEXT1.NE.0)  THEN
          JSG1 = JSG1 + ISTR1(JSG1)
          NEW1 = 1
        ENDIF
   40   IF (NEXT2.NE.0)  THEN
          JSG2 = JSG2 + ISTR2(JSG2)
          NEW2 = 1
        ENDIF
        GOTO 20
 
   50 IDIFF = IOFF
 
  100 IF (IDIFF.LT.0)  THEN
  105   IF (JSG2.GT.IE2)  GOTO 110
          IF (ISTR2(JSG2+1).NE.0)  THEN
            IDIFF = IOFF
            GOTO 110
          ELSE
            JSG2 = JSG2 + ISTR2(JSG2)
            GOTO 105
          ENDIF
      ENDIF
 
  110 RETURN
      END
      SUBROUTINE CMPITM (ITM1, ITM2, LIDAT, IC, ISAME)                      TNAT
 
C  REVISED 5-MAR-87.
C  COMPARES ATTRIBUTES OF TWO ITEMS.
 
C  ITM1 RECEIVES THE FIRST ITEM.
C  ITM2 RECEIVES THE SECOND ITEM.
C  LIDAT RECEIVES THE LENGTH OF ITM1 AND ITM2.
C  IC RECEIVES THE CHARACTER NUMBER.
C  ISAME RETURNS 1 IF THE ATTRIBUTES ARE IDENTICAL, 0 OTHERWISE.
 
      DIMENSION ITM1(LIDAT),ITM2(LIDAT)
 
      ISAME = 0
 
      JG1 = ITM1(IC)
      JG2 = ITM2(IC)
      IF (JG1.LE.0.AND.JG2.LE.0)  GOTO 50
      L1 = ITM1(JG1)
      L2 = ITM2(JG2)
      IF (L1.NE.L2)  GOTO 100
      L = L1 - 1
      DO 20 I = 1, L
        IF (ITM1(JG1+I).NE.ITM2(JG2+I))  GOTO 100
   20   CONTINUE
 
   50 ISAME = 1
 
  100 RETURN
      END
      FUNCTION   IFINCL (IMC, IADDCH, IADDT, IADDC, IEMPCH, IEMPT,          TNAT
     * IEMPC)
 
C  REVISED 14-MAR-91.
C  DETERMINES WHETHER A CHARACTER IS TO BE INCLUDED IN NATURAL
C   LANGUAGE OUTPUT.
 
C  IMC RECEIVES WHETHER THE CHARACTER HAS BEEN MASKED-IN.
C  IADDCH RECEIVES WHETHER CHARACTERS HAVE BEEN ADDED.
C  IADDT RECEIVES WHETHER CHARACTERS HAVE BEEN ADDED FOR THE CURRENT TAXON.
C  IADDC RECEIVES WHETHER THE CHARACTER HAS BEEN ADDED TO THE CURRENT TAXON.
C  IEMPCH RECEIVES WHETHER CHARACTERS ARE TO BE IEMPHASIZED.
C  IEMPT RECEIVES WHETHER CHARACTERS ARE TO BE EMPHASIZED IN THE CURRENT TAXON.
C  IEMPC RECEIVES WHETHER THE CHARACTER IS TO BE EMPHASIZED IN THE
C   CURRENT TAXON.
 
      IFINCL = 0
      IF (IMC.NE.0)  IFINCL = 1
      IF (IADDCH.NE.0.AND.IADDT.NE.0.AND.IADDC.NE.0)  GOTO 20
      IF (IEMPCH.NE.0.AND.IEMPT.NE.0.AND.IEMPC.NE.0)  GOTO 20
      GOTO 100
 
   20 IFINCL = 2
 
  100 RETURN
      END
      INTEGER FUNCTION ISCOD (IC, IDAT, LIDAT)
 
C  REVISED 21-MAY-91.
C  DETERMINES WHETHER THERE IS NATURAL LANGUAGE OUTPUT FOR A CHARACTER.
 
C  IC RECEIVES THE CHARACTER NUMBER.
C  IDAT RECEIVES THE ITEM.
C  LIDAT RECEIVES THE LENGTH OF IDAT.
 
      COMMON /ITSXXX/ ITSS
      COMMON /MISXXX/ IMPVAL,IPACH,IPCHN,IPUNC,IRAB,IKEYCH,ICMPRS,
     * ITUNC,ITINAP,ITIMPL,IUNVAR,LNKC,IDEPC,LICDEP,IPSUMM,ICHSEQ,
     * ITMSEQ,INSRVA,IFATT,ITINTR,ICMAND,IUNRNG,IOMTOR,NEWFLS,IRSEMI,
     * IOMSTC,IADDCH,IEMPCH,IVARUN,ISCALC,ICNOTE,ICIMGE,ITIMGE,MTIMGE,
     * NTIMGE,IOMNSC,IOMCMT,IOMLOW,IERRPC,IERRAB,ICHNSE,NUMST0,IUMEAN,
     * NADNAM,NEMNAM,NODELO,IOMUSP,ICKYIMG,ITKYIMG,ISUPIMG,ICTIMGE,
     * ICTNAME,IHTML,IRTF,MTHEAD,NTHEAD,ITMHDGS,LCDNAM,MTFILE,NTFILE,
     * ITMFILS,MXHEAD,NXHEAD,IDXHDGS,INSIMGFN,ICOFILE,IUCC,IOUNC,ITLINK,
     * MTLINK,NTLINK,NAUTOCC,IOUTSUBJ
 
      DIMENSION IDAT(LIDAT)
 
      ISCOD = 0
 
      IF (IDAT(IC).EQ.0)  GOTO 100
      JG = IDAT(IC)
      JSG = JG + 1
      IENDC = JG + IDAT(JG)
 
C     CHARACTER NUMBER ONLY?
      IF (JSG.GE.IENDC)  GOTO 100
C     COMMENT PRESENT?
      IF (IDAT(JSG+1).EQ.0)  GOTO 90
 
   10 IF (JSG.GE.IENDC)  GOTO 100
        ITS = IDAT(JSG+1)
        IF (ITS.LT.0)  GOTO 50
        IF (ITS.EQ.0)  GOTO 90
        IF (ITS.LE.ITSS)  GOTO 90
C       PSEUDO-VALUES.
C              V  U  -
        GOTO (90,50,40), ITS-ITSS
 
C       INAPPLICABLE.
   40   IF (JSG+IDAT(JSG).LT.IENDC)  GOTO 90
        IF (ITINAP.NE.0)  GOTO 90
        GOTO 50
 
   50   JSG = JSG + IDAT(JSG)
        GOTO 10
 
   90 ISCOD = 1
 
  100 RETURN
      END
      SUBROUTINE NATTI (IDAT, IDAM, IDAV, ITYPC, IMC, NSTAT,                TNAT
     * NDEC, ICDES, LCDES, IPARA, IEMPF, LINKC, IOMORC, IREPS, IOMPD,
     * IALTC, IOMFC, IOMLO, IOUSP,
     * IA1S, IMI, IFILS, ITSHD, ICSTR, IMPFLG, ITMADD, IADDT,
     * IADDC, IEMPT, IEMPC, ITYPMK, LLANG, ITHDING, ITFILE, IXHDING,
     * IFOFSET, LUNTYP)
 
C* REVISED 25-OCT-00.
C* OUTPUTS ITEM IN NATURAL LANGUAGE.
 
C  21-MAY-91. PROVISIONS FOR "TYPESETTING MARKS".
C  14-MAR-91. OUTPUT IMPLICIT VALUES FOR "ADD CHARACTERS" AND
C   "ITALICIZE CHARACTERS"
C  19/10/88. "ADD CHARACTERS" AND "ITALICIZE CHARACTERS".
C  18/7/88. DIAGNOSTIC DESCRIPTIONS.
C  11/4/88. REPLACE SEMICOLON BY COMMA.
C  2/2/88. REMOVE UNCODED CHARACTERS CODE.
C  30/12/87. USE BRACKETS WITH EXTREME RANGES.
C  7/4/87. USE '-' INSTEAD OF 'TO' TO LINK NUMERICS.
C  3/12/86. NEW HANDLING OF ITEMS.
C  1/10/86. TAXON NAME TYPESET IN BOLD FONT.
 
C  IDAT RECEIVES THE ITEM.
C  IDAM RECEIVES THE MASTER ITEM.
C  IDAV RECEIVES WORKING SPACE.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  IMC RECEIVES THE CHARACTER MASK.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  NDEC RECEIVES THE NUMBERS OF DECIMAL PLACES FOR OUTPUT.
C  ICDES RECEIVES THE STARTING POSITIONS OF THE CHARACTER DESCRIPTIONS.
C  LCDES RECEIVES THE LENGTHS OF THE CHARACTER DESCRIPTIONS.
C  IPARA RECEIVES FLAGS INDICATING WHERE NEW PARAGRAPHS ARE TO BE
C    STARTED.
C  IEMPF RECEIVES FLAGS INDICATING WHICH FEATURES ARE TO BE EMPHASIZED.
C  LINKC RECEIVES FLAGS INDICATING WHICH GROUPS OF CHARACTERS ARE
C    TO BE LINKED IN THE DESCRIPTIONS.
C  IOMORC RECEIVES WHERE TO OMIT "OR" FROM DESCRIPTIONS.
C  IREPS RECEIVES CHARACTER GROUPS WHERE SEMICOLON IS TO BE REPLACED BY
C    COMMA AS A SEPARATOR.
C  IOMPD RECEIVES WHETHER TO OMIT A PERIOD AT THE END OF A CHARACTER.
C  IALTC RECEIVES WHETHER TO USE THE ALTERNATE COMMA FOR A CHARACTER.
C  IOMFC RECEIVES WHETHER TO OMIT THE FINAL COMMA FOR A CHARACTER.
C  IOMLO RECEIVES WHETHER TO OMIT THE LOWER END OF A NUMERIC RANGE.
C  IOUSP RECEIVES WHETHER TO OMIT THE SPACE BEFORE THE UNITS OF NUMERIC
C  CHARACTERS.
C  IA1S RECEIVES WORKING SPACE OF LENGTH MS.
C  IMI RECEIVES THE ITEM MASK.
C  IFILS RECEIVES FLAGS INDICATING WHERE NEW FILES ARE TO BE
C    STARTED.
C  ITSHD RECEIVES THE ITEM SUBHEADINGS (SEE SUBR. RDSENL)
C  ICSTR. IF THE CHARACTER DESCRIPTIONS ARE STORED IN MAIN MEMORY
C    (SEE SUBR. STOREC), ICSTR RECEIVES THESE DESCRIPTIONS.
C    IF NOT, ICSTR IS USED AS A BUFFER TO HOLD EACH CHARACTER
C    DESCRIPTION AS IT IS FETCHED BY A CALL TO FETCHC.
C    THE CODE IN THIS SUBR. (NATTI) IS INDEPENDENT OF THE METHOD OF
C    STORAGE OF THE DESCRIPTIONS.
C  IMPFLG RECEIVES WHETHER IMPLICIT VALUES HAVE BEEN INSERTED.
C  ITMADD RECEIVES WHERE DATA HAS BEEN COPIED TO A VARIANT ITEM.
C  IADDT RECEIVES RECORD POINTERS TO ADDITIONAL CHARACTERS.
C  IADDC RECEIVES WORKING SPACE TO STORE ADDITIONAL CHARACTERS.
C  IEMPT RECEIVES RECORD POINTERS TO CHARACTERS TO BE EMPHASIZED.
C  IEMPC RECEIVES WORKING SPACE TO STORE EM[PHASIZED CHARACTERS.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  LLANG RECEIVES THE INFORMATION FROM THE ALTERNATE LANGUAGES DIRECTIVE.
C  ITHDING RECEIVES POINTERS TO THE ITEM HEADINGS.
C  ITFILE RECEIVES POINTERS TO THE ITEM OUTPUT FILES.
C  IXHDING RECEIVES POINTERS TO THE INDEX HEADINGS.
C  IFOFSET RECEIVES SPACE OF LENGTH NC TO STORE FEATURE OFFSETS FOR LINKED,
C   EMPHASIZED CHARACTERS.
C  LUNTYP RECEIVES THE OUTPUT TYPE (3=PRINT, 6=BINARY)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /CAPXXX/ KCAPMK,IOMCAP
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /DIMXXX/ NC,MI,MS,LIDAT,LCSTR
      COMMON /FILXXX/ NFILE
      COMMON /INIXXX/ JI,JT,JIM,IVARIT,MASTIN,MISTOP
      COMMON /ITSXXX/ ITSS
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /LANGXX/ IUSELNG1,IUSELNG2,NLANG
      COMMON /LUFXXX/ FNAME(19),LFNAME(19)
        CHARACTER FNAME*80
      COMMON /LUNDAX/ LRECDA,IRECDA
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
      COMMON /MISXXX/ IMPVAL,IPACH,IPCHN,IPUNC,IRAB,IKEYCH,ICMPRS,
     * ITUNC,ITINAP,ITIMPL,IUNVAR,LNKC,IDEPC,LICDEP,IPSUMM,ICHSEQ,
     * ITMSEQ,INSRVA,IFATT,ITINTR,ICMAND,IUNRNG,IOMTOR,NEWFLS,IRSEMI,
     * IOMSTC,IADDCH,IEMPCH,IVARUN,ISCALC,ICNOTE,ICIMGE,ITIMGE,MTIMGE,
     * NTIMGE,IOMNSC,IOMCMT,IOMLOW,IERRPC,IERRAB,ICHNSE,NUMST0,IUMEAN,
     * NADNAM,NEMNAM,NODELO,IOMUSP,ICKYIMG,ITKYIMG,ISUPIMG,ICTIMGE,
     * ICTNAME,IHTML,IRTF,MTHEAD,NTHEAD,ITMHDGS,LCDNAM,MTFILE,NTFILE,
     * ITMFILS,MXHEAD,NXHEAD,IDXHDGS,INSIMGFN,ICOFILE,IUCC,IOUNC,ITLINK,
     * MTLINK,NTLINK,NAUTOCC,IOUTSUBJ
      COMMON /DIRYXX/ OUTDIR,LOUTDIR,IMGDIR,LIMGDIR
        CHARACTER*80 OUTDIR,IMGDIR
      COMMON /SCR6XX/ LRECS6,IRECS6
      COMMON /SCRCXX/ LRECSC
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
      COMMON /TNAMEX/ TNAME,LTNAME
        CHARACTER*256 TNAME
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
      COMMON /TRNXXX/ IPCHAR,IPITEM,IPNAME,ITRAN
      COMMON /VLWXXX/ NVWD,MAXVWD,LVWD(18),IBPUNC,IEPUNC,
     * KVSTOP,KVCOM1,KVCOM2,KVSEMI,KVDEC
 
      DIMENSION IDAT(LIDAT),IDAM(LIDAT),IDAV(LIDAT),ITYPC(NC),IMC(NC),
     * NSTAT(NC),NDEC(NC),ICDES(NC),LCDES(NC),IPARA(NC),IEMPF(NC),
     * LINKC(NC),IOMORC(NC),IREPS(NC),IOMPD(NC),IALTC(NC),IOMFC(NC),
     * IOMLO(NC),IOUSP(NC),IMPFLG(NC),
     * ITMADD(NC),IA1S(MS),IMI(JI),IFILS(JI),ITSHD(LIDAT),ICSTR(LCSTR),
     * IADDT(JI),IADDC(NC),IEMPT(JI),IEMPC(NC),ITYPMK(LIDAT),
     * LLANG(LIDAT),ITHDING(MI),ITFILE(MI),IXHDING(MI),IFOFSET(NC),
     * IERRWD(6)
C
      CHARACTER*6 ERRWRD,FMT*10,TEMP*80,PREVNAM*80
      PARAMETER (ERRWRD = '******', LERR = 6)
 
C     NUMBER OF LOGICAL UNITS IN LUNXXX.
      PARAMETER (NU=15)                                                       =*
      DIMENSION LU(NU)
      EQUIVALENCE (LU(1),LUNE)
 
      LUNOUT = LU(LUNTYP)
      IOMCAP = 1

C     TYPESETTING MARK AT END OF EACH FILE - AFTER LAST ITEM
      IF (IVARIT.EQ.-1) THEN
        IF (LUNREC(LUNOUT).GT.0.AND.ITPSET.GT.0) THEN
          CALL JSTTPS (29, ITYPMK, LIDAT, NTYPMK, LUNTYP)
          IFEND = 1
          CALL ENDLN (LUNTYP)
        ENDIF
        GOTO 2000
      ENDIF
 
C     Check if name is  Implicit_Attributes"
      IMPLNAM = IMPNAM (IDAT(NC+2), LIDAT)
 
C     New file required?
      NEWFILE = 0
      IF (NEWFLS.NE.0.AND.IFILS(JI).NE.0)  THEN
C       NEW FILES AT ...
        NEWFILE = 1
      ELSE IF (ITMFILS.NE.0.AND.ITFILE(JI).NE.0)  THEN
C       ITEM OUTPUT FILES.
        IRECS6 = ITFILE(JI)
        CALL RDDAI (L, 1, LUNS6, LRECS6, IRECS6)
        IF (L.LE.LIDAT) THEN
          IRECS6 = IRECS6 + 1
          CALL RDDAI (IDAV, L, LUNS6, LRECS6, IRECS6)
          KSG = 2
          L = IDAV(KSG) - 2
          IF (L.GT.0)  THEN
            NEWFILE = 2
C           Text begins at KSG+2
            IBFNAM = KSG + 2
            LFNAM = L
          ENDIF
        ENDIF
      ELSE IF (ICOFILE.NE.0)  THEN
C       CHARACTER FOR OUTPUT FILES.
        ISCODED = 0
        IF (IDAT(ICOFILE).EQ.0)  THEN
          IF (IMPLNAM.NE.0)  GOTO 2
          GOTO 1
        ENDIF
        JG = IDAT(ICOFILE)
        JSG = JG + 1
        IB = JSG + 2
        IE = JSG + IDAT(JSG) - 1
        CALL REMNSC (IDAT(IB), IE-IB+1, L)
C       EMPTY?
        IF (L.LE.2) GOTO 1
C       TEST FOR EMPTY TEXT.
        IF (IEMPTYCMT(IDAT(IB), L).NE.0)  GOTO 1
        NEWFILE = 3
        ISCODED = 1
C       COPY INTO IDAV AND IGNORE ANGLE BRACKETS.
C       (USING IDAV SO THAT NEWFILE=2 AND NEWFILE=3 CAN USE THE SAME CODE.)
 
C        CALL COPIA (IDAT(IB+1), IDAV, L-2)
C        IBFNAM = 1
C        LFNAM = L - 2
 
C       Only copy the first word (just in case there is more than one word)
        IBFNAM = 1
        DO I = 1, L-2
          IF (IDAT(IB+I).EQ.KBLANK) THEN
            LFNAM = I - 1
            GOTO 1
          ENDIF
          IDAV(I) = IDAT(IB+I)
        ENDDO
        LFNAM = L - 2

    1   IF (ISCODED.EQ.0)
     *    CALL MESSC (166, IDUM, 1, -3, 0, TNAME(1:LTNAME), LTNAME, 1)
      ENDIF
    2 CONTINUE
 
C--   OPEN NEW FILE IF REQUIRED.
      IF (NEWFILE.NE.0) THEN
        LF = LFNAME(LUNOUT)
        PREVNAM = FNAME(LUNOUT)(1:LF)
        IPREVLEN = LF
CC-      Close current file.
C        IF (LUNREC(LUNOUT).EQ.0)  THEN
C          CLOSE (UNIT=LUNOUT, STATUS='DELETE')
C          CALL MESSC (118, IDUM, 1, 0, 0, FNAME(LUNOUT)(1:LF), LF, 1)
C        ELSE
CC         Typesetting mark at end of each file
C          IF (ITPSET.GT.0)  CALL JSTTPS (29, ITYPMK, LIDAT, NTYPMK,
C     *     LUNTYP)
C          CALL ENDLN (LUNTYP)
C          CLOSE (UNIT=LUNOUT)
C          CALL MESSC (119, IDUM, 1, 0, 0, FNAME(LUNOUT)(1:LF), LF, 1)
C        ENDIF
C        NFILE = NFILE + 1
C        LUNREC(LUNOUT) = 0
 
        NFILE = NFILE + 1
C-      FORM NEW FILE NAME.
        IF (NEWFILE.EQ.1)  THEN
C         Using NEW FILES AT ITEMS directive
        
C         CHECK FOR PATH INFORMATION.
C         FIND START OF NAME.
          DO I = LF, 1, -1
            IF (FNAME(LUNOUT)(I:I).EQ.CHAR(KCOLON) .OR.
     *          FNAME(LUNOUT)(I:I).EQ.CHAR(KDBSLSH)) GOTO 3
          END DO
   3      IBN = I + 1
        
          I = INDEX (FNAME(LUNOUT)(1:LF),CHAR(KDSTOP))
          NDIG = NDIGIT(MI)
C         This done for MJD, because all his box program assume min. of 3 digits
          NDIG = MAX(3, NDIG)
          J = MIN(I, IBN+(8-NDIG))
          WRITE(FMT, 4) NDIG, NDIG
    4     FORMAT('(I', I1, '.', I1, ')')
        
          IF (NFILE.EQ.1)  THEN
            TEMP = FNAME(LUNOUT)(1:J-1)
            WRITE(TEMP(J:), FMT) NFILE
            TEMP(J+NDIG:) = FNAME(LUNOUT)(I:LF)
            LF1 = J+NDIG+LF-I+1
            FNAME(LUNOUT) = TEMP(1:LF1)
            LFNAME(LUNOUT) = LF1
          ELSE
            WRITE (FNAME(LUNOUT)(I-NDIG:I-1),FMT) NFILE
          ENDIF
        ELSE IF (NEWFILE.EQ.2.OR.NEWFILE.EQ.3)  THEN
C         2 = Using ITEM OUTPUT FILES directive
C         3 = Using CHARACTER FOR OUTPUT FILES directive.
C         Check if file name already contains a path
          IPATH = 0
          DO I = 1, LFNAM
            IF (IDAV(IBFNAM+I-1).EQ.KDBSLSH.OR.
     *        IDAV(IBFNAM+I-1).EQ.KDSOL)  THEN
              IPATH = 1
              GOTO 5
            ENDIF
          ENDDO
    5     FNAME(LUNOUT) = CHAR(KBLANK)
          LF = 0
C         Insert output path if not already present
          IF (IPATH.EQ.0.AND.LOUTDIR.GT.0) THEN
            FNAME(LUNOUT) = OUTDIR
            LF = LOUTDIR
          ENDIF
          DO I = 1, LFNAM
            J = LF + I
            FNAME(LUNOUT)(J:J) = CHAR(IDAV(IBFNAM+I-1))
          ENDDO
          LFNAME(LUNOUT) = LF + LFNAM
          IDOT = 0
          DO J = LFNAME(LUNOUT), 1, -1
            IF (FNAME(LUNOUT)(J:J).EQ.CHAR(KDSOL).OR.
     *        FNAME(LUNOUT)(J:J).EQ.CHAR(KDBSLSH)) GOTO 6
            IF (FNAME(LUNOUT)(J:J).EQ.CHAR(KDSTOP)) IDOT = J
          ENDDO
C         Add extension?
    6     IF (IDOT.EQ.0)  THEN
            L = LFNAME(LUNOUT)
            IF (IHTML.NE.0)  THEN
              FNAME(LUNOUT)(L+1:) = '.htm'
            ELSE IF (IRTF.NE.0)  THEN
              FNAME(LUNOUT)(L+1:) = '.rtf'
            ELSE IF (ITPSET.NE.0)  THEN
              FNAME(LUNOUT)(L+1:) = '.tps'
            ELSE
              FNAME(LUNOUT)(L+1:) = '.prt'
            ENDIF
            LFNAME(LUNOUT) = L + 4
          ENDIF
        ENDIF
 
C        I = INDEX (FNAME(LUNOUT)(1:LF),'.')
C        J = MIN(I, IBN+5)
C        IF (NFILE.EQ.1)  THEN
C          TEMP = FNAME(LUNOUT)(1:J-1)
C          TEMP(J:) = '001'
C          TEMP(J+3:) = FNAME(LUNOUT)(I:LF)
C          LF1 = J+3+LF-I+1
C          FNAME(LUNOUT) = TEMP(1:LF1)
C          LFNAME(LUNOUT) = LF1
C        ELSE
C          WRITE (FNAME(LUNOUT)(I-3:I-1),'(I3.3)') NFILE
C        ENDIF
 
C-      OPEN NEW FILE.
C       Need to call EXNAME so that the Windows version can complete any
C       relative paths in the new file name.
        CALL EXNAME(FNAME(LUNOUT), TEMP)
        LFNAME(LUNOUT) = LSTRB(FNAME(LUNOUT))

C       Compare new file name with previous file name.
        ISAME = 0
        IF (LFNAME(LUNOUT).EQ.IPREVLEN) THEN
          IF (FNAME(LUNOUT)(1:IPREVLEN).EQ.PREVNAM(1:IPREVLEN)) THEN
            ISAME = 1
            NEWFILE = 0
          ENDIF
        ENDIF
 
        IF (ISAME.EQ.0) THEN
 
C-        Close current file.
          IF (LUNREC(LUNOUT).EQ.0)  THEN
            CLOSE (UNIT=LUNOUT, STATUS='DELETE')
            CALL MESSC (118, IDUM, 1, 0, 0, PREVNAM(1:IPREVLEN),
     *        IPREVLEN, 1)
          ELSE
C           Typesetting mark at end of each file
            IF (ITPSET.GT.0)  CALL JSTTPS (29, ITYPMK, LIDAT, NTYPMK,
     *       LUNTYP)
            CALL ENDLN (LUNTYP)
            ENDFILE(UNIT=LUNOUT)
            CLOSE (UNIT=LUNOUT)
            CALL MESSC (119, IDUM, 1, 0, 0, PREVNAM(1:IPREVLEN),
     *        IPREVLEN, 1)
          ENDIF
C***          NFILE = NFILE + 1
          LUNREC(LUNOUT) = 0
        
C         Open new file.
          CALL UOPEN (LUNOUT, LUNUSE(LUNOUT), FNAME(LUNOUT), LRECDA,
     *      IERR)
          IF (IERR.NE.0)  CALL MESSC (108, IDUM, 1, -1, 0,
     *      FNAME(LUNOUT), LFNAME(LUNOUT), 1)
          IFBEGIN = 0
        ENDIF
      ENDIF
 
      IF (IMPLNAM.EQ.0)  THEN
C       Save pointer to current ITEM HEADING
        IF (ITMHDGS.NE.0.AND.ITHDING(JI).NE.0)  ITHD = JI
C       Save pointer to current INDEX HEADING
        IF (IDXHDGS.NE.0.AND.IXHDING(JI).NE.0)  IXHD = JI
        
        IF (IMI(JI).EQ.0)  GO TO 2000
      ENDIF
        
C     TYPESETTING MARK AT START OF EACH FILE
      IF (IFBEGIN.EQ.0 .AND. ITPSET.GT.0) THEN
        CALL JSTTPS (28, ITYPMK, LIDAT, NTYPMK, LUNTYP)
        IFBEGIN = 1
        IFEND = 0
      ENDIF
 
      IF (IMPLNAM.EQ.0)  THEN
C       ADDED CHARACTERS.
        IF (IADDCH.NE.0)  THEN
          IF (IADDT(JI).NE.0)  THEN
            CALL RDDAI (IADDC, NC, LUNS4, LRECSC, IADDT(JI))
C            READ (LUNS4,REC=IADDT(JI)) (IADDC(I),I=1,NC)
          ELSE
            CALL SETIA (IADDC, NC, 0)
          ENDIF
        ENDIF
        
C       EMPHASIZED CHARACTERS.
        IF (IEMPCH.NE.0)  THEN
          IF (IEMPT(JI).NE.0) THEN
            CALL RDDAI (IEMPC, NC, LUNS5, LRECSC, IEMPT(JI))
C            READ (LUNS5,REC=IEMPT(JI)) (IEMPC(I),I=1,NC)
          ELSE
            CALL SETIA (IEMPC, NC, 0)
          ENDIF
        ENDIF
      ELSE
        CALL SETIA (IADDC, NC, 0)
        CALL SETIA (IEMPC, NC, 0)
      ENDIF
 
C--   SET INDENTATION, ETC.
      PSEQ = 0
      INDEN(LUNTYP) = 0
      IF (IPITEM.NE.0) THEN
        I = 1
        J = 12
      ELSE
        IF (ICHNSE.NE.0)  THEN
          I = 1
        ELSE
          I = 2
        ENDIF
        J = 13
      ENDIF
      IF (ITPSET.LE.0) THEN
        CALL BLKLIN (I, 5, LUNTYP)
      ELSE
        CALL BLKLIN (1, 0, LUNTYP)
      ENDIF
      IF (IMPLNAM.EQ.0.AND.ITPSET.GT.0)
     *  CALL JSTTPS (J, ITYPMK, LIDAT, NTYPMK, LUNTYP)
 
C     OUTPUT ITEM HEADING IF PRESENT.
      IHDOUT = 0
      IF (ITMHDGS.NE.0.AND.ITHDING(ITHD).NE.0)  THEN
        IRECS6 = ITHDING(ITHD)
        CALL RDDAI (L, 1, LUNS6, LRECS6, IRECS6)
        IF (L.LE.LIDAT) THEN
          IRECS6 = IRECS6 + 1
          CALL RDDAI (IDAV, L, LUNS6, LRECS6, IRECS6)
          IE = 1
          IF (ITPSET.GT.0) THEN
            CALL JSTTPS (30, ITYPMK, LIDAT, NTYPMK, LUNTYP)
            IE = 0
          ENDIF
          CALL WSENT (IDAV, LIDAT, 0, 0, 0, 0, IE, ITYPMK, LIDAT,
     *      LUNTYP)
          IF (ITPSET.GT.0)  CALL JSTTPS (31, ITYPMK, LIDAT, NTYPMK,
     *      LUNTYP)
          IHDOUT = 1
        ENDIF
        ITHD = 0
      ENDIF
 
C     Get logical unit for index file.
      LUNIDX = LU(4)
 
C     OUTPUT INDEX HEADING IF PRESENT.
      IF (LUNIDX.GT.0)  THEN
        IF (IDXHDGS.NE.0.AND.IXHDING(IXHD).NE.0)  THEN
          IRECS6 = IXHDING(IXHD)
          CALL RDDAI (L, 1, LUNS6, LRECS6, IRECS6)
          IF (L.LE.LIDAT) THEN
            IRECS6 = IRECS6 + 1
            CALL RDDAI (IDAV, L, LUNS6, LRECS6, IRECS6)
            IE = 0
            IF (ITPSET.GT.0)  CALL JSTTPS (30, ITYPMK, LIDAT, NTYPMK, 4)
            CALL WSENT (IDAV, LIDAT, 0, 0, 0, 0, IE, ITYPMK, LIDAT, 4)
            IF (ITPSET.GT.0)  CALL JSTTPS (31, ITYPMK, LIDAT, NTYPMK, 4)
            CALL ENDLN(4)
          ENDIF
          IXHD = 0
        ENDIF
      ENDIF
 
C     OUTPUT NAME OF FILE TO INDEX FILE.
      IF (IMPLNAM.EQ.0.AND.LUNIDX.GT.0)  THEN
        IF (ITPSET.GT.0)  CALL JSTTPS (34, ITYPMK, LIDAT, NTYPMK, 4)
C       Remove any path information from output file name.
        CALL EXNAME (FNAME(LUNOUT), TEMP)
        CALL JSTSTR (TEMP(1:LSTRB(TEMP)), IDAV, LIDAT, -1, 4, 0)
        IF (ITPSET.GT.0)  CALL JSTTPS (35, ITYPMK, LIDAT, NTYPMK, 4)
      ENDIF

C--   TAXON NAME.
      IF (IMPLNAM.EQ.0)  THEN
        IALTNAME = 0
C       Is there an alternate name specified in "CHARACTER FOR TAXON NAME"?
        IF (ICTNAME.NE.0.AND.IDAT(ICTNAME).NE.0) THEN
          KG = IDAT(ICTNAME)
          KSG = KG + 1
C         CHECK THAT THERE IS SOMETHING THERE
          IF (KSG.LT.KG+IDAT(KG)) THEN
            L = IDAT(KSG) - 2
C           IGNORE ANGLE BRACKETS
            L = L - 2
            IF (L.GT.0) IALTNAME = 1
          ENDIF
        ENDIF
C       Determine which typesetting mark to insert before the taxon name
        JTYPMK = 14
        IF ((IHDOUT.NE.0.OR.NEWFILE.EQ.0).AND.ITYPMK(51).NE.0)
     *    JTYPMK = 51
        IF (IALTNAME.NE.0) THEN
          CALL WALTNAME (IDAT(KG), LIDAT, ITYPMK, LIDAT, ITPSET, 0,
     *      JTYPMK, LUNTYP)
        ELSE
          CALL WNAME (IDAT(NC+2), LIDAT, ITYPMK, LIDAT, 1+IRAB, ITPSET,
     *      0, JTYPMK, LUNTYP)
        ENDIF
C       Write name to index file.
        IF (LUNIDX.GT.0)  THEN
          CALL WNAME (IDAT(NC+2), LIDAT, ITYPMK, LIDAT, 1+IRAB, 0,
     *      -1, JTYPMK, 4)
          IF (ITPSET.GT.0)  CALL JSTTPS (36, ITYPMK, LIDAT, NTYPMK, 4)
          CALL ENDLN(4)
        ENDIF
      ENDIF

C--
C     IF JPARA IS INITIALIZED TO 1, THERE WILL ALWAYS BE A NEW PARAGRAPH BEFORE
C     THE FIRST CHARACTER AFTER THE TAXON NAME.
      JPARA = 0
C     If there is no NEW PARAGRAPHS AT directive, force new paragraph at start.
      IF (NONZER(IPARA, NC).EQ.0) JPARA = 1
 
C     LPARATXT = WHETHER OUTPUT HAS OCCURRED SINCE LAST NEW PARAGRAPH MARK.
      LPARATXT = 1
      JHD = 0
      JIEMPF = 0
      JIEMPC = 0
      IFETO = 0
      LSTCHO = 0
C     IOTXT = WHETHER ANY NON-CHARACTER OUTPUT (E.G. HEADINGS) DONE WHILE
C             PROCESSING CURRENT CHARACTER
      IOTXT = 0
C     LASTXT = WHETHER ANY STATE OUTPUT DONE SINCE LAST PUNCTUATION OUTPUT.
      LASTXT = 0
C--
 
C     Calculate feature offsets for LINKED CHARACTERS.
C     Note: this code takes note of which characters are present in the each 
C     item.
C     It would also be possible to do this calculation once for all items,
C     ignoring missing characters. The result, though different, would also be
C     valid.
 
      CALL SETIA (IFOFSET, NC, 0)
      IF (LNKC.GT.0) THEN
        DO 88 IC = 1, NC
          IF (IFOFSET(IC).NE.0)  GOTO 88
          ICODED = ISCOD (IC, IDAT, LIDAT)
          IF (ICODED.EQ.0) GOTO 88
          JCREQ = IFINCL (IMC(IC), IADDCH, IADDT(JI), IADDC(IC),
     *     IEMPCH, IEMPT(JI), IEMPC(IC))
          IF (JCREQ.EQ.0)  GOTO 88
C         Ignore implicit characters unless ADDED or EMPHASIZED (i.e.JCREQ=2).
          IF (JCREQ.EQ.1.AND.IMPFLG(IC).EQ.1.AND.ITIMPL.EQ.0)  GOTO 88
          KC = LINKC(IC)
          IF (KC.EQ.0) GOTO 88
          CALL FETCHC (ICSTR, LCSTR, ICDES, LCDES, NC, IC, IAC, IA1S,
     *     MS)
C         Save first description of a linked list.
          CALL COPIA (ICSTR(IAC), IDAV, ICSTR(IAC))
          DO 8 JC = IC+1, NC
            ICODED = ISCOD (JC, IDAT, LIDAT)
            IF (ICODED.EQ.0)  GOTO 8
            JCREQ = IFINCL (IMC(JC), IADDCH, IADDT(JI), IADDC(JC),
     *       IEMPCH, IEMPT(JI), IEMPC(JC))
            IF (JCREQ.EQ.0)  GOTO 8
C           IMPLICIT VALUE?
C           Ignore implicit characters unless ADDED or EMPHASIZED (i.e.JCREQ=2).
            IF (JCREQ.EQ.1.AND.IMPFLG(JC).EQ.1.AND.ITIMPL.EQ.0)  GOTO 8
            IF (LINKC(JC).NE.KC) GOTO 88
C           NOT APPLICABLE WITH NOTHING FOLLOWING?
            JG = IDAT(JC)
            JSG = JG + 1
            IF (IDAT(JSG).EQ.2.AND.IDAT(JSG+2).GE.7.AND.
     *        JSG+IDAT(JSG).GE.JG+IDAT(JG))  GOTO 8
    7       CALL FETCHC (ICSTR, LCSTR, ICDES, LCDES, NC, JC, IAC, IA1S,
     *       MS)
            CALL CMPCHR (IDAV, LIDAT, ICSTR(IAC), LCSTR, IOFFSET)
            IF (IOFFSET.EQ.0)  THEN
C             Assign dummy value so it will not be reprocessed.
              IFOFSET(JC) = -2
            ELSE
              IFOFSET(JC) = IOFFSET
            ENDIF
    8     CONTINUE
   88   CONTINUE
C       Clear dummy values.
        DO IC = 1, NC
          IF (IFOFSET(IC).EQ.-2) IFOFSET(IC) = 0
        ENDDO
      ENDIF
 
      DO 500 IC = 1, NC
 
C       ICHTXT = WHETHER ANY OUTPUT  WHILE PROCESSING CURRENT CHARACTER
        ICHTXT = 0
C       JSTATOUT = WHETHER ANY (NON-EMPTY) STATE OF THIS CHARACTER HAS BEEN OUTPUT
        JSTATOUT = 0
        ICMTOUT = 0
C       FLAG TO MARK THIS CHARACTER AS NOT OUTPUT I.E. NOT PROCESSED
        NOTOUTP = 0
 
C--     PRELIMINARIES FOR OUTPUT OF ATTRIBUTE.
        IF (IPARA(IC).NE.0) THEN
          JPARA = 1
C         17-JAN-91. THIS LINE COMMENTED OUT BECAUSE IT CAN DISABLE ITEM
C         SUB-HEADING FOR SUBSEQUENT PARAGRAPHS IF INTERVENING PARAGRAPHS ARE
C         EMPTY.
C         JHD = 0
        ENDIF
        IF (ITSHD(IC).NE.0)  JHD = ITSHD(IC)
        IF (ITPSET.GT.0)  JIEMPF = IEMPF(IC)
 
        IF (IDAT(IC).EQ.0) THEN
          NOTOUTP = 1
          GOTO 495
        ENDIF
        ICREQ = IFINCL (IMC(IC), IADDCH, IADDT(JI), IADDC(IC), IEMPCH,
     *   IEMPT(JI), IEMPC(IC))
        IF (ICREQ.EQ.0)  THEN
          NOTOUTP = 1
          GOTO 495
        ENDIF
 
  
C       IF NO OUTPUT SINCE LAST NEW PARAGRAPH, DON'T START ANOTHER NEW
C       PARAGRAPH.
        IF (IPARA(IC).NE.0)  THEN
          IF (LPARATXT.EQ.0)  JPARA = 0
C          LPARATXT = 0
        ENDIF
 
C--     Feature emphasis.
    9   JIEMPC = 0
        JIEMPS = 0
        IF (IEMPCH.NE.0)  THEN
          IF (IEMPT(JI).NE.0.AND.IEMPC(IC).NE.0.AND.ITPSET.GT.0)  THEN
            JIEMPC = IC
            JIEMPS = 1
          ENDIF
        ENDIF

C       Feature emphasis for LINKED EMPHASIZED CHARACTERS.
C       May need to emphasize the feature part of an unemphasized character
C       in a linked set, if a subsequent character is emphasized but its
C       feature (or part thereof) will be omitted because it is common to
C       to the first feature output in the linked set.
        IF (JIEMPC.EQ.0.AND.IEMPCH.NE.0.AND.ITPSET.GT.0)  THEN
          KC = LINKC(IC)
          IF (KC.EQ.0)  GOTO 21
C         If value already set, don't overwrite.
          IFSET = 0
          IF (IFOFSET(IC).NE.0) IFSET = 1
          MINOFF = 0
          DO 10 JC = IC+1, NC
            ICODED = ISCOD (JC, IDAT, LIDAT)
            IF (ICODED.EQ.0)  GOTO 10
            JCREQ = IFINCL (IMC(JC), IADDCH, IADDT(JI), IADDC(JC),
     *       IEMPCH, IEMPT(JI), IEMPC(JC))
            IF (JCREQ.EQ.0)  GOTO 10
C           IMPLICIT VALUE?
C           TAKE NOTE OF IMPLICIT CHARACTERS WHICH ARE "ADDED" OR "EMPHASIZED"
            IF (JCREQ.EQ.1.AND.IMPFLG(JC).EQ.1.AND.ITIMPL.EQ.0)  GOTO 10
            IF (LINKC(JC).NE.KC)  GOTO 20
C           NOT APPLICABLE WITH NOTHING FOLLOWING?
            JG = IDAT(JC)
            JSG = JG + 1
            IF (IDAT(JSG).EQ.2.AND.IDAT(JSG+2).GE.7.AND.
     *        JSG+IDAT(JSG).GE.JG+IDAT(JG))  GOTO 10
            IF (IEMPC(JC).NE.0.AND.IFOFSET(JC).NE.0)  THEN
              JIEMPC = IC
              IF (IFSET.NE.0)  THEN
                GOTO 21
              ELSE
                IF (IFOFSET(JC).GT.0) THEN
                  IF (MINOFF.EQ.0)  THEN
                    MINOFF = IFOFSET(JC)
                  ELSE
                    MINOFF = MIN0(MINOFF, IFOFSET(JC))
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
   10     CONTINUE
   20     IF (JIEMPC.NE.0.AND.IFSET.EQ.0) IFOFSET(IC) = MINOFF
        ENDIF
 
   21   IOA = 0
        IF (IVARIT.NE.0)  THEN
          IF (MASTIN.EQ.0)  GOTO 50
C         INSRVA = WHETHER TO INSERT REDUNDANT VARIANT ATTRIBUTES.
          IF (INSRVA.EQ.0)  THEN
            IF (ITMADD(IC).NE.0)  THEN
              NOTOUTP = 1
              GOTO 495
            ENDIF
          ELSE IF (INSRVA.GT.0)  THEN
            GOTO 50
          ELSE IF (INSRVA.LT.0)  THEN
            IF (ITMADD(IC).NE.0)  THEN
              NOTOUTP = 1
              GOTO 495
            ENDIF
            CALL CMPITM (IDAM, IDAT, LIDAT, IC, ISAME)
            IF (ISAME.NE.0)  THEN
              NOTOUTP = 1
              GOTO 495
            ENDIF
          ENDIF
        ENDIF
   50   IF (ICREQ.EQ.1.AND.IMPFLG(IC).EQ.1.AND.ITIMPL.EQ.0)  THEN
          NOTOUTP = 1
          GOTO 495
        ENDIF
        CALL FETCHC (ICSTR, LCSTR, ICDES, LCDES, NC, IC, IAC, IA1S, MS)
 
C       SET COMMA CHARACTER TO BE USED.
        IF (IALTC(IC).EQ.0)  THEN
          KCOM = KVCOM1
        ELSE
          KCOM = KVCOM2
        ENDIF
 
        IF (IDAT(IC).LE.0) THEN
C         ERROR.
C          CALL WFEAT (ICSTR, LCSTR, IDAV, LIDAT, LINKC, IREPS, IOMPD,
          CALL WFEAT (ICSTR, LCSTR, IFOFSET, LINKC, IREPS, IOMPD,
     *     NC, ITSHD, ITYPMK, LIDAT, IAC, IC, LNKC, IPCHN, JPARA, JHD,
     *     JIEMPF, JIEMPC, IEMPC(IC), IFETO, LSTCHO, IRSEMI, KCOM,
     *     ICHNSE, LASTXT, LPARATXT, LUNTYP)
          CALL COPSIA (ERRWRD, IERRWD, LERR)
          CALL JSTOTP (IERRWD, LERR, -1, ITYPMK, LIDAT, LUNTYP, 0, 0)
          ICHTXT = 1
          GO TO 500
        ENDIF
 
        JG = IDAT(IC)
        JSG = JG + 1
C       ONLY CHARACTER NUMBER CODED.
        IF (JSG.GE.JG+IDAT(JG))  GOTO 500
 
C       SET FLAG FOR HANDLING "OR".
        IF (IOMTOR.GT.0.AND.IOMORC(IC).NE.0)  THEN
          IFOR = 0
        ELSE
          IFOR = 1
        ENDIF
C       SET FLAG FOR HANDINGS COMMAS BEFORE "OR".
        IF (IRSEMI.GT.0.AND.IREPS(IC).GT.0)  THEN
          IFCOM = 0
        ELSE
          IFCOM = 1
        ENDIF
 
        JITSET = 0
        IF (IDAT(JSG+1).NE.0)  GO TO 100
 
C       FEATURE COMMENT OR TEXT CHARACTER.
C       OUTPUT FEATURE AND COMMENT IF REQUIRED.
 
        IF (IOMCMT.EQ.0.OR.ITYPC(IC).EQ.5)  THEN
 
CC         OUTPUT FEATURE.
C          IOTXT = JHD
C          IF (ICHTXT.EQ.0) ICHTXT =
C     *      ICHKFEAT (ICSTR(IAC), LCSTR, IFETO, LNKC, LINKC(IC), LSTCHO,
C     *      IDAV, LIDAT)
C          CALL WFEAT (ICSTR, LCSTR, IDAV, LIDAT, LINKC, IREPS, IOMPD,
C          CALL WFEAT (ICSTR, LCSTR, IFOFSET, LINKC, IREPS, IOMPD,
C     *      NC, ITSHD, ITYPMK, LIDAT, IAC, IC, LNKC, IPCHN, JPARA, JHD,
C     *      JIEMPF, JIEMPC, IEMPC(IC), IFETO, LSTCHO, IRSEMI, KCOM,
C     *      ICHNSE, LASTXT, LPARATXT, LUNTYP)
C          IOA = 1

C         OUTPUT COMMENT.
          IB = JSG + 2
          IE = JSG + IDAT(JSG) - 1
          IF (IOMNSC.NE.0.AND.IC.NE.ICTIMGE)  THEN
C           REMOVE NESTED COMMENTS - BUT NOT IN `CHARACTER FOR TAXON IMAGES'
            CALL REMNSC (IDAT(IB), IE-IB+1, L)
C           EMPTY COMMENT?
            IF (L.LE.2) GOTO 90
            IE = IB + L - 1
          ENDIF
C         TEST FOR EMPTY COMMENT.
          IF (IEMPTYCMT(IDAT(IB), IE-IB+1).NE.0)  GOTO 90
C         EXTRACT COMMENTS IN THE SPECIFIED LANGUAGE
C         Note: This is called before REPLAB
          IF (NLANG.GT.0.AND.IUSELNG1.NE.0)  THEN
            CALL LANGCMT(LLANG, LIDAT, IUSELNG1, IUSELNG2, NLANG,
     *        IDAT(IB), IE-IB+1, L)
            IE = IB + L - 1
          ENDIF
C         TEST FOR EMPTY COMMENT.
          IF (IEMPTYCMT(IDAT(IB), IE-IB+1).NE.0)  GOTO 90
 
C         OUTPUT FEATURE.
          IOTXT = JHD
          IF (ICHTXT.EQ.0) ICHTXT =
     *      ICHKFEAT (ICSTR(IAC), LCSTR, IFETO, LNKC, LINKC(IC), LSTCHO,
     *      IFOFSET(IC))
C     *      IDAV, LIDAT)
          CALL WFEAT (ICSTR, LCSTR, IFOFSET, LINKC, IREPS, IOMPD,
     *      NC, ITSHD, ITYPMK, LIDAT, IAC, IC, LNKC, IPCHN, JPARA, JHD,
     *      JIEMPF, JIEMPC, IEMPC(IC), IFETO, LSTCHO, IRSEMI, KCOM,
     *      ICHNSE, LASTXT, LPARATXT, LUNTYP)
          IOA = 1

          IF (ITYPC(IC).EQ.5.OR.IRAB.NE.0)  THEN
C           REMOVE ANGLE BRACKETS - BUT NOT IN THE 'CHARACTER FOR TAXON IMAGES'
            IF (IC.NE.ICTIMGE)  THEN
              CALL REPLAB (IDAT(IB), IE-IB+1, L, 1)
              IE = IB + L - 1
            ELSE
              IB = IB + 1
              IE = IE - 1
            ENDIF
          ENDIF
          IF (JIEMPS.NE.0) THEN
C                        .AND.ITYPC(IC).EQ.5)  THEN
            CALL JSTTPS (21, ITYPMK, LIDAT, NTYPMK, LUNTYP)
            JITSET = 1
          ENDIF
          IF (IE.GE.IB) THEN
            INHTML = 0
            IEND = 0
            IF (IC.EQ.ICTIMGE) INHTML = 1
C           Need to add a blank after a feature comment if is followed by
C           state information (not just "or inapplicable" - this is the
C           purpose of the "+2" in the test below for the end of the character
C           data)
            IF (ITYPC(IC).EQ.5.OR.
     *       JSG+IDAT(JSG)+2.GE.JG+IDAT(JG)) THEN
C             This is a text character or terminating comment.
C             Thus DON'T want separating blank after this.
              IEND = -1
C             Thus DO want punctuation after this to separate from following character.
C              (but not for a feature comment, followed by values).
              JSTATOUT = 1
            ENDIF
            CALL JSTOTP (IDAT(IB), IE-IB+1, IEND, ITYPMK,
     *      LIDAT, LUNTYP, INHTML, 0)
            ICMTOUT = 1
          ENDIF
          IF (JITSET.NE.0) THEN
C           Kludge to get a blank before the next state (if present) in binary
C           mode. No blank is required after a text character.
C           (Note: we know the blank is necessary here and the call to ENDWD
C           will have no effect for the reasons stated below.)
C           The problem in binary mode is that typsetting marks cause the output
c           buffer to be emptied and a blank character (as generated by ENDWD)
C           will not be inserted into an empty buffer.
C            IF (ITYPC(IC).NE.5.AND.LUNTYP.EQ.3.AND.LWIDTH(3).LT.0.AND.
C     *          JSG+IDAT(JSG).LT.JG+IDAT(JG))  THEN
C              CALL ENDWD(LUNTYP)
C            ENDIF
            CALL JSTTPS (22, ITYPMK, LIDAT, NTYPMK, LUNTYP)
            JITSET = 0
          ENDIF
        ENDIF
   90   JSG = JSG + IDAT(JSG)
        IF (JSG.GE.JG+IDAT(JG))  GOTO 490
 
C--     STATE DESCRIPTIONS.
 
C       EMPHASIZE STATE DESCRIPTIONS.
  100   IF (IOA.GT.0.AND.JIEMPS.NE.0)  THEN
          CALL JSTTPS (21, ITYPMK, LIDAT, NTYPMK, LUNTYP)
C         CALL ENDWD (LUNTYP)
          JITSET = 1
        ENDIF
 
        IF (IVARIT.NE.0.AND.ITMADD(IC).EQ.0)  GOTO 104
 
C     16-FEB-90. TREAT TYPE-2 IMPLICIT VALUES AS IF CODED. HENCE
C     FOLLOWING CODE WHICH TREATS THIS AS A SPECIAL CASE IS REMOVED.
 
C       ONLY CHARACTER NUMBER CODED, BUT HAVING IMPLICIT VALUE -
C       OUTPUT FEATURE DESCRIPTION.
C       IF (IMPFLG(IC).EQ.2.AND.ITIMPL.EQ.0)  THEN
C         IF (IOA.EQ.0)  THEN
C           IOTXT = JHD
C           IF (ICHTXT.EQ.0) ICHTXT =
C     *       ICHKFEAT (ICSTR(IAC), LCSTR, IFETO, LNKC, LINKC(IC), LSTCHO,
C     *       IDAV, LIDAT)
C          IF (ICHTXT.NE.0)
C    *      CALL WFEAT (ICSTR, LCSTR, IDAV, LIDAT,
C    *      LINKC, IREPS, IOMPD,
C    *      NC, ITSHD, ITYPMK, LIDAT, IAC, IC, LNKC, IPCHN, JPARA, JHD,
C    *      JIEMPF, JIEMPC, IEMPC(IC), IFETO, LSTCHO, IRSEMI, KCOM,
C    *      ICHNSE, LASTXT, LPARATXT, LUNTYP)
C         ENDIF
C         GOTO 490
C       ENDIF
 
  104   IEGRP = JG + IDAT(JG)
  105   IF (JSG.GE.IEGRP)  GO TO 490
          ITS = IDAT(JSG+1)
          NSV = IDAT(JSG) - 2
          ISV = 1
          LASTG = 0
          KSG = JSG + IDAT(JSG)
  106     IF (KSG.GE.IEGRP)  THEN
            LASTG = 1
            GOTO 108
          ENDIF
C         FOLLOWING SUB-GROUP IS A AN OMITTED COMMENT OR AN OMITTED INAPPLICABLE
          IF ((IDAT(KSG+1).EQ.0.AND.IOMCMT.NE.0) .OR.
     *        (IDAT(KSG+1).EQ.8.AND.ITINAP.EQ.0) )  THEN
            CONTINUE
          ELSE
            LASTG = 0
            GOTO 108
          ENDIF
          KSG = KSG + IDAT(KSG)
          GOTO 106
  108     IF (ITS.LT.0)  GO TO 400
          IF (ITS.GT.0)  GO TO 130
C
C-        COMMENT.
          IF (IOMCMT.NE.0)  GOTO 400
          IB = JSG + 2
          IE = JSG + IDAT(JSG) - 1
C         REMOVE NESTED COMMENTS, BEFORE OUTPUTTING COMMENT.
          IF (IOMNSC.NE.0)  THEN
            CALL REMNSC (IDAT(IB), IE-IB+1, L)
C           EMPTY COMMENT?
            IF (L.LE.2) GOTO 400
            IE = IB + L - 1
          ENDIF
C         TEST FOR EMPTY COMMENT.
          IF (IEMPTYCMT(IDAT(IB), IE-IB+1).NE.0)  GOTO 400
C         EXTRACT COMMENTS IN THE SPECIFIED LANGUAGE
C         Note: This is called before REPLAB
          IF (NLANG.GT.0.AND.IUSELNG1.NE.0)  THEN
            CALL LANGCMT(LLANG, LIDAT, IUSELNG1, IUSELNG2,
     *        NLANG, IDAT(IB), IE-IB+1, L)
            IE = IB + L - 1
          ENDIF
C         TEST FOR EMPTY COMMENT.
          IF (IEMPTYCMT(IDAT(IB), IE-IB+1).NE.0)  GOTO 400

          IF (IOA.NE.0 .AND. IOA.NE.3)  GO TO 110
          IF (IOA.EQ.0)  THEN
            IOTXT = JHD
            IF (ICHTXT.EQ.0) ICHTXT =
     *        ICHKFEAT (ICSTR(IAC), LCSTR, IFETO, LNKC, LINKC(IC),
     *        LSTCHO, IFOFSET(IC))
C     *        LSTCHO, IDAV, LIDAT)
C            CALL WFEAT (ICSTR, LCSTR, IDAV, LIDAT, LINKC, IREPS, IOMPD,
            CALL WFEAT (ICSTR, LCSTR, IFOFSET, LINKC, IREPS, IOMPD,
     *       NC, ITSHD, ITYPMK, LIDAT, IAC, IC, LNKC, IPCHN, JPARA, JHD,
     *       JIEMPF, JIEMPC, IEMPC(IC), IFETO, LSTCHO, IRSEMI, KCOM,
     *       ICHNSE, LASTXT, LPARATXT, LUNTYP)
            IOA = 1
C           EMPHASIZE STATE DESCRIPTIONS.
            IF (JIEMPS.NE.0)  THEN
              CALL JSTTPS (21, ITYPMK, LIDAT, NTYPMK, LUNTYP)
C             CALL ENDWD (LUNTYP)
              JITSET = 1
            ENDIF
          ENDIF
C          IF (IOA.EQ.3)  CALL WOR (IFCOM, IFOR, LASTG, KCOM, IOMFC(IC),
C     *     ITYPMK, LIDAT, LUNTYP)
          IF (IOA.EQ.3)  CALL WOR (IFCOM, IFOR, KCOM, ITYPMK, LIDAT,
     *      LUNTYP)
          IF (IRAB.EQ.0)  GO TO 120
          IF (NOTAPP.EQ.1)  GOTO 120
C         REMOVE ANGLE BRACKETS.
          CALL REPLAB (IDAT(IB), IE-IB+1, L, 1)
          IE = IB + L - 1
          GO TO 120
  110     IF (IRAB.EQ.0)  GO TO 120
          IF (NOTAPP.EQ.-1)  THEN
C           REMOVE ANGLE BRACKETS.
            CALL REPLAB (IDAT(IB), IE-IB+1, L, 1)
            IE = IB + L - 1
          ELSE
C           REPLACE ANGLE BRACKETS WITH PARENTHESES.
            CALL REPLAB (IDAT(IB), IE-IB+1, L, 2)
          ENDIF
  120     IF (JSTATOUT.NE.0) CALL ENDWD (LUNTYP)
          IF (IEMPTYCMT(IDAT(IB), IE-IB+1).EQ.0) THEN
            CALL JSTOTP (IDAT(IB), IE-IB+1, -1, ITYPMK, LIDAT,
     *        LUNTYP, 0, 0)
            JSTATOUT = 1
          ENDIF
          NOTAPP = 0
          IOA = 3
          GO TO 400
C-
  130     IF (ITS.GT.ITSS)  GO TO 300
          NOTAPP = 0
C         IEND = WHETHER TO CALL ENDWD
          IEND = 1
          IF (IOA.EQ.0)  THEN
            IOTXT = JHD
            IF (ICHTXT.EQ.0) ICHTXT =
     *        ICHKFEAT (ICSTR(IAC), LCSTR, IFETO, LNKC, LINKC(IC),
     *        LSTCHO, IFOFSET(IC))
C     *        LSTCHO, IDAV, LIDAT)
C           CHECK FOR PRESENCE OF SOME STATE TEXT.
            IF (ITYPC(IC).LE.2) THEN
              IALLSTAT = 0
              DO KK = 1, NSV
                IV = IDAT(JSG+1+KK)
                IS = IA1S(IV)
C               CHECK IF STATE TEXT EMPTY
                IALLSTAT = ICHKSTATE(ICSTR(IS), LCSTR)
                IF (IALLSTAT.NE.0)  GOTO 135
              ENDDO
            ELSE
              IALLSTAT = 1
            ENDIF
C  135       IF (ICHTXT.NE.0.OR.IALLSTAT.NE.0) THEN
  135       IF (IALLSTAT.NE.0) THEN
C              CALL WFEAT (ICSTR, LCSTR, IDAV, LIDAT, LINKC, IREPS, IOMPD,
              CALL WFEAT (ICSTR, LCSTR, IFOFSET, LINKC, IREPS,
     *          IOMPD, NC, ITSHD, ITYPMK, LIDAT, IAC, IC, LNKC, IPCHN,
     *          JPARA, JHD,
     *          JIEMPF, JIEMPC, IEMPC(IC), IFETO, LSTCHO, IRSEMI, KCOM,
     *          ICHNSE, LASTXT, LPARATXT, LUNTYP)
              IOA = 1
C             EMPHASIZE STATE DESCRIPTIONS.
              IF (JIEMPS.NE.0)  THEN
                CALL JSTTPS (21, ITYPMK, LIDAT, NTYPMK, LUNTYP)
C               CALL ENDWD (LUNTYP)
                JITSET = 1
              ENDIF
            ELSE
              IEND = 0
            ENDIF
          ENDIF

          IF (IOA.GE.1)  THEN
            LAST = 0
            IF (LASTG.EQ.1)  THEN
              IF (ITS.EQ.1.AND.ITYPC(IC).GE.3)  THEN
                LAST = 1
              ELSE IF (NSV.EQ.1)  THEN
                LAST = 1
              ENDIF
            ENDIF
C           TEST FOR EMPTY STATE TEXT.
            IF (ITYPC(IC).LE.2) THEN
              IV = IDAT(JSG+1+ISV)
              IS = IA1S(IV)
C             CHECK IF STATE TEXT EMPTY
              ISTAT = ICHKSTATE(ICSTR(IS), LCSTR)
            ELSE
              ISTAT = 1
            ENDIF
C           CHECK IF BOTH THIS AND PREVIOUS STATE OUTPUT.
            IF (JSTATOUT.NE.0.AND.ISTAT.NE.0) THEN
              CALL WOR (IFCOM, IFOR, KCOM, ITYPMK, LIDAT, LUNTYP)
            ELSE
              IEND = 0
            ENDIF
            IOA = 2
          ENDIF
          IF (IEND.NE.0) CALL ENDWD (LUNTYP)
 
C         NUMERIC RANGES.
          IF (ITS.EQ.1.AND.ITYPC(IC).GE.3)  THEN
            IF (NSV.LE.0) GOTO 400
            IF (IOMLO(IC).NE.0)  THEN
              CALL UPRRNG (ITYPC(IC), NDEC(IC), ITYPMK, LIDAT,
     *          IDAT(JSG+2), NSV, LUNTYP, 1)
            ELSE
              CALL DELRNG (ITYPC(IC), NDEC(IC), ITYPMK, LIDAT,
     *          IDAT(JSG+2), NSV, LUNTYP, 1)
            ENDIF
            JSTATOUT = 1
            ISV = NSV
            GOTO 210
          ENDIF
 
C         OTHER VALUES.
          ISV = 1
  150     IF (ISV.GT.NSV)  GO TO 400
 
            IF (ISV.LE.1)  GO TO 170
 
C           TEST FOR EMPTY STATE DESCRIPTION
            IF (ITYPC(IC).LE.2)  THEN
              IV = IDAT(JSG+1+ISV)
              IS = IA1S(IV)
              ISTAT = ICHKSTATE(ICSTR(IS), LCSTR)
            ELSE
              ISTAT = 1
            ENDIF
            IF (JSTATOUT.EQ.0 .OR. ISTAT.EQ.0)  GOTO 170
 
 
C-          LINK VALUES.
            IF (ITS.EQ.1)  THEN
C             LINK VALUES BY 'TO'.
              CALL ENDWD (LUNTYP)
              CALL JSTWD (2, 0, ITYPMK, LIDAT, LUNTYP)
           ELSE
C             LINK VALUES BY COMMA OR 'AND'.
              IF (NSV.EQ.2)  THEN
                CALL ENDWD (LUNTYP)
              ELSE
                IF (ISV.NE.NSV.OR.IOMFC(IC).EQ.0)  THEN
                  CALL JSTWD (KCOM, 0, ITYPMK, LIDAT, LUNTYP)
C                  CALL WPUNC (KCOM, 0, LUNTYP)
                ELSE
                  CALL ENDWD (LUNTYP)
                ENDIF
              ENDIF
C             IF (NSV.NE.2)  CALL WPUNC (KCOMMA, 0, LUNTYP)
              IF (ISV.EQ.NSV)  CALL JSTWD (3, 0, ITYPMK, LIDAT, LUNTYP)
            ENDIF
C
C-          SELECT VALUE, AND, IF NUMERIC, ENCODE AND OUTPUT.
  170       IF (ITYPC(IC).GE.4)  GOTO 200
            I = JSG + 1 + ISV
            IV = IDAT(I)
            IF (ITYPC(IC).EQ.3)  GO TO 180
            IS = IA1S(IV)
            GO TO 220
  180       CALL JSTI (IV, -1, LUNTYP)
            JSTATOUT = 1
            GO TO 210
  200       I = JSG + ISV + 1
            CALL JSTR (RELIN(IDAT(I)), NDEC(IC), -1, LUNTYP, 1)
            JSTATOUT = 1
 
  210       ICAP = 0
            IF (NSTAT(IC).LE.0)  GO TO 250
            IF (ISV.EQ.NSV)  THEN
              IF ((ITYPC(IC).EQ.3.OR.ITYPC(IC).EQ.4).AND.
     *             IOMUSP.NE.0.AND.IOUSP(IC).NE.0)  THEN
C               OMIT SPACE BEFORE UNITS.
                CONTINUE
              ELSE
                IS = IA1S(1)
                ISTAT = ICHKSTATE(ICSTR(IS), LCSTR)
                IF (ISTAT.NE.0)  CALL ENDWD (LUNTYP)
              ENDIF
            ENDIF
            IS = IA1S(1)
C
C-          OUTPUT STATE DESCRIPTION.
  220       IF (ISV.EQ.NSV .OR. NSTAT(IC).GT.1) THEN
              ISTAT = ICHKSTATE(ICSTR(IS), LSTR)
              IF (ISTAT.NE.0) THEN
                CALL WSENT (ICSTR(IS), LCSTR, 0, 0, 0, 0, -1, ITYPMK,
     *            LIDAT, LUNTYP)
                JSTATOUT = 1
              ENDIF
            ENDIF
C-
  250       ISV = ISV + 1
            GO TO 150
C
C-        PSEUDO-VALUES.
  300     IPS = ITS - ITSS
          GO TO (320,340,360), IPS
C
C         VARIABLE.
  320     IF (IOA.EQ.0)  THEN
            IOTXT = JHD
            IF (ICHTXT.EQ.0) ICHTXT =
     *        ICHKFEAT (ICSTR(IAC), LCSTR, IFETO, LNKC, LINKC(IC), 
     *        LSTCHO, IFOFSET(IC))
C     *        LSTCHO, IDAV, LIDAT)
C            CALL WFEAT (ICSTR, LCSTR, IDAV, LIDAT, LINKC, IREPS, IOMPD,
            CALL WFEAT (ICSTR, LCSTR, IFOFSET, LINKC, IREPS, IOMPD,
     *        NC, ITSHD, ITYPMK, LIDAT, IAC, IC, LNKC, IPCHN, JPARA,
     *        JHD, JIEMPF, JIEMPC, IEMPC(IC), IFETO, LSTCHO, IRSEMI, 
     *        KCOM, ICHNSE, LASTXT, LPARATXT, LUNTYP)
C           EMPHASIZE STATE DESCRIPTIONS.
            IF (JIEMPS.NE.0)  THEN
              CALL JSTTPS (21, ITYPMK, LIDAT, NTYPMK, LUNTYP)
C             CALL ENDWD (LUNTYP)
              JITSET = 1
            ENDIF
          ENDIF
          IF (IOA.GE.2)  THEN
            LAST = 0
            IF (LASTG.EQ.1.AND.ITYPC(IC).GE.3)  LAST = 1
C            CALL WOR (IFCOM, IFOR, LAST, KCOM, IOMFC(IC), ITYPMK, LIDAT,
C     *       LUNTYP)
            CALL WOR (IFCOM, IFOR, KCOM, ITYPMK, LIDAT, LUNTYP)
          ENDIF
          IOA = 2
          CALL ENDWD (LUNTYP)
          IF (ITYPC(IC).GE.3)  GO TO 330
          NS = NSTAT(IC)
          DO 324 IV = 1, NS
            IS = IA1S(IV)
            CALL WSENT (ICSTR(IS), LCSTR, 0, 0, 0, 0, -1, ITYPMK, LIDAT,
     *       LUNTYP)
            IF (IV.LT.NS)  THEN
              IF (IV.EQ.NS-1)  THEN
                LAST = 1
              ELSE
                LAST = 0
              ENDIF
C              CALL WOR (IFCOM, IFOR, LAST, KCOM, IOMFC(IC), ITYPMK, LIDAT,
C     *         LUNTYP)
              CALL WOR (IFCOM, IFOR, KCOM, ITYPMK, LIDAT, LUNTYP)
            ENDIF
  324     CONTINUE
          GO TO 400
  330     CALL JSTWD (4, -1, ITYPMK, LIDAT, LUNTYP)
          GO TO 400
C
C         UNKNOWN.
  340     IF (IOA.LE.1)  GO TO 400
C          CALL WOR (IFCOM, IFOR, LASTG, KCOM, IOMFC(IC), ITYPMK, LIDAT, LUNTYP)
          CALL WOR (IFCOM, IFOR, KCOM, ITYPMK, LIDAT, LUNTYP)
          IOA = 2
          CALL JSTWD (5, -1, ITYPMK, LIDAT, LUNTYP)
          GO TO 400
C
C         INAPPLICABLE.
  360     NOTAPP = -1
          IF (IOA.GT.0)  GO TO 365
          IF(LASTG.EQ.0.AND.JSG+IDAT(JSG).LT.JG+IDAT(JG))  THEN
            IOTXT = JHD
            IF (ICHTXT.EQ.0) ICHTXT =
     *        ICHKFEAT (ICSTR(IAC), LCSTR, IFETO, LNKC, LINKC(IC),
     *        LSTCHO, IFOFSET(IC))
C     *        LSTCHO, IDAV, LIDAT)
            IF (ICHTXT.NE.0) THEN
C              CALL WFEAT (ICSTR, LCSTR, IDAV, LIDAT, LINKC, IREPS, IOMPD,
              CALL WFEAT (ICSTR, LCSTR, IFOFSET, LINKC, IREPS,
     *          IOMPD, NC, ITSHD, ITYPMK, LIDAT,
     *          IAC, IC, LNKC, IPCHN, JPARA, JHD, JIEMPF, JIEMPC,
     *          IEMPC(IC), IFETO, LSTCHO, IRSEMI, KCOM, ICHNSE,
     *          LASTXT, LPARATXT, LUNTYP)
              IOA = 1
C             EMPHASIZE STATE DESCRIPTIONS.
              IF (JIEMPS.NE.0)  THEN
                CALL JSTTPS (21, ITYPMK, LIDAT, NTYPMK, LUNTYP)
C               CALL ENDWD (LUNTYP)
                JITSET = 1
              ENDIF
            ENDIF
          ENDIF
  365     IF (IOA.LE.1)  GO TO 400
  370     IF (IOA.GE.2 .AND.
     *     (JSG+IDAT(JSG).LT.JG+IDAT(JG).OR.ITINAP.EQ.1))
     *      CALL WOR (IFCOM, IFOR, KCOM, ITYPMK, LIDAT, LUNTYP)
C     *      CALL WOR (IFCOM, IFOR, LASTG, KCOM, IOMFC(IC), ITYPMK, LIDAT,
C     *       LUNTYP)
          IOA = 2
          IF (ITINAP.EQ.1)  THEN
            CALL JSTWD (6, -1, ITYPMK, LIDAT, LUNTYP)
            NOTAPP = 1
          ENDIF
C-
  400     JSG = JSG + IDAT(JSG)
          GO TO 105
C-
  490   CONTINUE
c       After all states and comments of this character have been processed.
        LASTXT = MAX(LASTXT, JSTATOUT)
        LASTXT = MAX(LASTXT, ICMTOUT)
        IF (JSTATOUT.NE.0.OR.ICMTOUT.NE.0)  THEN
          LSTCHO = IC
          LPARATXT = MAX0(LPARATXT, JSTATOUT)
C          LPARATXT = MAX0(LPARATXT, ICHTXT)
          LPARATXT = MAX0(LPARATXT, ICMTOUT)
          LPARATXT = MAX0(LPARATXT, IOTXT)
        ENDIF
        IF (JITSET.NE.0)
     *    CALL JSTTPS (22, ITYPMK, LIDAT, NTYPMK, LUNTYP)
 
  495   IF  (NOTOUTP.NE.0)  THEN
C         THIS SITUATION (I.E. NO DATA OUTPUT FOR THIS CHARACTER) WILL NOT
C         OUTPUT A NEW PARAGRAPH MARK WHEN REQUIRED, SO NEED TO PRETEND
C         PARAGRAPH HAS BEEN OUTPUT TO RESET STATUS, SO NEXT NEW PARAGRAPH
C         WILL PROCEED.
C         NOTE: LEAVE 'JPARA' FLAG AS IS.
          IF (IPARA(IC).NE.0)  LPARATXT = 1
        ENDIF
 

  500 CONTINUE
 
      IF (LASTXT.NE.0.AND.IFETO.NE.0.AND.IOMPD(LSTCHO).EQ.0)  THEN
C       COMPARE LAST ENTRY IN BUFFER WITH FULL STOP
        IF (CMPVCB(IOUT(1,LUNTYP), JIOUT(LUNTYP), KVSTOP).NE.0)  THEN
          CALL JSTWD (KVSTOP, 0, ITYPMK, LIDAT, LUNTYP)
C          CALL WPUNC (KVSTOP, 0, LUNTYP)
C       IF (IOUT(JIOUT(LUNTYP, LUNTYP).NE.KSTOP)  THEN
C         CALL WPUNC (KSTOP, 0, LUNTYP)
        ELSE
          CALL JSTS (KBLANK, 0, LUNTYP)
        ENDIF
      ENDIF
 
C     TYPESETTING MARK AFTER ITEM
      IF (ITPSET.GT.0)  CALL JSTTPS (27, ITYPMK, LIDAT, NTYPMK, LUNTYP)
 
      CALL ENDLN (LUNTYP)
      IF (ITPSET.LE.0.AND.LUNOUT.EQ.LUNL)  CALL BLKLIN (2, 0, LUNTYP)
C--
 2000 ICAP = 0
      IOMCAP = 0
 
      RETURN
      END
      FUNCTION NDIGIT(NUM)
C  Returns number of digits required to output an integer
C  Revised 24-FEB-98.
 
 
      I = 1
      M = IABS(NUM)
      DO WHILE (M.GE.10)
        I = I + 1
        M = M/10
      END DO
 
      IF (NUM.LT.0) I = I + 1
      NDIGIT = I
      RETURN
      END
C      SUBROUTINE RDSCRC(IA, LUN, IREC, NC)
C 
CC  REVISED 22-NOV-95.
CC  READS CHARACTER NUMBERS FROM A A SCRATCH FILE.
C 
CC  IA RETURNS THE CHARACTERS NUMBERS.
CC  LUN RECEIVES THE LOGICAL READ UNIT
CC  IREC RECEIVES THE RECORD LENGTH.
CC  NC RECEIVES THE NUMBER OF CHARACTERS.
C 
CC     Record length for scratch files containing sets of NC character numbers.
CC     Also used in S/R TCMASK to store information.
CC     Must be identical to the value of LRECSC in common block SCRCXX.
CC     (Need to use local buffer to avoid problems in ConforW where program may
CC     have more than one data segment. Using a local buffer and copying avoids
CC     problems(bug?) reading into array addresses > 64K)
C      PARAMETER(LRECSC=128)
C      DIMENSION IBUF(LRECSC)
C      DIMENSION IA(NC)
C 
C      N = NC
C      JREC = IREC
C      J = 0
C      DO WHILE (N.GT.0)
C        NREAD = MIN0(LRECSC, N)
C        READ(LUN, REC=JREC)(IBUF(I),I=1,NREAD)
C        DO I = 1, NREAD
C          J = J +1 
C          IA(J) = IBUF(I)
C        END DO
C        N = N - NREAD
C        JREC = JREC + 1
C      END DO
C 
C      RETURN
C      END
      SUBROUTINE REMNSC (IDAT, LIDAT, JIDAT)                                TNAT
 
C  REVISED 22-MAY-95.
C  REMOVES NESTED COMMENTS FROM WITHIN A COMMENT.
 
C  IDAT RETURNS THE COMMENT.
C  LIDAT RECEIVES THE LENGTH OF IDAT.
C  JIDAT RECEIVES AND RETURNS THE INDEX OF THE LAST ELEMENT OF IDAT
C    IN USE.
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
 
      DIMENSION IDAT(LIDAT)
 
      IDEPTH = 0
      I = 1
      J = 0
      DO WHILE (I.LE.LIDAT)
        IF (IDAT(I).EQ.KDLBRA)  THEN
          IF (I.EQ.1)  THEN
            GOTO 20
          ELSE
            IDEPTH = IDEPTH + 1
            IF (IDAT(I-1).EQ.KBLANK.AND.J.GT.1)  J = J - 1
            GOTO 100
          ENDIF
        ENDIF
        IF (IDAT(I).EQ.KDRBRA)  THEN
          IF (I.EQ.LIDAT)  THEN
C           REMOVE TRAILING BLANKS.
            DO WHILE (J.GT.1)
              IF (IDAT(J).NE.KBLANK)  GOTO 20
              J = J - 1
            END DO
            GOTO 20
          ELSE
            IDEPTH = IDEPTH - 1
            GOTO 100
          ENDIF
        ENDIF
   20   IF (IDEPTH.GT.0)  GOTO 100
C       ADD CHARACTER, BUT OMIT LEADING BLANKS.
        IF (J.GT.1.OR.IDAT(I).NE.KBLANK)  THEN
          J = J + 1
          IDAT(J) = IDAT(I)
        ENDIF
  100   I = I + 1
      END DO
 
      JIDAT = J
      RETURN
      END
      SUBROUTINE REPLAB(IDAT, LIDAT, JIDAT, IOPT)
 
C  REPLACES OR REMOVES ANGLES BRACKETS FROM TEXT.
C  REVISED 22-MAY-95.
 
C IDAT RECEIVES THE TEXT.
C LIDAT RECEIVES THE LENGTH OF IDAT.
C JIDAT RETURNS THE LENGTH OF THE ALTERED TEXT.
C IOPT RECEIVES THE OPTION. 1=REMOVE, 2=REPLACE WITH PARENTHESES.
 
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
 
      DIMENSION IDAT(LIDAT)
 
      JIDAT = 0
      DO 100 I = 1, LIDAT
        NEXTC = IDAT(I)
        IF (NEXTC.EQ.KDLBRA)  THEN
          IF (IOPT.EQ.1)  THEN
            GOTO 100
          ELSE
            NEXTC = KDLPAR
          ENDIF
        ELSE IF (NEXTC.EQ.KDRBRA)  THEN
          IF (IOPT.EQ.1)  THEN
            GOTO 100
          ELSE
            NEXTC = KDRPAR
          ENDIF
        ENDIF
        JIDAT = JIDAT + 1
        IDAT(JIDAT) = NEXTC
  100 CONTINUE
 
      RETURN
      END
      SUBROUTINE UPRRNG (JTYPC, NDEC, ITYPMK, LIDAT, IDAT, NVAL, LUNTYP,    INOU
     * IVDEC)
 
C  REVISED 13-MAY-94.
C  OUTPUTS THE UPPER END OF A NUMERIC RANGE FOR NATURAL LANGUAGE FORMAT.
C  THE OUTPUT IS OF THE FORM " X(-Y)" WHERE "(-Y)" IS PRESENT ONLY
C  IF EXTREME VALUES HAVE BEEN CODED.
 
C  JTYPC RECEIVES THE CHARACTER TYPE.
C  NDEC RECEIVES THE NUMBER OF DECIMAL PLACES REQUIRED ON OUTPUT.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  LIDAT RECEIVES THE LENGTH OF ITYPMK.
C  IDAT RECEIVES THE DATA.
C  NVAL RECEIVES THE LENGTH OF IDAT.
C  LUNTYP RECEIVES THE OUTPUT UNIT TYPE.
C  IVDEC RECEIVES WHETHER TO USE THE DECIMAL POINT DEFINED IN THE VOCABULARY.
 
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
 
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
 
      DIMENSION ITYPMK(LIDAT),IDAT(NVAL)
 
      IB = NVAL
      IE = NVAL
      IF (NVAL.GT.3)  THEN
        IF (IDAT(IE).NE.IDAT(IE-1))  IB = IE - 1
      ENDIF
 
C-    OUTPUT RANGES.
C     OUTPUT "to". Removed 13-may-94.
C     CALL JSTWD(2, 0, ITYPMK, LIDAT, LUNTYP)
      IFIRST = 1
      DO 200 I = IB, IE
        IPAR = 0
        IF (IFIRST.EQ.0)  THEN
          CALL JSTS (KDLPAR, -1, LUNTYP)
          CALL PRANGE (1, ITYPMK, LIDAT, LUNTYP)
        ENDIF
        IF (JTYPC.EQ.3)  THEN
          CALL JSTI (IDAT(I), -1, LUNTYP)
        ELSE
          CALL JSTR (RELIN(IDAT(I)), NDEC, -1, LUNTYP, IVDEC)
        ENDIF
        IF (IFIRST.EQ.0)  CALL JSTS (KDRPAR, -1, LUNTYP)
        IFIRST = 0
  200   CONTINUE
 
      RETURN
      END
C      SUBROUTINE WFEAT (ICSTR, LCSTR, IDES, LDES, LINKC, IREPS, IOMPD,      TNAT
      SUBROUTINE WFEAT (ICSTR, LCSTR, IFOFSET, LINKC, IREPS, IOMPD,         TNAT
     * NC, ITSHD, ITYPMK, LIDAT, IAC, IC, LNKC, IPCHN, JPARA, JHD,
     * JIEMPF, JIEMPC, IFEMPC, IFETO, LSTCHO, IRSEMI, KCOM, ICHNSE,
     * LASTXT, LPARATXT, LUNTYP)
 
C* REVISED 14-SEP-99.
C* PRINTS ITEM SUBHEADING, CHARACTER NUMBER, AND FEATURE.
 
C  ICSTR RECEIVES THE FEATURE DESCRIPTION.
C  LCSTR RECEIVES THE LENGTH OF ICSTR.
C  IDES RECEIVES WORKING SPACE USED TO SAVE THE DESCRIPTION OF THE FIRST
C   CHARACTER OF A LINKED LIST.
C  LDES RECEIVES THE LENGTH OF IDES.
C  LINKC RECEIVES FLAGS INDICATING WHICH GROUPS OF CHARACTERS ARE
C    TO BE LINKED IN THE DESCRIPTIONS.
C  IREPS RECEIVES CHARACTER GROUPS WHERE SEMICOLON IS TO BE REPLACED BY
C    COMMA AS A SEPARATOR.
C  IOMPD RECEIVES WHETHER TO OMIT THE FINAL PERIOD AFTER CHARACTER.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  ITSHD RECEIVES THE ITEM SUBHEADINGS (SEE SUBR. RDSENL).
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  LIDAT RECEIVES THE (MAXIMUM) LENGTH OF ITSHD, ITYPMK.
C  IAC RECEIVES THE LOCATION IN ICSTR OF THE FEATURE DESCRIPTION.
C  IC RECEIVES THE CHARACTER NUMBER.
C  LNKC RECEIVES WHETHER CHARACTERS ARE LINKED.
C  IPCHN RECEIVES 1 IF THE CHARACTER NUMBER IS TO BE PRINTED, ELSE 0.
C  JPARA RECEIVES AND RETURNS THE NEW-PARAGRAPH FLAG. IF JPARA IS 1,
C    A NEW PARAGRAPH IS STARTED, AND JPARA IS SET TO 0.
C  JHD RECEIVES THE LOCATION OF THE SUBHEADING, OR 0 IF NONE.
C    IT RETURNS 0.
C  JIEMPF RECEIVES 1 IF THE FEATURE IS TO BE EMPHASIZED, ELSE 0.
C    IT RETURNS 0.
C  JIEMPC RECEIVES 1 IF THE CHARACTER IS TO BE EMPHASIZED, ELSE 0.
C    IT RETURNS 0.
C  IFEMPC RECEIVES WHETHER THE CHARACTER WAS NAMED IN AN EMPHASIZE CHARACTERS
C    DIRECTIVE
C  IFETO RECEIVES AND RETURNS THE NUMBER OF THE LAST FEATURE PRINTED IN THE
C   CURRENT SENTENCE, WHERE A SENTENCE IS TERMINATED BY A FULL STOP, EXCEPT WHEN
C   THE STOP IS EXPLICITLY OMITTED BY THE "OMIT PERIOD ..." DIRECTIVE.
C  LSTCHO RECEIVES THE LAST CHARACTER OUTPUT.
C  IRSEMI RECEIVES WHETHER SEMICOLONS ARE TO BE REPLACED BY COMMAS.
C  KCOM RECEIVES THE CURRENT COMMA CHARACTER.
C  ICHNSE RECEIVES WHETHER CHINESE FORMAT IS SET.
C  LASTXT RECEIVES AND RETURNS WHETHER ANY CHARACTER OUTPUT SINCE LAST PUNCTUATION
C  LPARATXT RECEIVES AND RETURNS WHETHER OUTPUT HAS OCCURRED SINCE LAST NEW PARAGRAPH.
C  LUNTYP RECEIVES THE OUTPUT TYPE.
 
C      DIMENSION ICSTR(LCSTR),IDES(LDES),LINKC(NC),IREPS(NC),IOMPD(NC),
      DIMENSION ICSTR(LCSTR),IFOFSET(NC),LINKC(NC),IREPS(NC),IOMPD(NC),
     * ITSHD(LIDAT),ITYPMK(LIDAT)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
      COMMON /VLWXXX/ NVWD,MAXVWD,LVWD(18),IBPUNC,IEPUNC,
     * KVSTOP,KVCOM1,KVCOM2,KVSEMI,KVDEC
 
      DIMENSION JVAL(2)
 
C-    PRINT FULL STOP OR SEMICOLON AS REQUIRED.
      IF (JPARA.EQ.0 .AND. JHD.EQ.0 .AND. IFETO.NE.0 .AND. LNKC.GT.0
     * .AND. IFETO.EQ.LINKC(IC))  GO TO 10
      IF (IFETO.NE.0.AND.IOMPD(LSTCHO).EQ.0)  THEN
C       COMPARE LAST ENTRY IN BUFFER WITH FULL STOP
        IF (LASTXT.NE.0 .AND.
     *      CMPVCB(IOUT(1,LUNTYP), JIOUT(LUNTYP), KVSTOP).NE.0)  THEN
          CALL JSTWD (KVSTOP, 0, ITYPMK, LIDAT, LUNTYP)
C          CALL WPUNC (KVSTOP, 0, LUNTYP)
C       IF (IOUT(JIOUT(LUNTYP),LUNTYP).NE.KSTOP)  THEN
C         CALL WPUNC (KSTOP, 0, LUNTYP)
        ELSE
          CALL JSTS (KBLANK, 0, LUNTYP)
        ENDIF
      ENDIF
      IFETO = 0
      LASTXT = 0
      GO TO 20
   10 KSYM = KVSEMI
C  10 KSYM = KSEMIC
      IF (IRSEMI.GT.0.AND.IREPS(IC).GT.0.AND.IREPS(IC).EQ.IREPS(LSTCHO))
     * KSYM = KCOM
      IF (LASTXT.NE.0) CALL JSTWD (KSYM, 0, ITYPMK, LIDAT, LUNTYP)
      LASTXT = 0
C      CALL WPUNC (KSYM, 0, LUNTYP)
C
C-    SET UP NEW PARAGRAPH IF REQUIRED.
   20 IF (JPARA.EQ.0)  GO TO 50
      IF (ITPSET.GT.0)  THEN
        IOK = 1
CC       Compare new paragraph mark and item subheading to see if they contain
CC       the same typesetting marks. If so, don't output the new paragraph mark.
C        IF (JHD.GT.0) THEN
C          IOK = ICMPTYP (16, ITYPMK, LIDAT, NTYPMK, ITSHD(JHD), LIDAT)
C        ENDIF
        IF (IOK.GT.0)  THEN
          CALL ENDLN (LUNTYP)
          CALL JSTTPS (16, ITYPMK, LIDAT, NTYPMK, LUNTYP)
        ENDIF
      ELSE
        IF (ICHNSE.NE.0)  THEN
C         NO INTERPARAGRAPH SPACING. INDENTATION = 4.
          CALL ENDLN (LUNTYP)
          I = 4
        ELSE
          CALL BLKLIN (1, 2, LUNTYP)
          I = 6
        ENDIF
        CALL INDENT (I, LUNTYP)
      ENDIF
      JPARA = 0
      LPARATXT = 0
C
C-    PRINT SUBHEADING IF REQUIRED.
   50 IF (JHD.LE.0)  GO TO 60
C      ICAP = 1
      IF (ITPSET.GT.0)  CALL JSTTPS (32, ITYPMK, LIDAT, NTYPMK, LUNTYP)
      CALL WSENT (ITSHD(JHD), LIDAT, 0, 0, 0, 0, 0, ITYPMK, LIDAT,
     * LUNTYP)
      IF (ITPSET.GT.0)  CALL JSTTPS (33, ITYPMK, LIDAT, NTYPMK, LUNTYP)
      JHD = 0
C
C-    PRINT CHARACTER NUMBER IF REQUIRED.
   60 IF (IPCHN.EQ.0)  GO TO 100
      CALL JSTS (KLPAR, -1, LUNTYP)
      CALL JSTI (IC, -1, LUNTYP)
      CALL JSTS (KRPAR, 0, LUNTYP)
C
C-    PRINT FEATURE IF REQUIRED.
C     NOTE: SECOND PART OF TEST BELOW CHECKS FOR LINKED CHARACTERS WHERE
C     NO CHARACTER IN THE LINK RANGE HAS YET BEEN OUTPUT.
  100 IF (IFETO.EQ.0 .OR.
     *    (LNKC.GT.0.AND.IFETO.EQ.LINKC(IC).AND.LSTCHO.LT.IFETO))  THEN
        IOFFST = 0
        ICAP = 1
 
CC       RETAIN A COPY OF CHARACTER DESCRIPTION.
C        IF (ICSTR(IAC).GT.LDES)  THEN
CC         INSUFFICIENT MEMORY.
C          JVAL(1) = ICSTR(IAC)
C          JVAL(2) = LDES
C          CALL MESSB (85, JVAL, 2, -1, 0)
C        ELSE
C          CALL COPIA (ICSTR(IAC), IDES, ICSTR(IAC))
C        ENDIF
      ELSE
CC       COMPARE FIRST AND CURRENT CHARACTER DESCRIPTIONS.
C        CALL CMPCHR (IDES, LDES, ICSTR(IAC), LCSTR, IOFFST)
        IOFFST = IFOFSET(IC)
        IF (IOFFST.LT.0)  THEN
          GO TO 200
        ENDIF
        ICAP = 0
      ENDIF
C      IE = 0
      IE = -1
      IF (JIEMPF.NE.0)  THEN
        CALL JSTTPS (17, ITYPMK, LIDAT, NTYPMK, LUNTYP)
C       CALL ENDWD (LUNTYP)
        IE = -1
      ENDIF
      IF (JIEMPC.NE.0) THEN
C       NOTE: THE TEST BELOW DETERMINES -
C       1) IF THIS IS NOT REALLY AN EMPHASIZED CHARACTER AND
C       2) ONLY PART OF THE FEATURE IS BEING OUTPUT (I.E. IT IS NOT
C       REQUIRED AS THE FIRST FEATURE OF A LINKED LIST)
C       THEN DON'T EMPHASIZE.
        IF (IOFFST.NE.0.AND.IFEMPC.EQ.0)  THEN
          CONTINUE
        ELSE
          CALL JSTTPS (19, ITYPMK, LIDAT, NTYPMK, LUNTYP)
          IENDTYP = 20
          IE = -1
          IF (IOFFST.EQ.0.AND.IFOFSET(IC).GT.0) THEN
C           First character of a linked set. IOFFST specifies where to turn off
C           typesetting.
            IOFFST = -IFOFSET(IC)
          ENDIF
C        CALL ENDWD (LUNTYP)
        ENDIF
      ENDIF
      CALL WSENT (ICSTR(IAC), LCSTR, 0, IOFFST, IENDTYP, 0, IE,
     * ITYPMK, LIDAT, LUNTYP)
C     WAS ANY TEXT OUTPUT? DON'T NEED A BLANK SEPARATOR IF NO TEXT WAS OUTPUT.
      IFTEXT = ICHKSTATE (ICSTR(IAC), LCSTR)
      IF (JIEMPC.NE.0)  THEN
C       PRECEDING BLANK ADDED FOR RTF FORMAT. 9-SEP-94.
C        CALL ENDWD(LUNTYP) // REMOVED 28-JUL-98.
        IF (IENDTYP.NE.0) CALL JSTTPS (20, ITYPMK, LIDAT, NTYPMK,
     *    LUNTYP)
C       Only want to output one blank after feature, so do it here or in next
C       piece of code for an emphasized feature.
C        IF (JIEMPF.EQ.0.AND.IFTEXT.NE.0) CALL ENDWD(LUNTYP)
      ENDIF
      IF (JIEMPF.NE.0)  THEN
C       PRECEDING BLANK ADDED FOR RTF FORMAT. 9-SEP-94.
C        CALL ENDWD(LUNTYP) // REMOVED 28-JUL-98.
        CALL JSTTPS (18, ITYPMK, LIDAT, NTYPMK, LUNTYP)
C        IF (IFTEXT.NE.0) CALL ENDWD(LUNTYP)
      ENDIF
      IF (IFTEXT.NE.0) CALL ENDWD(LUNTYP)
      IFETO = IC
      IF (LNKC.GT.0.AND.LINKC(IC).NE.0)  IFETO = LINKC(IC)
      JIEMPF = 0
      JIEMPC = 0
C-

  200 RETURN
      END
      SUBROUTINE WALTNAME (IDAT, LDAT, ITYPMK, LIDAT, ITYPST, IE,          TNAT
     * JTYPMK, LUNTYP)
 
C* REVISED 26-OCT-00.
C* WRITES THE ALTERNATE TAXON NAME (AS SPECIFIED BY THE "CHARACTER FOR TAXON NAME"
C   DIRECTIVE) FOR NATURAL-LANGUAGE DESCRIPTIONS.
C
C  IDAT RECEIVES THE NAME (SEE SUBR. SENTNC).
C  LDAT RECEIVES THE LENGTH OF IDAT.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  LIDAT RECEIVES THE LENGTH OF ITYPMK.
C  ITYPST RECEIVES -1 IF TYPESETTING INSTRUCTIONS ARE TO BE OMITTED,
C    0 OR 1 OTHERWISE. (VALUE MAY BE DIFFERENT FROM VALUE IN TPSXXX, IF
C    TYPESETTING INSTRUCTIONS HAVE ALREADY BEEN OMITTED.)
C  IE RECEIVES A FLAG SPECIFYING THE ACTION AFTER OUTPUT.
C    NEGATIVE - LAST WORD LEFT UNFINISHED. 0 - LAST WORD FINISHED.
C    POSITIVE - LINE FINISHED, AND (IE-1) EXTRA BLANK LINES.
C  JTYPMK RECEIVES THE NO. OF THE TYPESETTING MARK TO PRECEED THE TAXON NAME.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT FOR OUTPUT.
 
      DIMENSION IDAT(LDAT),ITYPMK(LIDAT)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /INIXXX/ JI,JT,JIM,IVARIT,MASTIN,MISTOP
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
 
      JTYP = 0
      KTYP = 0
C     IVOUT = whether word 'variant' output.
      IVOUT = 0
      JSG = 2
   10 IF (JSG.GT.IDAT(1))  GO TO 50
        IB = JSG + 2
        L = IDAT(JSG) - 2
C       IGNORE ANGLE BRACKETS
        IB = IB + 1
        L = L - 2
C       TYPSET MARK BEFORE TAXON NAME
        IF (ITYPST.GT.0 .AND. JTYP.EQ.0)  THEN
          CALL JSTTPS (JTYPMK, ITYPMK, LIDAT, NTYPMK, LUNTYP)
          JTYP = 1
        ENDIF
C       Variant item? Output word 'variant' from vocabulary.
        IF (IVOUT.EQ.0.AND.IVARIT.NE.0 .AND. MASTIN.NE.0) THEN
          ICAP = 1
          CALL JSTWD (7, 0, ITYPMK, LIDAT, LUNTYP)
          IVOUT = 1
        ENDIF
        CALL JSTOTP (IDAT(IB), L, 0, ITYPMK, LIDAT, LUNTYP, 0, 0)
        JSG = JSG + IDAT(JSG)
      GO TO 10
 
C     TYPSET MARK AFTER TAXON NAME
   50 IF (JTYP.NE.0)  CALL JSTTPS (15, ITYPMK, LIDAT, NTYPMK, LUNTYP)
      IF (IE.GE.0)  CALL JSTS (KBLANK, IE, LUNTYP)
      IF (IDAT(1).EQ.1.AND.IE.GT.0)  CALL BLKLIN (1, 0, LUNTYP)
      RETURN
      END
      SUBROUTINE WNAME (ISEN, LSEN, ITYPMK, LIDAT, ICOMM, ITYPST, IE,       TNAT
     * JTYPMK, LUNTYP)
 
C* REVISED 26-OCT-00.
C* WRITES THE TAXON NAME FOR NATURAL-LANGUAGE DESCRIPTIONS.
C
C  ISEN RECEIVES THE NAME (SEE SUBR. SENTNC).
C  LSEN RECEIVES THE LENGTH OF ISEN.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  LIDAT RECEIVES THE LENGTH OF ITYPMK.
C  ICOMM RECEIVES 0 IF COMMENTS ARE TO BE OMITTED, 1 IF COMMENTS ARE TO
C    BE OUTPUT WITH ANGLE BRACKETS, 2 IF COMMENTS ARE TO BE OUTPUT
C    WITHOUT ANGLE BRACKETS.
C  ITYPST RECEIVES -1 IF TYPESETTING INSTRUCTIONS ARE TO BE OMITTED,
C    0 OR 1 OTHERWISE. (VALUE MAY BE DIFFERENT FROM VALUE IN TPSXXX, IF
C    TYPESETTING INSTRUCTIONS HAVE ALREADY BEEN OMITTED.)
C  IE RECEIVES A FLAG SPECIFYING THE ACTION AFTER OUTPUT.
C    NEGATIVE - LAST WORD LEFT UNFINISHED. 0 - LAST WORD FINISHED.
C    POSITIVE - LINE FINISHED, AND (IE-1) EXTRA BLANK LINES.
C  JTYPMK RECEIVES THE NO. OF THE TYPESETTING MARK TO PRECEED THE TAXON NAME.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT FOR OUTPUT.
 
      DIMENSION ISEN(LSEN),ITYPMK(LIDAT)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /INIXXX/ JI,JT,JIM,IVARIT,MASTIN,MISTOP
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
 
      JTYP = 0
      KTYP = 0
      JSG = 2
C     IVOUT = whether word 'variant' output.
      IVOUT = 0
   10 IF (JSG.GT.ISEN(1))  GO TO 50
        IF (ICOMM.NE.0 .OR. ISEN(JSG+1).NE.0) THEN
C          IF (JSG.GT.2)  CALL ENDWD (LUNTYP)
          IB = JSG + 2
          L = ISEN(JSG) - 2
          IF (ISEN(JSG+1).EQ.0 .AND. ICOMM.EQ.2) THEN
            IB = IB + 1
            L = L - 2
          ENDIF
C         TYPSET MARK BEFORE TAXON NAME
          IF (ITYPST.GT.0 .AND. JTYP.EQ.0)  THEN
            CALL JSTTPS (JTYPMK, ITYPMK, LIDAT, NTYPMK, LUNTYP)
            JTYP = 1
          ENDIF
C         Variant item? Output word 'variant' from vocabulary.
          IF (IVOUT.EQ.0.AND.IVARIT.NE.0 .AND. MASTIN.NE.0) THEN
            ICAP = 1
            CALL JSTWD (7, 0, ITYPMK, LIDAT, LUNTYP)
            IVOUT = 1
          ENDIF
          IF (JTYP.EQ.1 .AND. ISEN(JSG+1).NE.0)  THEN
C           TYPSET MARK BEFORE NON-COMMENT SECTION OF A TAXON NAME
            CALL JSTTPS (25, ITYPMK, LIDAT, NTYPMK, LUNTYP)
            KTYP = 1
          ENDIF
C         NEED TO SEPARATE THIS PART OF THE NAME FROM NEXT PART?
C         INSERT SEPARATOR BEFORE CLOSING TYPSET MARK - IF APPLICABLE.
          JENDWD = -1
          IF (JSG+ISEN(JSG).LE.ISEN(1)) JENDWD = 0
          CALL JSTOTP (ISEN(IB), L, JENDWD, ITYPMK, LIDAT, LUNTYP, 0, 0)
          IF (KTYP.EQ.1)  THEN
C           TYPSET MARK AFTER NON-COMMENT SECTION OF A TAXON NAME
            CALL JSTTPS (26, ITYPMK, LIDAT, NTYPMK, LUNTYP)
            KTYP = 0
          ENDIF
        ENDIF
        JSG = JSG + ISEN(JSG)
      GO TO 10
 
C     TYPSET MARK AFTER TAXON NAME
   50 IF (JTYP.NE.0)  CALL JSTTPS (15, ITYPMK, LIDAT, NTYPMK, LUNTYP)
      IF (IE.GE.0)  CALL JSTS (KBLANK, IE, LUNTYP)
      IF (ISEN(1).EQ.1.AND.IE.GT.0)  CALL BLKLIN (1, 0, LUNTYP)
      RETURN
      END
C      SUBROUTINE WOR (IFCOM, IFOR, LAST, KCOM, IOMFC, ITYPMK, LIDAT, LUNTYP)       TNAT
      SUBROUTINE WOR (IFCOM, IFOR, KCOM, ITYPMK, LIDAT, LUNTYP)             TNAT
 
C* REVISED 10-MAR-93.
C* LINKS ALTERNATIVES WITH 'OR' IN NATURAL-LANGUAGE DESCRIPTIONS.
 
C  IFCOM RECEIVES WHETHER TO INSERT A COMMA BEFORE THE "OR".
C  IFOR RECEIVES WHETHER TO INSERT "OR". 0=NO, 1=YES.
C  ILAST RECEIVES WHETHER THE LAST STATE IS TO FOLLOW.
C  KCOM RECEIVES THE COMMA CHARACTER TO BE USED.
C  IOMFC RECEIVES WHETHER THE FINAL COMMA IS TO BE OMITTED.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  LIDAT RECEIVES THE LENGTH OF ITYPMK.
C  LUNTYP RECEIVES THE OUTPUT TYPE.
 
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
 
      DIMENSION ITYPMK(LIDAT)
 
C      IF (IFOR.EQ.0.OR.LAST.EQ.0.OR.IOMFC.EQ.0)  THEN
C        CALL JSTWD (KCOM, 0, ITYPMK, LIDAT, LUNTYP)
CC        CALL WPUNC (KCOM, 0, LUNTYP)
C      ELSE
C        CALL ENDWD (LUNTYP)
C      ENDIF
C     CALL WPUNC (KCOMMA, 0, LUNTYP)
 
      IF (IFCOM.NE.0)  THEN
        CALL JSTWD (KCOM, 0, ITYPMK, LIDAT, LUNTYP)
      ELSE
        CALL ENDWD (LUNTYP)
      ENDIF
      IF (IFOR.NE.0)  CALL JSTWD (1, 0, ITYPMK, LIDAT, LUNTYP)
C      IF (IFOR.NE.0)  CALL JSTWD (1, 0, ITYPMK, LIDAT, LUNTYP)
 
   30 RETURN
      END
C      SUBROUTINE WPUNC (K, IE, LUNTYP)                                      TNAT
C 
CC  REVISED 4-MAY-92.
CC  OUTPUTS A PUNCTUATION SYMBOL VIA JSTS.
C 
CC  K RECEIVES THE INDEX IN THE VOCABULARY OF THE SYMBOL TO BE OUTPUT.
CC  IE RECEIVES A FLAG SPECIFYING THE ACTION AFTER OUTPUT.
CC    NEGATIVE - LAST WORD LEFT UNFINISHED. 0 - LAST WORD FINISHED.
CC    POSITIVE - LINE FINISHED, AND (IE-1) EXTRA BLANK LINES.
CC  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT FOR OUTPUT.
C 
C      COMMON /BLKXXX/ KBLANK
C      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
C     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
C      COMMON /VWDXXX/ VWORD(18)
C        CHARACTER*40 VWORD
C      COMMON /VLWXXX/ NVWD,MAXVWD,LVWD(18),IBPUNC,IEPUNC,
C     * KVSTOP,KVCOM1,KVCOM2,KVSEMI,KVDEC
C 
C      IF (IOUT(JIOUT(LUNTYP),LUNTYP).EQ.KBLANK)
C     *  JIOUT(LUNTYP) = JIOUT(LUNTYP) - 1
C 
C      IEND = -1
C      DO I = 1, LVWD(K)
C        IF (I.EQ.LVWD(K))  IEND = IE
C        CALL JSTS (ICHAR(VWORD(K)(I:I)), IEND, LUNTYP)
C      END DO
C 
C      RETURN
C      END
