      LOGICAL FUNCTION ADDDIR(NAME)
 
C  REVISED 2-SEP-99.
C  ATTEMPTS TO CREATE NEW DIRECTORY USING NAME. RETURNS TRUE IF SUCCESSFUL.
 
C  NAME RECEIVES THE DIRECTORY NAME.
      use clib
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
 
      CHARACTER*(*) NAME
C      LOGICAL ISADIR
      LOGICAL DIREXISTS
      
      ADDDIR = .FALSE.
      DO ILEN = LEN(NAME), 1, -1
         IF (NAME(ILEN:ILEN).NE.CHAR(KBLANK)) GOTO 10
      ENDDO
      
   10 IF (ILEN.LE.0) GOTO 1000
        IF (NAME(ILEN:ILEN).EQ.CHAR(KDBSLSH).AND.
     *       ILEN.GT.1) ILEN = ILEN - 1
	
 
C     Find beginning of directory name taking into account UNC file names
C     of the form \\machine_name\...
      IB = 2
      IF (NAME(1:1).EQ.CHAR(KDBSLSH).AND.
     *    NAME(2:2).EQ.CHAR(KDBSLSH)) THEN
   14   IB = IB + 1
c        IF (IB.GT.ILEN)  GOTO 30
        IF (IB.GT.ILEN)  GOTO 1000
        IF (NAME(IB:IB).EQ.CHAR(KDBSLSH)) THEN
          IB = IB + 1
c          GOTO 15
          GOTO 1000
        ENDIF
        GOTO 14
      ENDIF
 
   15 DO 20 JLEN = IB, ILEN - 1
        IF (NAME(JLEN:JLEN).EQ.CHAR(KDBSLSH)) THEN
          IF (NAME(JLEN-1:JLEN-1).EQ.CHAR(KDCOLN)) GOTO 20
          IF (DIREXISTS(NAME, JLEN-1)) GOTO 20
          IF (MKDIR(NAME(:JLEN-1)//CHAR(0)).EQ.0) GOTO 20
          GOTO 1000
        ENDIF
   20 CONTINUE

   30 IF (MKDIR(NAME(:ILEN)//CHAR(0)).EQ.0) ADDDIR = .TRUE.
	
1000  RETURN
      END
      SUBROUTINE ARROW (IPOINT, LUNTYP)                                     INOU
C
C  REVISED 23/4/86.
C  PRINTS ARROW.
C
C  IPOINT RECEIVES THE POSITION OF THE ARROW.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT FOR OUTPUT.
C
      COMMON /BLKXXX/ KBLANK
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /INQXXX/ ISEQ,SEQ,LIBUF,MIREC,LISIND,LLUNI,JLIS,LISOUT(132)
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
      COMMON /UNUXXX/ ILUNU
C
      DIMENSION MBUF(132)
 
      JPOINT = LISIND + MIN0(MAX0(IPOINT,0),JEDAT)
      DO 10 I = 1, JPOINT
   10   MBUF(I) = KBLANK
      MBUF(JPOINT) = KPOINT
      IF (ILUNU.EQ.0)  CALL WRTREC (MBUF(1), JPOINT, LUNTYP, 3)
      IF (ILUNU.NE.0)  CALL WREC (MBUF(1), JPOINT, LUNE)
      RETURN
      END
      SUBROUTINE BLKLIN (NLBL, NLGR, LUNTYP)                                INOU
 
C* REVISED 23-SEP-92.
C* FINISHES OUTPUT LINE, AND OUTPUTS BLANK LINES.
C
C  NLBL RECEIVES THE NUMBER OF BLANK LINES TO BE WRITTEN.
C  NLGR RECEIVES THE MINIMUM NUMBER OF ADDITIONAL LINES WHICH MUST
C    FIT ON THE CURRENT PAGE.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT.
C
C  BLANK LINES ARE ABSORBED AT THE TOP OF A NEW PAGE.
 
C     NUMBER OF LOGICAL UNITS IN LUNXXX.
      PARAMETER (NU=15)                                                       =*
 
      DIMENSION LU(NU)
 
      COMMON /BINXXX/ IENDRC,LENDRC,INSBLK
      COMMON /BLKXXX/ KBLANK
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
 
      EQUIVALENCE (LU(1),LUNE)
 
      LUN = LU(LUNTYP)
 
C     WHETHER TO TERMINATE BINARY RECORD.
      IF (LUNTYP.EQ.3)  IEND = 1
 
C--   OUTPUT NON-EMPTY LINE IF NECESSARY.
      IF (JIOUT(LUNTYP).LE.0 .AND. IENDWD(LUNTYP).LT.0)  GO TO 20
      IF (LWIDTH(LUNTYP).EQ.0)  THEN
C       BINARY FILE.
        CONTINUE
      ELSE
C       ORDINARY FILE.
        IF (JIOUT(LUNTYP).LE.0)  THEN
C         PUT BLANK IN BUFFER.
          IOUT(1,LUNTYP) = KBLANK
          JIOUT(LUNTYP) = 1
        ENDIF
      ENDIF
C     OUTPUT BUFFER.
   10 IENDRC = IEND
      CALL WRTREC (IOUT(1,LUNTYP), JIOUT(LUNTYP), LUNTYP, 5)
C
C--   OUTPUT BLANK LINES IF NECESSARY.
   20 IF (LWIDTH(LUNTYP).EQ.0)  THEN
        JIOUT(LUNTYP) = 0
      ELSE
        IOUT(1,LUNTYP) = KBLANK
        JIOUT(LUNTYP) = 1
      ENDIF
      IF (LUNPAG(LUN).EQ.0 .OR.
     * LUNREC(LUN).GT.LPRINT .OR. LUNREC(LUN)+NLBL+NLGR.LE.LPRINT)  THEN
        DO 30 I = 1, NLBL
          IENDRC = IEND
          CALL WRTREC (IOUT(1,LUNTYP), JIOUT(LUNTYP), LUNTYP, 5)
   30     CONTINUE
      ELSE IF (LUNREC(LUN).LE.0)  THEN
        CONTINUE
      ELSE
        LUNREC(LUN) = LPRINT
      ENDIF
C
C--
      JIOUT(LUNTYP) = 0
      IENDWD(LUNTYP) = -1
      RETURN
      END
      SUBROUTINE BMESS                                                      INOU
C
C  REVISED 14/2/84.
C  PREPARES FOR SINGLE-LINE MESSAGE DONE WITH FORTRAN WRITE.
C
      CALL BLKLIN (1, 3, 1)
C?    IF (LUNREC(LUNE).EQ.1)  CALL BLKLIN (1, 0, 1)
      RETURN
      END
      SUBROUTINE BUG (NBUG, IVALUE)                                         INOU
 
C* REVISED 22-SEP-92.
C* DUMPS INFORMATION AFTER DISCOVERY OF A PROGRAM BUG.
 
C  NBUG RECEIVES A NUMBER IDENTIFYING THE BUG.
C    1 - WASC
C    2 - CONPHR
C    3 - NOT USED
C    4 - SENSIM
C    5 - JSTOUT
C    6 - WSENT
C    7 - INKOD
C    8 - RNKOD
C    9,10 - JSTWD
C    11 - RNKOD
C    12 - TYPEP
C    13 - ATOH
C    14-20 - NOT USED
C    21,22 - JSTTPS
C    23 - DELTC
C    24,25 - PUTWD
C    26 - EMESS
C    27 - LSTR
C    28 - WMESS
C    29 - COPIAS
C    30 - COPSIA
C    31 - MESS
C    32 - RDDAI
C  IVALUE RECEIVES A VALUE TO BE PRINTED.
 
      COMMON /LUFXXX/ FNAME(19),LFNAME(19)
        CHARACTER FNAME*80
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
 
      DIMENSION IVAL(2)
      CHARACTER*100 MESS
 
      IVAL(1) = NBUG
      IVAL(2) = LUNREC(LUNI)
      L = LFNAME(LUNI)
      CALL PMESSC (120, IVAL, 2, FNAME(LUNI)(1:L), L, 1, MESS, LMESS)
C      WRITE (LUNE, '(A)') MESS(1:LMESS)
C      WRITE (LUNE, 3) IVALUE, IVALUE
C    3 FORMAT (I20/ 10X, A10)
      CALL WRECS (MESS, LMESS, LUNE)
      WRITE(MESS,'(I20)') IVALUE
      CALL WRECS (MESS, LMESS, LUNE)
      CALL MESSA (82, 0, 0)
 
      CALL PSTOP (1)
      END
      SUBROUTINE CARDI (IBF, ICARD)                                         INOU
C
C* REVISED 10/7/87.
C  READS A FIXED-FORMAT CARD IMAGE.
C
C  IBF RETURNS THE CARD IMAGE.
C  ICARD RETURNS -1 IF A STAR (KDSTAR) IS THE FIRST NON-BLANK SYMBOL
C    ON THE CARD, OTHERWISE THE POSITION OF THE LAST NON-BLANK
C    SYMBOL ON THE CARD.
C
      DIMENSION IBF(80)
C
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /INQXXX/ ISEQ,SEQ,LIBUF,MIREC,LISIND,LLUNI,JLIS,LISOUT(132)
C
C     READ CARD.
      JSEQ = ISEQ
      ISEQ = 0
      CALL RDBUF
      JE = MIN0(JEDAT,80)
      ICARD = JE
C
C     CHECK CONTENTS.
      IF (JE.LT.1)  GO TO 150
      DO 20 I = 1, JE
        IF (IBUF(I).NE.KBLANK)  GO TO 40
   20   CONTINUE
      GO TO 100
   40 IF (IBUF(I).NE.KDSTAR)  GO TO 100
      ICARD = -1
      JE = 0
      GO TO 150
C
C     COPY AND BLANK FILL.
  100 CALL COPIA (IBUF, IBF, JE)
  150 IF (JE.LT.80) CALL SETIA (IBF(JE+1), 80-JE, KBLANK)
      ISEQ = JSEQ
 
      RETURN
      END
C      SUBROUTINE CARDO (JOUT)                                              INOU
C 
CC  REVISED 14-MAR-91.
CC  OUTPUTS A CARD.
C 
CC  JOUT RECEIVES THE POSITION OF THE LAST CHARACTER ON THE CARD,
CC    AND RETURNS 0.
CC
CC  THE CARD IMAGE IS CONTAINED IN IOUT(1,4).
CC    IF PSEQ IS POSITIVE, IT IS INCREMENTED BY SEQINC AND ENCODED
CC    IN COLUMNS 73-80. JIOUT(4) IS SET TO 0.
CC
C      COMMON /BLKXXX/ KBLANK
C      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
C     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
CC
C      IF (JOUT.LE.0) GO TO 100
C      IF (PSEQ.LE.0.) GO TO 20
C      IF (JOUT.LT.72) CALL SETIA (IOUT(JOUT+1,4), 72-JOUT, KBLANK)
C      PSEQ = PSEQ + SEQINC
C      CALL SNKOD (PSEQ, 2, IOUT(73, 4), 8, 0)
C      JOUT = 80
CC
C   20 CALL WRTREC (IOUT(1,4), JOUT, 4, 4)
CC
C  100 JOUT = 0
C      JIOUT(4) = 0
C      RETURN
C      END
      SUBROUTINE CHECKO (LUN, MBUF)                                         INOU
 
C* REVISED 1-AUG-89.
C* CHECKS THAT OUTPUT FILE HAS BEEN SPECIFIED.
 
C  LUN RECEIVES THE LOGICAL UNIT OF THE OUTPUT FILE.
C  MBUF RECEIVES TEXT TO BE INSERTED IN THE ERROR MESSAGE.
 
      CHARACTER*(*) MBUF
      CHARACTER*12  M
 
      IF (LUN.LE.0) THEN
C       (CONCATENATION OF CHARACTER*(*) NOT ALLOWED IN MS FORTRAN 4.0.)
        M = MBUF
        LM = LSTRB(M)
        CALL MESSC (117, IDUM, 1, -1, 0, M(1:LM), LM, 1)
      ENDIF
 
      RETURN
      END
      LOGICAL FUNCTION CHKDIRY (DIRNAME, LDIR)
 
C     REVISED 18-SEP-98.
C     CHECKS IF A SPECIFIED DIRECTORY EXISTS. IF NOT, ATTEMPTS TO CREATE IT.
C     RETURNS IF THE DIRECTORY EXISTS.
 
C     DIRNAME RECEIVES THE DIRECTORY NAME.
C     LDIR RECEIVES THE LENGTH OF THE DIRECTORY NAME.
 
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
 
      CHARACTER*(*) DIRNAME
      LOGICAL ADDDIR, DIREXISTS
      CHARACTER*80 F,S

 
      F = DIRNAME(1:LDIR)
      LF = LDIR
      IF (F(LF:LF).NE.CHAR(KDBSLSH))  THEN
        LF = LF + 1
        F(LF:LF) = CHAR(KDBSLSH)
      ENDIF
C     MAKE INTO A FILENAME BEFORE CALL TO EXNAME
      F(LF+1:LF+1) = CHAR(KDSTOP)
 
C     THE CALL BELOW IS REQUIRED TO FILL OUT RELATIVE PATHNAMES IN WINDOWS VERSION
      CALL EXNAME(F, S)
      LF = LSTRB(F)
C     REMOVE '.' FROM NAME
      LF = LF - 1
 
      CHKDIRY = .FALSE.
      IF (DIREXISTS(F, LF))  THEN
        CHKDIRY = .TRUE.
      ELSE
        IF (ADDDIR(F(1:LF)))  CHKDIRY = .TRUE.
      ENDIF
 
      RETURN
      END
      SUBROUTINE CONPHR (ICONPH, LCPH, NCPH, NSIG, IBUF, JBUF, JL,          INOU
     * ICPH, JE)
C
C  REVISED 15/4/86.
C  DETERMINES THE NUMBER ASSOCIATED WITH A CONTROL PHRASE.
C
C  ICONPH, DIMENSIONED (LCPH,NCPH), RECEIVES THE LIST OF CONTROL
C    PHRASES. ICONPH(1,ICPH) TO ICONPH(LCPH,ICPH) CONTAIN THE ICPH-TH
C    CONTROL PHRASE. EACH WORD OF THE PHRASE IS REPRESENTED BY ITS
C    FIRST NSIG LETTERS (FILLED OUT WITH BLANKS IF THE WORD IS SHORTER
C    THAN NSIG).
C    THUS, A PHRASE MAY CONTAIN AT MOST (LCPH+NSIG-1)/NSIG WORDS.
C    IF THE NUMBER OF WORDS IN THE PHRASE IS LESS THAN THIS, THE
C    REMAINING ELEMENTS OF ICONPH MUST BE FILLED OUT WITH BLANKS.
C    EACH CONTROL PHRASE MUST HAVE A DISTINCT REPRESENTATION ON
C    THE LIST. REPRESENTATIONS DIFFERING ONLY BY HAVING BLANKS
C    INSTEAD OF NON-BLANKS IN SOME ELEMENTS ARE NOT DISTINCT.
C  LCPH RECEIVES THE NUMBER OF ELEMENTS RESERVED IN ICONPH FOR THE
C    REPRESENTATION OF EACH CONTROL PHRASE. IT MUST NOT BE GREATER THAN
C    THE LENGTH OF THE LOCAL ARRAY JCONPH.
C  NCPH RECEIVES THE NUMBER OF CONTROL PHRASES IN ICONPH.
C  NSIG RECEIVES THE NUMBER OF SIGNIFICANT SYMBOLS IN EACH WORD OF
C    THE CONTROL PHRASE.
C  IBUF RECEIVES THE ARRAY TO BE TESTED FOR THE PRESENCE OF A CONTROL
C    PHRASE. IBUF SHOULD CONTAIN ONE SYMBOL PER ARRAY ELEMENT.
C  JBUF RECEIVES THE POSITION IN IBUF OF THE START OF THE FIELD WHICH
C    WILL BE SCANNED FOR THE CONTROL PHRASE.
C  JL RECEIVES THE POSITION IN IBUF OF THE END OF THE FIELD WHICH
C    WILL BE SCANNED FOR THE CONTROL PHRASE.
C  ICPH RETURNS THE NUMBER OF THE CONTROL PHRASE, OR 0 IF THE PHRASE IS
C    INVALID.
C  JE. IF THE CONTROL PHRASE IS VALID, JE RETURNS THE POSITION IN IBUF
C    IMMEDIATELY AFTER THE END OF THE PHRASE. IF IT IS INVALID, JE
C    RETURNS THE POSITION OF THE FIRST INVALID SYMBOL, OR, IF THE FIELD
C    WAS EXHAUSTED BEFORE FINDING A VALID PHRASE, JL+1.
C
C  JBUF MUST NOT BE GREATER THAN JL.
C  THE PHRASE MAY BE PRECEDED BY BLANKS.
C
      CHARACTER*1 ICONPH(LCPH,NCPH)
      DIMENSION IBUF(JL),JCONPH(12)                                           =*
C
      COMMON /BLKXXX/ KBLANK
C
      IF (LCPH.LT.1.OR.LCPH.GT.12.OR.JL.LT.1                                  =*
     * .OR.NSIG.LT.1.OR.NSIG.GT.LCPH)  CALL BUG (2, JBUF)
      DO 10 I = 1, LCPH
   10   JCONPH(I) = KBLANK
      ISIG = 1
      JCW = 1
      ICPH = 1
      JF = JBUF
      IF (JBUF.GT.JL) GOTO 300
C
C-    SKIP OVER BLANKS.
   12 IF (JF.GT.JL)  GO TO 300
        IF (IBUF(JF).NE.KBLANK)  GO TO 20
        JF = JF + 1
        GO TO 12
C
C--   TEST FOR CONTROL PHRASE.
   20 JCONPH(JCW) = IBUF(JF)
C
C-      LOOK FOR MATCH OF LETTERS CONSIDERED SO FAR.
   30   DO 40 I = 1, JCW
            IF (JCONPH(I).NE.ICHAR(ICONPH(I,ICPH)))  GO TO 60
   40       CONTINUE
          DO 50 I = 1, LCPH
            IF (JCONPH(I).NE.ICHAR(ICONPH(I,ICPH)))  GO TO 100
   50       CONTINUE
          GO TO 500
   60     IF (ICPH.GE.NCPH)  GO TO 300
          ICPH = ICPH + 1
          GO TO 30
C
C-      PARTIAL MATCH FOUND, BUT NOT COMPLETE MATCH.
C-      POSITION POINTERS FOR NEXT SIGNIFICANT LETTER IN PHRASE.
  100   IF (ISIG.GE.NSIG)  GO TO 150
C       NEXT LETTER IS SIGNIFICANT (UNLESS FIELD IS EXHAUSTED).
        IF (IBUF(JF).EQ.KBLANK)  GO TO 200
        JF = JF + 1
        IF (JF.GT.JL)  GO TO 300
        GO TO 200
C       NO MORE SIGNIFICANT LETTERS IN CURRENT WORD. MOVE TO
C       START OF NEXT WORD.
  150   ISIG = 0
  160   IF (IBUF(JF).EQ.KBLANK)  GO TO 170
          JF = JF + 1
          IF (JF.GT.JL)  GO TO 300
          GO TO 160
  170   IF (IBUF(JF).NE.KBLANK)  GO TO 200
          JF = JF + 1
          IF (JF.GT.JL)  GO TO 300
          GO TO 170
C       INCREMENT OTHER POINTERS.
  200   ISIG = ISIG + 1
        JCW = JCW + 1
        GO TO 20
C
C--
C-    INVALID SYMBOL OR END OF FIELD.
  300 ICPH = 0
      GO TO 540
C
C-    VALID CONTROL PHRASE. SKIP PAST LAST WORD.
  500 IF (IBUF(JF).EQ.KBLANK)  GO TO 540
        JF = JF + 1
        IF (JF.GT.JL)  GO TO 540
        GO TO 500
C-
  540 JE = JF
      RETURN
      END
      SUBROUTINE COPIA (IA, IB, L)                                          INOU
 
C* REVISED 2/9/78.
C* COPIES AN INTEGER ARRAY.
 
C  IA RECEIVES THE ARRAY TO BE COPIED.
C  IB RETURNS THE COPIED ARRAY.
C  L RECEIVES THE LENGTHS OF IA AND IB.
 
      DIMENSION IA(L),IB(L)
 
      DO 10 I = 1, L
   10   IB(I) = IA(I)
 
      RETURN
      END
      SUBROUTINE COPIAS (IA, S, N)                                          INOU
 
C* REVISED 27/7/87.
C* COPIES AN INTEGER ARRAY INTO A CHARACTER STRING.
 
C  IA RECEIVES THE INTEGER ARRAY.
C  S RETURNS THE CHARACTER STRING.
C  N RECEIVES THE NUMBER OF CHARACTERS IN THE STRING.
 
      CHARACTER S*(*)
      DIMENSION IA(30000)
 
      IF (N.GT.LEN(S)) CALL BUG (29, N)
      DO 10 I = 1, N
        S(I:I) = CHAR(IA(I))
   10 CONTINUE
 
      RETURN
      END
      SUBROUTINE COPCIA (CHRS, ICHRS, N)                                    INOU
C
C  REVISED 12/3/86.
C  CONVERTS A CHARACTER ARRAY TO ITS INTEGER EQUIVALENT.
C
C  CHRS RECEIVES THE ARRAY OF CHARACTERS.
C  ICHRS RETURNS THE INTEGER EQUIVALENTS.
C  N RECEIVES THE NUMBER OF CHARACTERS.
C
      CHARACTER*1 CHRS(N)
      DIMENSION ICHRS(N)
C
      DO 10 I = 1, N
        ICHRS(I) = ICHAR (CHRS(I))
   10   CONTINUE
C
      RETURN
      END
      SUBROUTINE COPSIA (S, IA, N)                                          INOU
 
C* REVISED 27/7/87.
C* CONVERTS A CHARACTER STRING TO ITS INTEGER EQUIVALENT.
 
C  S RECEIVES THE CHARACTER STRING.
C  IA RETURNS THE INTEGER EQUIVALENT.
C  N RECEIVES THE NUMBER OF CHARACTERS.
 
      CHARACTER*(*) S
      DIMENSION IA(N)
 
      IF (N.GT.LEN(S)) CALL BUG (30, N)
      DO 10 I = 1, N
        IA(I) = ICHAR(S(I:I))
   10 CONTINUE
 
      RETURN
      END
      SUBROUTINE DELETS (IA, IBF, LA, K, LS)                                INOU
C
C* REVISED 14/6/83.
C* DELETES ALL OCCURRENCES OF A SYMBOL FROM A STRING.
C
C  IA RECEIVES THE STRING.
C  IBF RETURNS THE STRING WITH THE SYMBOL DELETED. MAY BE THE SAME AS IA.
C  LA RECEIVES THE MAXIMUM LENGTH OF THE STRING.
C  K RECEIVES THE CHARACTER TO BE DELETED.
C  LS RECEIVES THE ORIGINAL LENGTH OF THE STRING, AND RETURNS THE NEW
C    LENGTH.
C
      DIMENSION IA(LA),IBF(LA)
C
      IF (LS.LE.0)  GO TO 50
      J = 0
      DO 10 I = 1, LS
        IF (IA(I).EQ.K)  GO TO 10
        J = J + 1
        IBF(J) = IA(I)
   10   CONTINUE
      LS = J
   50 RETURN
      END
      SUBROUTINE DELRNG (JTYPC, NDEC, ITYPMK, LIDAT, IDAT, NVAL, LUNTYP,    INOU
     * IVDEC)
 
C  REVISED 13-MAY-91.
C  OUTPUTS NUMERIC RANGES FOR DELTA AND NATURAL LANGUAGE FORMATS.
 
C  JTYPC RECEIVES THE CHARACTER TYPE.
C  NDEC RECEIVES THE NUMBER OF DECIMAL PLACES REQUIRED ON OUTPUT.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  LIDAT RECEIVES THE LENGTH OF ITYPMK.
C  IDAT RECEIVES THE DATA.
C  NVAL RECEIVES THE LENGTH OF IDAT.
C  LUNTYP RECEIVES THE OUTPUT UNIT TYPE.
C  IVDEC RECEIVES WHETHER TO USE THE DECIMAL POINT DEFINED IN THE VOCABULARY.
 
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
 
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
 
      DIMENSION ITYPMK(LIDAT),IDAT(NVAL)
 
      IFIRST = 0
      ILAST = 0
 
      IB = 1
      IE = NVAL
      IF (NVAL.LE.3)  GOTO 100
 
C-    4 OR 5 VALUES.
C     FIRST TWO VALUES EQUAL.
      IF (IDAT(1).EQ.IDAT(2))  THEN
        IF (IDAT(IE-1).EQ.IDAT(IE))  THEN
          IB = IB + 1
          IE = IE - 1
        ELSE
          ILAST = 1
          IB = IB + 1
          IF (IE-IB+1.EQ.3.AND.IDAT(IB).EQ.IDAT(IB+1))  IB = IB + 1
        ENDIF
        GOTO 100
      ENDIF
 
C     LAST TWO VALUES EQUAL.
      IF (IDAT(IE-1).EQ.IDAT(IE))  THEN
        IFIRST = 1
        IE = IE - 1
        IF (IE-IB+1.EQ.3.AND.IDAT(IE-1).EQ.IDAT(IE))  IE = IE - 1
        GOTO 100
      ENDIF
 
C     OTHER CASES.
      IFIRST = 1
      ILAST = 1
      IF (NVAL.EQ.5)  GOTO 100
      IF (IDAT(2).EQ.IDAT(3))  THEN
        IDAT(3) = IDAT(4)
        IE = IE - 1
      ENDIF
 
C-    OUTPUT RANGES.
  100 LSTRNG = 0
      DO 200 I = IB, IE
        IPAR = 0
        IRNG = 0
        IF ((IFIRST.NE.0.AND.I.EQ.IB) .OR.
     *      (ILAST.NE.0.AND.I.EQ.IE))  IPAR = 1
        IF (IPAR.NE.0)  CALL JSTS (KDLPAR, -1, LUNTYP)
        IF (I.EQ.IE.AND.IE.GT.IB.AND.LSTRNG.EQ.0)
     *    CALL PRANGE (1, ITYPMK, LIDAT, LUNTYP)
        IF (JTYPC.EQ.3)  THEN
          CALL JSTI (IDAT(I), -1, LUNTYP)
        ELSE
          CALL JSTR (RELIN(IDAT(I)), NDEC, -1, LUNTYP, IVDEC)
        ENDIF
        IF (I.LT.IE-1)  THEN
          IRNG = 1
        ELSE IF(I.EQ.IE-1.AND.IPAR.NE.0)  THEN
          IRNG = 1
          LSTRNG = 1
        ENDIF
        IF (IRNG.NE.0)  CALL PRANGE (1, ITYPMK, LIDAT, LUNTYP)
        IF (IPAR.NE.0)  CALL JSTS (KDRPAR, -1, LUNTYP)
  200   CONTINUE
 
      RETURN
      END
      LOGICAL FUNCTION DIREXISTS (DIRNAME, LDIR)
 
C     REVISED 18-SEP-98.
C     RETURNS IF A SPECIFIED DIRECTORY EXISTS.
 
C     DIRNAME RECEIVES THE DIRECTORY NAME.
C     LDIR RECEIVES THE LENGTH OF THE DIRECTORY NAME.
 
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
 
      CHARACTER*(*) DIRNAME
      CHARACTER*80 F
C      CHARACTER*80 S
      LOGICAL*4 E,O
 
      F = DIRNAME(1:LDIR)
      LF = LDIR
      IF (F(LF:LF).NE.CHAR(KDBSLSH))  THEN
        LF = LF + 1
        F(LF:LF) = CHAR(KDBSLSH)
      ENDIF
      F(LF+1:LF+1) = CHAR(KDSTOP)
C      CALL EXNAME(F, S)
 
      DIREXISTS = .FALSE.
      INQUIRE (FILE=F, EXIST=E, OPENED=O, NUMBER=LUN, ERR=100)
      IF (E) THEN
        DIREXISTS = .TRUE.
      ENDIF
 
  100 RETURN
      END
      SUBROUTINE ECOUNT                                                     INOU
C
C  REVISED 1-AUG-89.
C  SETS IDERR AND INCREMENTS NCERR. TERMINATES PROGRAM IF NCERR.GT.100.
 
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
 
      IDERR = 1
      NCERR = NCERR + 1
      IF (NCERR.GT.100)  THEN
        CALL MESSF (78, IDUM, 1)
        CALL EXTERM
      ENDIF
 
      END
      SUBROUTINE ENDLN (LUNTYP)                                             INOU
C
C  REVISED 9/2/80.
C  FINISHES A LINE.
C
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT ON WHICH THE LINE IS BEING
C    OUTPUT.
C
      CALL BLKLIN (0, 0, LUNTYP)
      RETURN
      END
      SUBROUTINE ENDWD (LUNTYP)                                             INOU
C
C  REVISED 1/12/78.
C  FINISHES A WORD.
C
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT ON WHICH THE WORD IS BEING
C    OUTPUT.
C
      COMMON /BLKXXX/ KBLANK
C
      CALL JSTS (KBLANK, 0, LUNTYP)
      RETURN
      END
      SUBROUTINE EXTERM                                                     INOU
 
C* REVISED 1-AUG-89.
C* WRITES MESSAGE AND TERMINATES EXECUTION.
 
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
 
      L = 1
      IF (NCERR.NE.0) L = L + 1
      IF (NWERR.NE.0) L = L + 1
      CALL BLKLIN (1, L, 1)
 
      IF (NWERR.NE.0)  CALL MESSF (79, NWERR, 1)
 
      IF (NCERR.EQ.0) THEN
        CALL MESSF (80, IDUM, 1)
      ELSE
        CALL MESSF (81, NCERR, 1)
        CALL MESSF (82, IDUM, 1)
      ENDIF
 
      CALL UCLOSE
 
      IF (NCERR.EQ.0)  THEN
        CALL PSTOP (0)
      ELSE
        CALL PSTOP (1)
      ENDIF
      END
      SUBROUTINE FINDS (K, IBF, JB, JE, JF)                                 INOU
C
C  REVISED 5/6/83.
C  SEARCHES FOR A SYMBOL IN AN AREA OF A BUFFER.
C
C  K RECEIVES THE CHARACTER TO BE SEARCHED FOR.
C  IBF RECEIVES THE BUFFER TO BE SEARCHED.
C  JB RECEIVES THE STARTING POSITION IN THE BUFFER.
C  JE RECEIVES THE END POSITION IN THE BUFFER.
C  JF RETURNS THE POSITION OF THE FIRST OCCURRENCE OF K, OR JE
C    IF THERE IS NO OCCURRENCE OF K.
C
      DIMENSION IBF(JE)
C
      IF (JB.GT.JE)  GO TO 20
      DO 10 I = JB, JE
        IF (IBF(I).EQ.K)  GO TO 30
   10   CONTINUE
   20 I = JE
   30 JF = I
      RETURN
      END
      SUBROUTINE GETAU (LUN)                                                INOU
 
C* REVISED 26-JUL-89.
C* GETS NUMBER OF FIRST AVAILABLE LOGICAL UNIT.
 
C  LUN RETURNS THE LOGICAL UNIT NUMBER.
 
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
 
 
      DO 20 I = 1, NUN
        IF (LUNUSE(I).LT.0) GOTO 50
   20 CONTINUE
      CALL MESSA (83, -1, 0)
 
   50 LUN = I
 
      RETURN
      END
      SUBROUTINE IDKOD (N, IBF, M, ILEGAL)                                  INOU
C
C  REVISED 4/10/78.
C  DECODES AN INTEGER.
C
C  N RETURNS THE DECODED VALUE, OR 0 IF THE NUMBER IS INVALID.
C  IBF RECEIVES THE CHARACTERS TO BE DECODED.
C  M RECEIVES THE NUMBER OF CHARACTERS TO BE DECODED.
C  ILEGAL RETURNS 0 IF THE NUMBER IS VALID, OR THE POSITION OF THE
C    FIRST ILLEGAL CHARACTER OTHERWISE.
C
C  EMBEDDED AND TRAILING BLANKS ARE ILLEGAL.
 
C  NOTE: 13-MAR-91.
C  AS EFFICIENCY MEASURE, TRIED USING ARRAY LOOKUP INSTEAD OF FUNCTION CALL
C  TO DECODE VALUES WITH NO APPARENT IMPROVEMENT.

      DIMENSION IBF(M)
C
      COMMON /BLKXXX/ KBLANK
      COMMON /NUMXXX/ KNUM(10),KDEC,KMINUS
 
      N = 0
      ISIGN = 1
      ILEGAL = 0
      I = 1
   10 IF (I.GT.M)  GO TO 100
        IF (IBF(I).NE.KBLANK)  GO TO 12
        I = I + 1
        GO TO 10
   12 IF (IBF(I).NE.KMINUS)  GO TO 20
      IF (I.GE.M)  GO TO 90
      ISIGN = -1
      I = I + 1
   20 J = INUM(IBF(I))
        IF (J.LT.0)  GO TO 90
        N = 10*N + J
        IF (I.GE.M)  GO TO 100
        I = I + 1
        GO TO 20
   90 ILEGAL = I
      N = 0
  100 N = ISIGN*N
      RETURN
      END
      SUBROUTINE INDENT (IND, LUNTYP)                                       INOU
C
C  REVISED 14-MAR-91.
C  SETS INDENTATION AT START OF LINE.
C
C  IND RECEIVES THE INDENTATION.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT.
C
C  IF LUNTYP.EQ.4 AND PSEQ IS POSITIVE, PSEQ IS INCREMENTED BY SEQINC,
C    AND ENCODED AT THE START OF THE LINE.
C
      COMMON /BLKXXX/ KBLANK
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
C
      JOUT = 0
C      IF (IND.GT.LWIDTH(LUNTYP)-20)  GO TO 100
      IF (IND.GT.ABS(LWIDTH(LUNTYP))-20)  GO TO 100
      IF (PSEQ.LE.0. .OR. LUNTYP.NE.4)  GO TO 20
      PSEQ = PSEQ + SEQINC
      CALL RNKOD (PSEQ, NSQDIG, IOUT(1,4), JOUT, IND-1, 0)
      IF (JOUT.GT.0)  GO TO 20
      CALL MESSA (84, 1, 0)
      JOUT = IND - 1
   20 IF (JOUT.GE.IND)  GO TO 100
        JOUT = JOUT + 1
        IOUT(JOUT,LUNTYP) = KBLANK
        GO TO 20
  100 JIOUT(LUNTYP) = JOUT
      IENDWD(LUNTYP) = 0
      RETURN
      END
      SUBROUTINE INKOD (N, IBF, NBF, MBF)                                   INOU
C
C  REVISED 6/10/83.
C  ENCODES AN INTEGER.
C
C  N RECEIVES THE INTEGER TO BE ENCODED.
C  IBF RETURNS THE ENCODED NUMBER.
C  NBF RETURNS THE NUMBER OF SYMBOLS IN THE ENCODED NUMBER, OR 0 IF
C    IBF IS TOO SHORT TO CONTAIN THE ENCODED NUMBER.
C  MBF RECEIVES THE LENGTH OF IBF.
C
      DIMENSION IBF(MBF)
C
      COMMON /NUMXXX/ KNUM(10),KDEC,KMINUS
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
C
      IF (MBF.LT.1)  CALL BUG (7, MBF)
      NN = N
      NBF = 1
      IBF(1) = KNUM(1)
      IF (NN.EQ.0)  GO TO 200
      MM = 10
      J = 1
      IF (NN.GT.0) GO TO 105
      IBF(1) = KMINUS
      NBF = 2
      NN = -NN
      J = 2
  105 IF (NN.LT.MM) GO TO 110
        MM = MM*10
        NBF = NBF + 1
      GO TO 105
  110 IF (NBF.GT.MBF)  GO TO 150
      I = NBF
  115 M = NN/10
        IBFI = NN - M*10
        IBF(I) = KNUM(IBFI+1)
        NN = M
        IF (I.LE.J) GO TO 200
        I = I - 1
        GO TO 115
  150 NBF = 0
      CALL SETIA (IBF, MBF, KSTAR)
 
  200 RETURN
      END
      FUNCTION   INUM (K)                                                   INOU
C
C  REVISED 7/7/77.
C  RETURNS THE NUMERICAL VALUE OF K IF K IS A NUMERAL, -1 OTHERWISE.
C
      COMMON /NUMXXX/ KNUM(10),KDEC,KMINUS
C
      DO 10 I = 1, 10
        IF (K.EQ.KNUM(I))  GO TO 50
   10   CONTINUE
      INUM = -1
      RETURN
   50 INUM = I - 1
      RETURN
      END
      SUBROUTINE INSIDX                                                     INOU
 
C* REVISED 19-AUG-98.
C  INSERTS THE TEXT FOLLOWING THE `INDEX INSERT' DIRECTIVE INTO THE INDEX FILE.
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
 
C     CONTINUE READING FROM CURRENT RECORD
      CALL NEXTWD (JE)
      IB = JBUF
 
   10 DO 20 I = IB, JEDAT
        IF (IBUF(I).NE.KBLANK)  GO TO 40
   20   CONTINUE
      GO TO 100
   40 IF (IBUF(I).NE.KDSTAR)  GO TO 100
      GO TO 150
C
C     COPY TO INDEX FILE.
  100 CALL WRTREC (IBUF(IB), JEDAT, 4, 4)
 
C     READ NEXT RECORD.
      CALL RDBUF
 
C     CHECK CONTENTS.
      IF (JEDAT.LT.1)  GO TO 150
      IB = 1
      GOTO 10
 
  150 RETURN
      END
C      SUBROUTINE INSIDX                                                     INOU
C 
CC* REVISED 10-MAR-98.
CC  INSERTS THE CONTENTS OF THE CURRENT INPUT FILE INTO THE INDEX FILE.
C 
C      COMMON /BLKXXX/ KBLANK
C      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
C     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
C      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C 
CC     READ RECORD.
C   10 CALL RDBUF
CC
CC     CHECK CONTENTS.
C      IF (JEDAT.LT.1)  GO TO 150
C      DO 20 I = 1, JEDAT
C        IF (IBUF(I).NE.KBLANK)  GO TO 40
C   20   CONTINUE
C      GO TO 100
C   40 IF (IBUF(I).NE.KDSTAR)  GO TO 100
C      GO TO 150
CC
CC     COPY TO INDEX FILE.
C  100 CALL WRTREC (IBUF, JEDAT, 4, 4)
C      GOTO 10
C 
C  150 RETURN
C      END
      SUBROUTINE IPRT (LUNTYP, IPOINT)                                      INOU
 
C* REVISED 11-OCT-95.
C* PRINTS INPUT BUFFER.
 
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT FOR THE PRINTING.
C  IPOINT OPTIONALLY (IF > 0) RECEIVES A POINTER INTO THE INPUT BUFFER.
 
      PARAMETER (LBF=15)
      DIMENSION IBF(LBF)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /INQXXX/ ISEQ,SEQ,LIBUF,MIREC,LISIND,LLUNI,JLIS,LISOUT(132)
      COMMON /LUFXXX/ FNAME(19),LFNAME(19)
        CHARACTER FNAME*80
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
      COMMON /UNUXXX/ ILUNU
C
      IF (LLUNI.LE.0)  GO TO 100
      IF (ILUNU.EQ.0)  CALL BLKLIN (0, 0, LUNTYP)
C
      IF (JLIS.LE.0)  THEN
C-      ENCODE FILE NAME AND RECORD NUMBER.
        CALL INKOD (LUNREC(LLUNI), IBF, L, LBF)
C       TRUNCATE FILE NAME FROM LEFT IF INSUFFICIENT ROOM AND PREFIX WITH ".."
C       TO INDICATE OMISSION OF LETTERS.
        JLIS = MIN (LFNAME(LLUNI), LISIND-L-2)
        IB = LFNAME(LLUNI) - JLIS + 1
        CALL COPSIA (FNAME(LLUNI)(IB:), LISOUT, JLIS)
        IF (IB.GT.1)  CALL COPSIA('..', LISOUT, 2)
        LISOUT(JLIS+1) = KCOMMA
        CALL COPIA (IBF, LISOUT(JLIS+2), L)
        JLIS = JLIS + L + 1
        IF (LISIND.GT.JLIS)
     *    CALL SETIA (LISOUT(JLIS+1), LISIND-JLIS, KBLANK)
 
C-      COPY INPUT RECORD.
        L = MAX(1,JEDAT-1)
        JPOINT = IPOINT
        CALL CPYINP (JPOINT, IBUF, L, LISOUT(LISIND+1), MIREC-1, JOUT)
        IF (IPOINT.GT.0)  IPOINT = JPOINT
        JLIS = LISIND + JOUT
      ENDIF
C
C-    PRINT RECORD.
      IF (ILUNU.EQ.0) CALL WRTREC (LISOUT, JLIS, LUNTYP, LUNTYP)
      IF (ILUNU.NE.0) CALL WREC (LISOUT, JLIS, LUNE)
  100 RETURN
      END
      FUNCTION   ISPUNC (IBF, L)
 
C  REVISED 29-MAY-92.
C  DETERMINES WHETHER A BYTE OR SET OF BYTES REPRESENTS A PUNCTUATION MARK
C  AS DEFINED IN THE VOCABULARY.
 
      COMMON /VWDXXX/ VWORD(18)
        CHARACTER*40 VWORD
      COMMON /VLWXXX/ NVWD,MAXVWD,LVWD(18),IBPUNC,IEPUNC,
     * KVSTOP,KVCOM1,KVCOM2,KVSEMI,KVDEC
 
      DIMENSION IBF(L)
 
      ISPUNC = 0
 
      DO 20 I = IBPUNC, IEPUNC
        J = L
        K = LVWD(I)
        IF (J.LT.K)  GOTO 20
        DO JJ = 1, LVWD(I)
          IF (IBF(J).NE.ICHAR(VWORD(I)(K:K)))  GOTO 20
          J = J - 1
          K = K - 1
        ENDDO
        ISPUNC = 1
        GOTO 100
   20 CONTINUE
 
  100 RETURN
      END
      FUNCTION ISALPHA (ICHAR)                                              INOU
 
C* REVISED 07-MAY-98.
C* CHECKS TO SEE IF A CHARACTER IS ALPHABETIC.

 
      COMMON /ALPXXX/ KA,KB,KC,KD,KE,KF,KG,KH,KI,KJ,KK,KL,KM,
     *                KN,KO,KP,KQ,KR,KS,KT,KU,KV,KW,KX,KY,KZ
      COMMON /ALPLCX/ KLA,KLB,KLC,KLD,KLE,KLF,KLG,KLH,KLI,KLJ,KLK,KLL,
     *                KLM,KLN,KLO,KLP,KLQ,KLR,KLS,KLT,KLU,KLV,KLW,KLX,
     *                KLY,KLZ

      DIMENSION K(26),L(26)
      EQUIVALENCE (KA,K(1)), (KLA,L(1))
 
      ISALPHA = 0
      DO 10 II = 1, 26
        IF (ICHAR.EQ.K(II))  GO TO 20
   10   CONTINUE
 
      DO 15 II = 1, 26
        IF (ICHAR.EQ.L(II))  GO TO 20
   15   CONTINUE

      GO TO 30
C
   20 ISALPHA = 1
C
   30 RETURN
      END
      SUBROUTINE JNKOD (N, IBF, MBF)                                        INOU
C
C  REVISED 26-JUL-89.
C  ENCODES AN INTEGER RIGHT-JUSTIFIED IN AN ARRAY.
C
C  N RECEIVES THE INTEGER TO BE ENCODED.
C  IBF RETURNS THE ENCODED NUMBER. IF IBF IS TOO SHORT TO CONTAIN
C     THE ENCODED NUMBER, IT IS FILLED WITH STARS.
C  MBF RECEIVES THE LENGTH OF IBF.
C
      DIMENSION IBF(MBF)
C
      COMMON /BLKXXX/ KBLANK
C
      CALL INKOD (N, IBF, NBF, MBF)
      IF (NBF.LE.0)  GO TO 50
C
      J = NBF
      I = MBF
   10 IBF(I) = IBF(J)
        IF (J.LE.1)  GO TO 20
        I = I - 1
        J = J - 1
        GO TO 10
   20 I = I - 1
        IF (I.LT.1)  GO TO 100
        IBF(I) = KBLANK
        GO TO 20
C
   50 CALL MESSA (84, 1, 0)
C
  100 RETURN
      END
C      SUBROUTINE JRKOD (R, NDEC, IBF, MBF, IVDEC)                          INOU
C 
CC  REVISED 14-MAR-91.
CC  ENCODES A REAL NUMBER RIGHT-JUSTIFIED IN AN ARRAY.
C 
CC  R RECEIVES THE REAL NUMBER TO BE ENCODED.
CC  NDEC RECEIVES THE NUMBER OF FIGURES REQUIRED IN THE RESULT
CC    (SEE SUBR. RNKOD)
CC  IBF RETURNS THE ENCODED NUMBER.
CC  MBF RECEIVES THE LENGTH OF IBF.
CC  IVDEC RECEIVES WHETHER TO USE THE DECIMAL POINT DEFINED IN THE VOCABULARY.
C 
C      DIMENSION IBF(MBF)
C 
C      COMMON /BLKXXX/ KBLANK
C 
C      CALL RNKOD (R, NDEC, IBF, NBF, MBF, IVDEC)
C      IF (NBF.LE.0)  GO TO 50
C 
C      J = NBF
C      I = MBF
C   10 IBF(I) = IBF(J)
C        IF (J.LE.1)  GO TO 20
C        I = I - 1
C        J = J - 1
C        GO TO 10
C   20 I = I - 1
C        IF (I.LT.1)  GO TO 100
C        IBF(I) = KBLANK
C        GO TO 20
C 
C   50 CALL MESSA (84, 1, 0)
C 
C  100 RETURN
C      END
      SUBROUTINE JSTCHO (IBF, N, IE, LUNTYP)                                INOU
 
C* REVISED 19-NOV-92.
C* PRODUCES JUSTIFIED OUTPUT USING SPECIFICATIONS FOR CHINESE FORMAT.
 
C  IBF RECEIVES THE SYMBOLS TO BE OUTPUT.
C  N RECEIVES THE NUMBER OF SYMBOLS TO BE OUTPUT.
C  IE RECEIVES A FLAG SPECIFYING THE ACTION AFTER THE N-TH SYMBOL.
C    IF IE.LT.0, THE LAST WORD IS LEFT UNFINISHED. IF IE.EQ.0, THE LAST
C    WORD IS FINISHED. IF IE.GT.0, THE LINE IS FINISHED, AND (IE-1)
C    EXTRA BLANK LINES ARE OUTPUT.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT FOR OUTPUT.
C    1 - ERROR. 2 - LISTING. 3 - PRINT. 4 - OUTPUT.
 
C  THE OUTPUT BUFFER STARTING AT IOUT(1,LUNTYP) IS USED.
 
C  11/8/87. WORDS LONGER THAN OUTPUT WIDTH NOT TRUNCATED (UNLESS THEY
C    ARE LONGER THAN THE OUTPUT BUFFER).
 
      DIMENSION IBF(N)
C
      COMMON /BLKXXX/ KBLANK
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
 
C     NOTE: BECAUSE THE LENGTH OF THE PUNCTUATION MARKS (I.E. NO.BYTES) DEFINED
C     IN THE VOCABULARY IS UNKNOWN, THE FUNCTION ISPUNC IS PASSED THE LAST BYTE
C     OF THE ARRAY BEING PROCESSED AND THE COMPARISON FUNCTION WORKS BACKWARDS..
 
      SAVE LCHIN, LNUMER, LPUNC
 
C     FUNCTION TO DETECT IF UPPER BIT OF BYTE IS SET.
      IHISET(I) = IAND(I,128)
 
      JOUT = JIOUT(LUNTYP)
      JIN = 1
 
C-    COMPLETE PREVIOUS WORD IF NECESSARY.
      IF (JOUT.LE.0)  THEN
        LCHIN = 0
        LNUMER = 0
        LPUNC = 0
        GO TO 120
      ENDIF
 
      IF (IBF(1).NE.KBLANK.OR.IOUT(JOUT,LUNTYP).EQ.KBLANK)  GO TO 100
      IENDWD(LUNTYP) = JOUT
      IF (JOUT.GE.ABS(LWIDTH(LUNTYP)))  GO TO 100
      JOUT = JOUT + 1
      IOUT(JOUT,LUNTYP) = KBLANK
 
C-    TRANSFER CHARACTERS UNTIL WORD IS COMPLETE OR OUTPUT BUFFER FULL.
  100 CONTINUE
C     NOTE PROPERTIES OF LAST CHARACTER IN BUFFER.
      IF (IOUT(JOUT,LUNTYP).EQ.KBLANK)  THEN
        LBLANK = 1
      ELSE
        LBLANK = 0
      ENDIF
 
  120   IF (JIN.GT.N)  GO TO 500
          IF (IBF(JIN).NE.KBLANK)  GO TO 130
          JIN = JIN + 1
          GOTO 120
  130   IF (IENDWD(LUNTYP).GE.0)  GO TO 140
        CALL INDENT (INDEN(LUNTYP), LUNTYP)
        JOUT = JIOUT(LUNTYP)
 
  140   IF (JIN.GT.N)  GO TO 500
          IF (IBF(JIN).EQ.KBLANK)  GO TO 160
          ISCHIN = IHISET(IBF(JIN))
          IF (ISCHIN.NE.0)  THEN
 
C           CURRENT CHARACTER IS CHINESE.
 
C           IF THE CURRENT CHARACTER IS NOT PUNCTUATION, ANY CHARACTER PRIOR
C           TO A CHINESE CHARACTER CAN BE A WORD BREAK.
            IF (ISPUNC(IBF, JIN+1).EQ.0)  IENDWD(LUNTYP) = JOUT
 
            IF (JOUT+1.GE.ABS(LWIDTH(LUNTYP)))  GOTO 200
 
            NUMER = 0
            L = 2
            IF (LBLANK.NE.0)  THEN
C             IF CHINESE CHARACTER+BLANK+CHINESE CHARACTER, OMIT BLANK.
C             IF NUMERIC CHARACTER+BLANK+CHINESE CHARACTER, OMIT BLANK.
C             IF ')'+BLANK+CHINESE CHARACTER, OMIT BLANK.
              IF (LCHIN.NE.0.OR.LNUMER.NE.0 .OR.
     *            (LCHIN.EQ.0.AND.IOUT(JOUT,LUNTYP).EQ.KRPAR))
     *          JOUT = JOUT - 1
            ELSE
C             IF PUNCTUATION MARK+CHINESE CHARACTER, INSERT BLANK BETWEEN THE TWO.
              IF (LPUNC.NE.0)  THEN
                JOUT = JOUT + 1
                IOUT(JOUT,LUNTYP) = KBLANK
                IF (JOUT.GE.ABS(LWIDTH(LUNTYP)))  GO TO 200
              ENDIF
            ENDIF
 
          ELSE
 
C           CURRENT CHARACTER IS NOT CHINESE.
 
            IF (JOUT.GE.ABS(LWIDTH(LUNTYP)))  GO TO 200
            NUMER = ISNUM(IBF(JIN))
C           IF CHINESE CHARACTER+BLANK+NUMERIC CHARACTER, OMIT BLANK.
C           IF CHINESE CHARACTER+BLANK+'(', OMIT BLANK.
            IF (LBLANK.NE.0.AND.LCHIN.NE.0 .AND.
     *        (NUMER.NE.0.OR.IBF(JIN).EQ.KLPAR))
     *        JOUT = JOUT - 1
            L = 1
          ENDIF
          DO JJ = 1, L
            I = IBF(JIN)
            IF (ICAP.NE.0.AND.ISCHIN.EQ.0)  CALL CAP (I, ICAP)
            IF (I.EQ.KBLANK.AND.IOUT(JOUT,LUNTYP).EQ.KBLANK)  GOTO 145
            JOUT = JOUT + 1
            IOUT(JOUT,LUNTYP) = I
  145       JIN = JIN + 1
          ENDDO
          IF (ISCHIN.NE.0)  THEN
            LCHIN = 1
            LPUNC = 0
          ELSE
            LCHIN = 0
            LPUNC = ISPUNC(IOUT(1,LUNTYP), JOUT)
          ENDIF
          LNUMER = NUMER
          LBLANK = 0
          GO TO 140
 
C-      WORD FITS.
  160   IENDWD(LUNTYP) = JOUT
        IF (JOUT.GE.ABS(LWIDTH(LUNTYP)))  GO TO 400
        JOUT = JOUT + 1
        LBLANK = 1
        IOUT(JOUT,LUNTYP) = KBLANK
        GO TO 400
 
C-      WORD DOES NOT FIT.
  200   IF (IENDWD(LUNTYP).GT.INDEN(LUNTYP)) GOTO 210
C       NO PREVIOUS WORD BREAK ON LINE. SET WORD BREAK AT NEXT BLANK,
C       OR WHEN OUTPUT BUFFER IS FULL.
  202   IF (JIN.GT.N) GOTO 500
          ISCHIN = IHISET(IBF(JIN))
          IF (IBF(JIN).EQ.KBLANK)  THEN
            IEND = 1
          ELSE IF (ISCHIN.NE.0.AND.JOUT+1.GE.LOUT)  THEN
            IEND = 1
          ELSE IF (JOUT.GE.LOUT) THEN
            IEND = 1
          ELSE
            IEND = 0
          ENDIF
          IF (IEND.NE.0)  THEN
            IENDWD(LUNTYP) = JOUT
            GOTO 210
          ENDIF
          IF (ISCHIN.NE.0)  THEN
            L = 2
          ELSE
            L = 1
          ENDIF
          DO JJ = 1, L
            JOUT = JOUT + 1
            IOUT(JOUT,LUNTYP) = IBF(JIN)
            JIN = JIN + 1
          ENDDO
          IF (ISCHIN.NE.0)  THEN
            IENDWD(LUNTYP) = JOUT
            LCHIN = 1
            LPUNC = 0
            LNUMER = 0
            GOTO 210
          ELSE
            LCHIN = 0
            LNUMER = ISNUM(IOUT(JOUT,LUNTYP))
            LPUNC = ISPUNC(IOUT(1,LUNTYP), JOUT)
          ENDIF
        GOTO 202
C       OUTPUT LINE UP TO WORD BREAK.
  210   CALL WRTREC (IOUT(1,LUNTYP), IENDWD(LUNTYP), LUNTYP, 4)
        JE = JOUT
        IF (IOUT(JE,LUNTYP).EQ.KBLANK)  JE = JE - 1
        I = IENDWD(LUNTYP)
C       .. ALLOW FOR WORD BREAK AT NON-BLANK (BY EXTERNAL SETTING
C       .. OF IENDWD).
        IF (I.LT.JE) THEN
          IF (IOUT(I+1,LUNTYP).EQ.KBLANK) I = I + 1
        ENDIF
C       START NEW LINE, AND COPY UNFINISHED WORD TO START OF BUFFER.
        CALL INDENT (INDEN(LUNTYP), LUNTYP)
        JOUT = JIOUT(LUNTYP)
  220   IF (I.GE.JE)  GO TO 420
          I = I + 1
          JOUT = JOUT + 1
          IOUT(JOUT,LUNTYP) = IOUT(I,LUNTYP)
        GO TO 220
 
  400   JIN = JIN + 1
  420 GO TO 100
 
C     END OF INPUT BUFFER.
  500 IF (IE.LT.0)  GO TO 1000
      IF (IE.GT.0)  GO TO 600
 
      IF (JOUT.EQ.0)  GO TO 1000
      IF (IOUT(JOUT,LUNTYP).EQ.KBLANK)  GO TO 1000
      IENDWD(LUNTYP) = JOUT
      IF (JOUT.GE.ABS(LWIDTH(LUNTYP)))  GO TO 1000
      JOUT = JOUT + 1
      IOUT(JOUT,LUNTYP) = KBLANK
      GO TO 1000
 
  600 JIOUT(LUNTYP) = JOUT
      CALL BLKLIN (IE-1, 0, LUNTYP)
      JOUT = 0
 
 1000 JIOUT(LUNTYP) = JOUT
      RETURN
      END  
      SUBROUTINE JSTI (N, IE, LUNTYP)                                       INOU
C
C  REVISED 26-JUL-89.
C  ENCODES AND OUTPUTS AN INTEGER VIA JSTOUT.
C
C  N RECEIVES THE INTEGER TO BE OUTPUT.
C  IE RECEIVES A FLAG SPECIFYING THE ACTION AFTER OUTPUT.
C    NEGATIVE - LAST WORD LEFT UNFINISHED. 0 - LAST WORD FINISHED.
C    POSITIVE - LINE FINISHED, AND (IE-1) EXTRA BLANK LINES.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT FOR OUTPUT.
C
      DIMENSION IW(12)
C
      DATA LW/12/
C
      CALL INKOD (N, IW, JW, LW)
      IF (JW.GT.0)  GO TO 20
      CALL MESSA (84, 1, 0)
      JW = LW
   20 CALL JSTOUT (IW, JW, IE, LUNTYP, 0)
      RETURN
      END
      SUBROUTINE JSTOUT (IBF, N, IE, LUNTYP, INHTMRTF)                      INOU
 
C* REVISED 27-MAR-99.
C* PRODUCES JUSTIFIED OUTPUT.
 
C  IBF RECEIVES THE SYMBOLS TO BE OUTPUT.
C  N RECEIVES THE NUMBER OF SYMBOLS TO BE OUTPUT.
C  IE RECEIVES A FLAG SPECIFYING THE ACTION AFTER THE N-TH SYMBOL.
C    IF IE.LT.0, THE LAST WORD IS LEFT UNFINISHED. IF IE.EQ.0, THE LAST
C    WORD IS FINISHED. IF IE.GT.0, THE LINE IS FINISHED, AND (IE-1)
C    EXTRA BLANK LINES ARE OUTPUT.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT FOR OUTPUT.
C    1 - ERROR. 2 - LISTING. 3 - PRINT. 4 - OUTPUT.
C  INHTMRTF RECEIVES WHETHER THIS IS AN HTML OR RTF STRING.
 
C  THE OUTPUT BUFFER STARTING AT IOUT(1,LUNTYP) IS USED.
 
C  11/8/87. WORDS LONGER THAN OUTPUT WIDTH NOT TRUNCATED (UNLESS THEY
C    ARE LONGER THAN THE OUTPUT BUFFER).
 
      DIMENSION IBF(N)
 
      COMMON /ALPLCX/ KLA,KLB,KLC,KLD,KLE,KLF,KLG,KLH,KLI,KLJ,KLK,KLL,
     *                KLM,KLN,KLO,KLP,KLQ,KLR,KLS,KLT,KLU,KLV,KLW,KLX,
     *                KLY,KLZ
      COMMON /BINXXX/ IENDRC,LENDRC,INSBLK
      COMMON /BLKXXX/ KBLANK
      COMMON /CAPXXX/ KCAPMK,IOMCAP
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /IGNXXX/ ICMD,IGNTYP
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /MISXXX/ IMPVAL,IPACH,IPCHN,IPUNC,IRAB,IKEYCH,ICMPRS,
     * ITUNC,ITINAP,ITIMPL,IUNVAR,LNKC,IDEPC,LICDEP,IPSUMM,ICHSEQ,
     * ITMSEQ,INSRVA,IFATT,ITINTR,ICMAND,IUNRNG,IOMTOR,NEWFLS,IRSEMI,
     * IOMSTC,IADDCH,IEMPCH,IVARUN,ISCALC,ICNOTE,ICIMGE,ITIMGE,MTIMGE,
     * NTIMGE,IOMNSC,IOMCMT,IOMLOW,IERRPC,IERRAB,ICHNSE,NUMST0,IUMEAN,
     * NADNAM,NEMNAM,NODELO,IOMUSP,ICKYIMG,ITKYIMG,ISUPIMG,ICTIMGE,
     * ICTNAME,IHTML,IRTF,MTHEAD,NTHEAD,ITMHDGS,LCDNAM,MTFILE,NTFILE,
     * ITMFILS,MXHEAD,NXHEAD,IDXHDGS,INSIMGFN,ICOFILE,IUCC,IOUNC,ITLINK,
     * MTLINK,NTLINK,NAUTOCC,IOUTSUBJ
      COMMON /NUMXXX/ KNUM(10),KDEC,KMINUS
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
C
 
      CHARACTER*8 HTML(32:255)
      CHARACTER*256 REPLSTR
C     MAXHTML is the maximum length of HTML strings.
      PARAMETER(MAXHTML=8)
 
      DATA (HTML(I),I=32,100)
C  32    
     * /'        ',
C  33 !  
     * '        ',
C  34 "  
     * '        ',
C  35 #  
     * '        ',
C  36 $  
     * '        ',
C  37 %  
     * '        ',
C  38 & (&amp;)  
     * '&amp;   ',
C  39 '  
     * '        ',
C  40 (  
     * '        ',
C  41 )  
     * '        ',
C  42 *  
     * '        ',
C  43 +  
     * '        ',
C  44 ,  
     * '        ',
C  45 -  
     * '        ',
C  46 .  
     * '        ',
C  47 /  
     * '        ',
C  48 0  
     * '        ',
C  49 1  
     * '        ',
C  50 2  
     * '        ',
C  51 3  
     * '        ',
C  52 4  
     * '        ',
C  53 5  
     * '        ',
C  54 6  
     * '        ',
C  55 7  
     * '        ',
C  56 8  
     * '        ',
C  57 9  
     * '        ',
C  58 :  
     * '        ',
C  59 ;  
     * '        ',
C  60 < (&lt;)  
     * '        ',
C  61 =  
     * '        ',
C  62 > (&gt;)
     * '        ',
C  63 ?  
     * '        ',
C  64 @  
     * '        ',
C  65 A  
     * '        ',
C  66 B  
     * '        ',
C  67 C  
     * '        ',
C  68 D  
     * '        ',
C  69 E  
     * '        ',
C  70 F  
     * '        ',
C  71 G  
     * '        ',
C  72 H  
     * '        ',
C  73 I  
     * '        ',
C  74 J  
     * '        ',
C  75 K  
     * '        ',
C  76 L  
     * '        ',
C  77 M  
     * '        ',
C  78 N  
     * '        ',
C  79 O  
     * '        ',
C  80 P  
     * '        ',
C  81 Q  
     * '        ',
C  82 R  
     * '        ',
C  83 S  
     * '        ',
C  84 T  
     * '        ',
C  85 U  
     * '        ',
C  86 V  
     * '        ',
C  87 W  
     * '        ',
C  88 X  
     * '        ',
C  89 Y  
     * '        ',
C  90 Z  
     * '        ',
C  91 [  
     * '        ',
C  92 \ (backslash)
     * '\       ',
C  93 ]  
     * '        ',
C  94 ^  
     * '        ',
C  95 _  
     * '        ',
C  96 `  
     * '&#145;  ',
C  97 a  
     * '        ',
C  98 b  
     * '        ',
C  99 c  
     * '        ',
C  100 d 
     * '        '/
      DATA (HTML(I),I=101,200)
C  101 e 
     */'        ',
C  102 f 
     * '        ',
C  103 g 
     * '        ',
C  104 h 
     * '        ',
C  105 i 
     * '        ',
C  106 j 
     * '        ',
C  107 k 
     * '        ',
C  108 l 
     * '        ',
C  109 m 
     * '        ',
C  110 n 
     * '        ',
C  111 o 
     * '        ',
C  112 p 
     * '        ',
C  113 q 
     * '        ',
C  114 r 
     * '        ',
C  115 s 
     * '        ',
C  116 t 
     * '        ',
C  117 u 
     * '        ',
C  118 v 
     * '        ',
C  119 w 
     * '        ',
C  120 x 
     * '        ',
C  121 y 
     * '        ',
C  122 z 
     * '        ',
C  123 { 
     * '        ',
C  124 | 
     * '        ',
C  125 } 
     * '        ',
C  126 ~ 
     * '        ',
C  127 (ox7f)
     * '&#127;  ',
C  128 (ox80)
     * '&#127;  ',
C  129 (ox81)
     * '&#127;  ',
C  130 (ox82)
     * '&#130;  ',
C  131 (ox83)
     * '&#131;  ',
C  132 (ox84)
     * '&#132;  ',
C  133 (ox85)
     * '&#133;  ',
C  134 (ox86)
     * '&#134;  ',
C  135 (ox87)
     * '&#135;  ',
C  136 (ox88)
     * '&#136;  ',
C  137 (ox89)
     * '&#137;  ',
C  138 (ox8a)
     * '&#138;  ',
C  139 (ox8b)
     * '&#139;  ',
C  140 (ox8c)
     * '&#140;  ',
C  141 (ox8d)
     * '&#127;  ',
C  142 (ox8e)
     * '&#127;  ',
C  143 (ox8f)
     * '&#127;  ',
C  144 (ox90)
     * '&#127;  ',
C  145 (ox91)
     * '&#145;  ',
C  146 (ox92)
     * '&#146;  ',
C  147 (ox93)
     * '&#147;  ',
C  148 (ox94)
     * '&#148;  ',
C  149 (ox95)
     * '&#149;  ',
C  150 (ox96)
     * '&#150;  ',
C  151 (ox97)
     * '&#151;  ',
C  152 (ox98)
     * '&#152;  ',
C  153 (ox99)
     * '&#153;  ',
C  154 (ox9a)
     * '&#154;  ',
C  155 (ox9b)
     * '&#155;  ',
C  156 (ox9c)
     * '&#156;  ',
C  157 (ox9d)
     * '&#127;  ',
C  158 (ox9e)
     * '&#127;  ',
C  159 (ox9f)
     * '&#159;  ',
C  160 (oxa0)
     * '&nbsp;  ',
C  161 (oxa1)
     * '&#161;  ',
C  162 (oxa2)
     * '&#162;  ',
C  163 (oxa3)
     * '&#163;  ',
C  164 (oxa4)
     * '&#164;  ',
C  165 (oxa5)
     * '&#165;  ',
C  166 (oxa6)
     * '&#166;  ',
C  167 (oxa7)
     * '&#167;  ',
C  168 (oxa8)
     * '&#168;  ',
C  169 (oxa9)
     * '&#169;  ',
C  170 (oxaa)
     * '&#170;  ',
C  171 (oxab)
     * '&#171;  ',
C  172 (oxac)
     * '&#172;  ',
C  173 (oxad)
     * '&#173;  ',
C  174 (oxae)
     * '&#174;  ',
C  175 (oxaf)
     * '&#175;  ',
C  176 (oxb0)
     * '&#176;  ',
C  177 (oxb1)
     * '&#177;  ',
C  178 (oxb2)
     * '&#178;  ',
C  179 (oxb3)
     * '&#179;  ',
C  180 (oxb4)
     * '&#180;  ',
C  181 (oxb5)
     * '&#181;  ',
C  182 (oxb6)
     * '&#182;  ',
C  183 (oxb7)
     * '&#183;  ',
C  184 (oxb8)
     * '&#184;  ',
C  185 (oxb9)
     * '&#185;  ',
C  186 (oxba)
     * '&#186;  ',
C  187 (oxbb)
     * '&#187;  ',
C  188 (oxbc)
     * '&#188;  ',
C  189 (oxbd)
     * '&#189;  ',
C  190 (oxbe)
     * '&#190;  ',
C  191 (oxbf)
     * '&#191;  ',
C  192 (oxc0)
     * '&Agrave;',
C  193 (oxc1)
     * '&Aacute;',
C  194 (oxc2)
     * '&acirc; ',
C  195 (oxc3)
     * '&Atilde;',
C  196 (oxc4)
     * '&Auml;  ',
C  197 (oxc5)
     * '&Aring; ',
C  198 (oxc6)
     * '&AElig; ',
C  199 (oxc7)
     * '&Ccedil;',
C  200 (oxc8)
     * '&Egrave;'/
      DATA (HTML(I),I=201,255)
C  201 (oxc9)
     */'&Eacute;',
C  202 (oxca)
     * '&Ecirc; ',
C  203 (oxcb)
     * '&Euml;  ',
C  204 (oxcc)
     * '&Igrave;',
C  205 (oxcd)
     * '&Iacute;',
C  206 (oxce)
     * '&Icirc; ',
C  207 (oxcf)
     * '&Iuml;  ',
C  208 (oxd0)
     * '&ETH;   ',
C  209 (oxd1)
     * '&Ntilde;',
C  210 (oxd2)
     * '&Ograve;',
C  211 (oxd3)
     * '&Oacute;',
C  212 (oxd4)
     * '&Ocirc; ',
C  213 (oxd5)
     * '&Otilde;',
C  214 (oxd6)
     * '&Ouml;  ',
C  215 (oxd7)
     * '&#215;  ',
C  216 (oxd8)
     * '&Oslash;',
C  217 (oxd9)
     * '&Ugrave;',
C  218 (oxda)
     * '&Uacute;',
C  219 (oxdb)
     * '&Ucirc; ',
C  220 (oxdc)
     * '&Uuml;  ',
C  221 (oxdd)
     * '&Yacute;',
C  222 (oxde)
     * '&THORN; ',
C  223 (oxdf)
     * '&szlig; ',
C  224 (oxe0)
     * '&agrave;',
C  225 (oxe1)
     * '&aacute;',
C  226 (oxe2)
     * '&acirc; ',
C  227 (oxe3)
     * '&atilde;',
C  228 (oxe4)
     * '&auml;  ',
C  229 (oxe5)
     * '&aring; ',
C  230 (oxe6)
     * '&aelig; ',
C  231 (oxe7)
     * '&ccedil;',
C  232 (oxe8)
     * '&egrave;',
C  233 (oxe9)
     * '&eacute;',
C  234 (oxea)
     * '&ecirc; ',
C  235 (oxeb)
     * '&euml;  ',
C  236 (oxec)
     * '&igrave;',
C  237 (oxed)
     * '&iacute;',
C  238 (oxee)
     * '&icirc; ',
C  239 (oxef)
     * '&iuml;  ',
C  240 (oxf0)
     * '&ieth;  ',
C  241 (oxf1)
     * '&ntilde;',
C  242 (oxf2)
     * '&ograve;',
C  243 (oxf3)
     * '&oacute;',
C  244 (oxf4)
     * '&ocirc; ',
C  245 (oxf5)
     * '&otilde;',
C  246 (oxf6)
     * '&ouml;  ',
C  247 (oxf7)
     * '&#247;  ',
C  248 (oxf8)
     * '&oslash;',
C  249 (oxf9)
     * '&ugrave;',
C  250 (oxfa)
     * '&uacute;',
C  251 (oxfb)
     * '&ucirc; ',
C  252 (oxfc)
     * '&uuml;  ',
C  253 (oxfd)
     * '&yacute;',
C  254 (oxfe)
     * '&thorn; ',
C  255 (oxff)
     * '&yuml;  '/

      IF (ABS(LWIDTH(LUNTYP)).LE.INDEN(LUNTYP)
     * .OR.ABS(LWIDTH(LUNTYP)).GT.LOUT.OR. N.LT.1)  CALL BUG (5, N)
C
      IF (ICHNSE.NE.0)  THEN
        CALL JSTCHO (IBF, N, IE, LUNTYP)
        GOTO 1100
      ENDIF
 
      JOUT = JIOUT(LUNTYP)
C     Save value of JOUT on entry so can later determine if any of contents of
C     IBF have been output by WRTREC (called in this routine)
      JOUTSV = JOUT
      JIN = 1
      IDOREPL = 0
      INRTFMK = 0
C     Flag for binary output mode.
      IBINARY = 0
      IF (LUNTYP.EQ.3.AND.LWIDTH(3).LT.0)  IBINARY = 1
C
C-    COMPLETE PREVIOUS WORD IF NECESSARY.
      IF (JOUT.LE.0)  GO TO 100
      IF (IBF(1).NE.KBLANK.OR.IOUT(JOUT,LUNTYP).EQ.KBLANK)  GO TO 100
      IENDWD(LUNTYP) = JOUT
      IF (JOUT.GE.ABS(LWIDTH(LUNTYP)))  GO TO 100
      JOUT = JOUT + 1
      IOUT(JOUT,LUNTYP) = KBLANK
      JOUTSV = JOUT
C
C-    TRANSFER CHARACTERS UNTIL WORD IS COMPLETE OR OUTPUT BUFFER FULL.
  100 CONTINUE
  120   IF (JIN.GT.N)  GO TO 500
          IF (IBF(JIN).NE.KBLANK)  GO TO 130
          JIN = JIN + 1
          GO TO 120
  130   IF (IENDWD(LUNTYP).GE.0)  GO TO 140
        CALL INDENT (INDEN(LUNTYP), LUNTYP)
        JOUT = JIOUT(LUNTYP)
  140   IF (JIN.GT.N)  GO TO 500
          IF ((INHTMRTF.EQ.0.OR.IBINARY.EQ.0).AND.IBF(JIN).EQ.KBLANK)
     *      GO TO 160
          IF (JOUT.GE.ABS(LWIDTH(LUNTYP)))  GO TO 200
          I = IBF(JIN)
          IF (I.EQ.KCAPMK.AND.IOMCAP.NE.0)  THEN
            ICAP = 0
            GOTO 150
          ENDIF
C         DON'T CAPITALIZE HTML OR RTF STRINGS.
C         (OTHER TYPESETTINGS ARE PROCESSED BY S/R TYPOUT, SO DON'T NEED
C          TO BE HANDLED HERE.)

C         Get IGNOR value of current character (I).
          KIGNOR = IGNOR(I)
 
          IF (ICAP.NE.0.AND.I.NE.KDBSLSH.AND.INHTMRTF.EQ.0)  THEN
C           Don't want to call IGNOR (CAP calls IGNOR) twice on '\',
C           or the '\' at the beginning of an RTF command will be
C           interpreted as a simple backslash. (i.e. two successive backslashes)
            CALL CAP (I, ICAP)
          ENDIF
          IF (I.EQ.KBLANK.AND.IOUT(JOUT,LUNTYP).EQ.KBLANK)  GOTO 150
          IF (I.EQ.KAT) THEN
C           @symbol - substitution required
            CALL SUBSTIT (IBF, N, JIN, IHTML, HTML, MAXHTML, REPLSTR,
     *        256, LSTR)
          ELSE IF (KIGNOR.EQ.0.AND.I.EQ.KLBRACE.AND.
     *             JIN+1.LE.N.AND.IBF(JIN+1).EQ.KRBRACE) THEN
              LSTR = -1
C             SKIP {} IN TEXT.
              JIN = JIN + 1
          ELSE IF (INHTMRTF.NE.0.OR.IHTML.EQ.0.OR.I.LT.32.OR.
     *     HTML(I)(1:1).EQ.CHAR(KBLANK))  THEN
            LSTR = 0
          ELSE
            LSTR = 0
            IF (I.EQ.KDBSLSH)  THEN
C             Backslash. Get RTF control word and replace with HTML equivalent.
C             Reset ICMD (set by IGNOR) to 0, because IGNOR not see the end of
C             the command, because it is handled by RTF2HTML.
              ICMD = 0
              CALL RTF2HTML (IBF, N, JIN, REPLSTR, LSTR)
            ELSE
              DO KK = 1, MAXHTML
                IF (HTML(I)(KK:KK).EQ.CHAR(KBLANK)) GOTO 145
                LSTR = LSTR + 1
              ENDDO
            ENDIF
          ENDIF
  145     IF (LSTR.LT.0)  THEN
C           Returned by RTF2HTML - ignore unrecognized RTF control word and don't
C           output the current character i.e. the leading backslash
            CONTINUE
          ELSEIF (LSTR.EQ.0)  THEN
            JOUT = JOUT + 1
            IOUT(JOUT,LUNTYP) = I
          ELSEIF (JOUT+LSTR.LE.ABS(LWIDTH(LUNTYP))) THEN
            DO KK = 1, LSTR
              JOUT = JOUT + 1
              IF (I.EQ.KDBSLSH.OR.I.EQ.KAT)  THEN
                IOUT(JOUT,LUNTYP) = ICHAR(REPLSTR(KK:KK))
              ELSE
                IOUT(JOUT,LUNTYP) = ICHAR(HTML(I)(KK:KK))
              ENDIF
            ENDDO
          ELSE
C           *** NOTE *** THIS ONLY WORKS HERE BECAUSE WE KNOW THE LENGTH
C           *** NOTE *** OF THE HTML STRINGS ARE LESS THAN THE BUFFER LENGTH.
C           EMPTY BUFFER.
C           IF NO PREVIOUS WORD BREAK ON LINE, BREAK AT CURRENT POSITION.
C           THEN WE CAN COME BACK AND USE EMPTIED BUFFER.
            IF (IENDWD(LUNTYP).LE.INDEN(LUNTYP)) IENDWD(LUNTYP)=JOUT
            INCHAR = I
            IDOREPL = 1
            NOBREAK = 0
            GOTO 210
          ENDIF
  150     JIN = JIN + 1
          GO TO 140
C
C-      WORD FITS.
  160   IENDWD(LUNTYP) = JOUT
        IF (JOUT.GE.ABS(LWIDTH(LUNTYP)))  GO TO 400
        JOUT = JOUT + 1
        IOUT(JOUT,LUNTYP) = KBLANK
        GO TO 400
C
C-      WORD DOES NOT FIT.
  200   NOBREAK = 0
 
        IF (IENDWD(LUNTYP).GT.INDEN(LUNTYP)) GOTO 210
C       NO PREVIOUS WORD BREAK ON LINE. SET WORD BREAK AT NEXT BLANK,
C       OR WHEN OUTPUT BUFFER IS FULL.
  202   IF (JIN.GT.N) GOTO 500
          IF (((INHTMRTF.EQ.0.OR.IBINARY.EQ.0).AND.IBF(JIN).EQ.KBLANK)
     *           .OR.JOUT.GE.LOUT) THEN
            IENDWD(LUNTYP) = JOUT
            IF (IBF(JIN).NE.KBLANK)  NOBREAK = 1
            GOTO 210
          ENDIF
          JOUT = JOUT + 1
          IOUT(JOUT,LUNTYP) = IBF(JIN)
          JIN = JIN + 1
        GOTO 202
C       OUTPUT LINE UP TO WORD BREAK.
  210   CALL WRTREC (IOUT(1,LUNTYP), IENDWD(LUNTYP), LUNTYP, 4)
C       See TYPOUT for an explanation of the line below. Basically,
C       it is a kludge to prevent a blank being inserted between output
C       buffers of RTF typesetting marks.
        IF (NOBREAK.NE.0.OR.
     *     (INHTMRTF.NE.0.AND.IENDWD(LUNTYP).GT.JOUTSV.AND.
     *      IBINARY.NE.0)) LENDRC = 1
        JOUTSV = 0
        JE = JOUT
        IF (IOUT(JE,LUNTYP).EQ.KBLANK)  JE = JE - 1
        I = IENDWD(LUNTYP)
C       .. ALLOW FOR WORD BREAK AT NON-BLANK (BY EXTERNAL SETTING
C       .. OF IENDWD).
        IF (I.LT.JE) THEN
          IF (IOUT(I+1,LUNTYP).EQ.KBLANK) I = I + 1
        ENDIF
C       START NEW LINE, AND COPY UNFINISHED WORD TO START OF BUFFER.
        CALL INDENT (INDEN(LUNTYP), LUNTYP)
        JOUT = JIOUT(LUNTYP)
  220   IF (I.GE.JE)  GO TO 230
          I = I + 1
          JOUT = JOUT + 1
          IOUT(JOUT,LUNTYP) = IOUT(I,LUNTYP)
        GO TO 220
C       Check if need to add HTML tags
  230   IF (IDOREPL.NE.0)  THEN
          IF (IDOREPL.EQ.1.AND.JOUT+LSTR.GT.ABS(LWIDTH(LUNTYP)))  THEN
            IDOREPL = 2
            IENDWD(LUNTYP) = JOUT
            GOTO 210
          ENDIF
          DO KK = 1, LSTR
            IF (JOUT.GE.ABS(LWIDTH(LUNTYP)))  THEN
              IF (IENDWD(LUNTYP).GT.INDEN(LUNTYP))  THEN
C               Output record breaking at last word.
                JE = JOUT
                I = IENDWD(LUNTYP)
                CALL WRTREC (IOUT(1,LUNTYP), IENDWD(LUNTYP), LUNTYP, 4)
                CALL INDENT (INDEN(LUNTYP), LUNTYP)
                JOUT = JIOUT(LUNTYP)
                IF (IOUT(I+1,LUNTYP).EQ.KBLANK)  I = I + 1
C               Copy remainder of buffer to start of IOUT(,LUNTYP).
                DO KKK = I+1, JE
                  IF (IOUT(I,LUNTYP).EQ.KBLANK) IENDWD(LUNTYP) = JOUT
                  JOUT = JOUT + 1
                  IOUT(JOUT,LUNTYP) = IOUT(KKK,LUNTYP)
                ENDDO
              ELSE
C               No word breaks - output whole record.
                CALL WRTREC (IOUT(1,LUNTYP), JOUT, LUNTYP, 4)
                JOUT = 0
                IENDWD(LUNTYP) = 0
              ENDIF
            ENDIF 
            JOUT = JOUT + 1
            IF (INCHAR.EQ.KDBSLSH.OR.INCHAR.EQ.KAT)  THEN
              IOUT(JOUT,LUNTYP) = ICHAR(REPLSTR(KK:KK))
            ELSE
              IOUT(JOUT,LUNTYP) = ICHAR(HTML(INCHAR)(KK:KK))
            ENDIF
            IF (IOUT(JOUT,LUNTYP).EQ.KBLANK)
     *        IENDWD(LUNTYP) = MAX(0,JOUT-1)
          ENDDO
          IDOREPL = 0
          JIN = JIN + 1
          GOTO 140
        ELSE
          GOTO 420
        ENDIF
 
  400   JIN = JIN + 1
  420 IF (IBINARY.NE.0) GOTO 130
      GO TO 100
C
C     END OF INPUT BUFFER.
  500 IF (IE.LT.0)  GO TO 1000
      IF (IE.GT.0)  GO TO 600
C
      IF (JOUT.EQ.0)  GO TO 1000
      IF (IOUT(JOUT,LUNTYP).EQ.KBLANK)  GO TO 1000
      IENDWD(LUNTYP) = JOUT
      IF (JOUT.GE.ABS(LWIDTH(LUNTYP)))  GO TO 1000
      JOUT = JOUT + 1
      IOUT(JOUT,LUNTYP) = KBLANK
      GO TO 1000
C
  600 JIOUT(LUNTYP) = JOUT
      CALL BLKLIN (IE-1, 0, LUNTYP)
      JOUT = 0
C
 1000 JIOUT(LUNTYP) = JOUT
 
 1100 RETURN
      END
      SUBROUTINE JSTSTR (S, IWORK, LWORK, IE, LUNTYP, IHTML)                INOU
 
C  REVISED 06-MAR-98.
C  OUTPUTS A CHARACTER STRING VIA JSTOUT.
 
C  S RECEIVES THE STRING TO BE OUTPUT.
C  IWORK RECEIVES WORKING SPACE.
C  LWORK RECEIVES THE LENGTH OF IWORK.
C  IE RECEIVES A FLAG SPECIFYING THE ACTION AFTER OUTPUT.
C    NEGATIVE - LAST WORD LEFT UNFINISHED. 0 - LAST WORD FINISHED.
C    POSITIVE - LINE FINISHED, AND (IE-1) EXTRA BLANK LINES.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT FOR OUTPUT.
C  IHTML RECEIVES WHETHER THIS CONATINS HTML.
 
      DIMENSION IWORK(LWORK)
      CHARACTER*(*) S
 
      LSTR = LEN(S)
      I = 1
      DO WHILE (LSTR.GT.0)
        NCPY = MIN(LSTR, LWORK)
        CALL COPSIA (S(I:), IWORK, NCPY)
        LSTR = LSTR - NCPY
        I = I + NCPY
        IF (LSTR.GT.0)  THEN
          JE = -1
        ELSE 
          JE = IE
        ENDIF
        CALL JSTOUT (IWORK, NCPY, JE, LUNTYP, IHTML)
      ENDDO
 
      RETURN
      END
      SUBROUTINE JSTR (R, NDEC, IE, LUNTYP, IVDEC)                          INOU
 
C  REVISED 14-MAR-91.
C  ENCODES AND OUTPUTS A REAL VIA JSTOUT.
 
C  R RECEIVES THE REAL TO BE OUTPUT.
C  NDEC RECEIVES THE NUMBER OF FIGURES REQUIRED IN THE RESULT
C    (SEE SUBR. RNKOD).
C  IE RECEIVES A FLAG SPECIFYING THE ACTION AFTER OUTPUT.
C    NEGATIVE - LAST WORD LEFT UNFINISHED. 0 - LAST WORD FINISHED.
C    POSITIVE - LINE FINISHED, AND (IE-1) EXTRA BLANK LINES.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT FOR OUTPUT.
C  IVDEC RECEIVES WHETHER TO USE THE DECIMAL POINT DEFINED IN THE VOCABULARY.
 
      DIMENSION IW(20)
 
      DATA LW/20/
 
      CALL RNKOD (R, NDEC, IW, JW, LW, IVDEC)
      IF (JW.GT.0)  GO TO 20
      CALL MESSA (84, 1, 0)
      JW = LW
   20 CALL JSTOUT (IW, JW, IE, LUNTYP, 0)
      RETURN
      END
      SUBROUTINE JSTS (K, IE, LUNTYP)                                       INOU
C
C  REVISED 16/7/85.
C  OUTPUTS A SINGLE SYMBOL VIA JSTOUT.
C
C  K RECEIVES THE SYMBOL TO BE OUTPUT.
C  IE RECEIVES A FLAG SPECIFYING THE ACTION AFTER OUTPUT.
C    NEGATIVE - LAST WORD LEFT UNFINISHED. 0 - LAST WORD FINISHED.
C    POSITIVE - LINE FINISHED, AND (IE-1) EXTRA BLANK LINES.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT FOR OUTPUT.
C
      DIMENSION L(1)
 
      L(1) = K
      CALL JSTOUT (L, 1, IE, LUNTYP, 0)
      RETURN
      END
      SUBROUTINE LCOUNT (LUN)                                               INOU
 
C* REVISED 15-DEC-93.
C* COUNTS OUTPUT RECORDS, AND HANDLES PAGINATION.
 
C  LUN RECEIVES THE LOGICAL UNIT.
 
C  IF A NEW PAGE IS NOT REQUIRED, LUNREC(LUN) IS INCREMENTED.
C    OTHERWISE, LUNREC(LUN) IS SET TO 1, AND A FORMFEED AND LTOP BLANK
C    LINES ARE OUTPUT.
 
      COMMON /BINXXX/ IENDRC,LENDRC,INSBLK
      COMMON /BLKXXX/ KBLANK
      COMMON /FFFXXX/ KFF
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
 
 
      IF (LUNPAG(LUN).EQ.0 .OR.
     *  (LUNREC(LUN).GE.0.AND.LUNREC(LUN).LT.LPRINT)) THEN
        LUNREC(LUN) = LUNREC(LUN) + 1
      ELSE
C       OUTPUT FORMFEED.
C       BINARY FILE ?
        LUNTYP = LUNUSE(LUN)
        IF (LUNTYP.EQ.3)  THEN
          IENDRC = 0
          CALL WRECB(KFF, 1, LUN)
        ELSE
          CALL WREC (KFF, 1, LUN)
        ENDIF
        LUNREC(LUN) = 1
 
C       OUTPUT BLANK LINES AT TOP OF PAGE.
        IF (LUNTYP.EQ.3.AND.LWIDTH(3).GT.0)  IENDRC = 1
        DO 50 I = 1, LTOP
          IF (LUNTYP.EQ.3)  THEN
            CALL WRECB (KBLANK, 1, LUN)
          ELSE
            CALL WREC (KBLANK, 1, LUN)
          ENDIF
   50   CONTINUE
        IENDRC = 0
      ENDIF
 
      RETURN
      END
      FUNCTION   LSTR (SBF)                                                 INOU
 
C* REVISED 27/7/87.
C* FINDS THE LENGTH OF A CHARACTER STRING DELIMITED BY '%'.
 
C  THE FUNCTION RETURNS LENGTH OF THE STRING, EXCLUDING THE DELIMITER.
C  SBF RECEIVES THE STRING, DELIMITED BY '%' AT THE END.
 
      CHARACTER SBF*(*)
 
      LBF = LEN(SBF)
      DO 10 I = 1, LBF
        IF (SBF(I:I).EQ.'%')  GOTO 20
   10 CONTINUE
 
   20 IF (I.LE.1 .OR. I.GT.LBF)  CALL BUG (27, I)
      LSTR = I - 1
 
      RETURN
      END
      FUNCTION   LSTRB (SBF)                                                INOU
 
C* REVISED 27/7/87.
C* FINDS THE LENGTH OF A CHARACTER STRING DELIMITED BY BLANK.
 
C  THE FUNCTION RETURNS LENGTH OF THE STRING, EXCLUDING THE BLANK.
C  SBF RECEIVES THE STRING, DELIMITED BY BLANK AT THE END.
 
      COMMON /BLKXXX/ KBLANK
 
      CHARACTER SBF*(*)
 
      L = INDEX(SBF,CHAR(KBLANK)) - 1
      IF (L.LT.0) L = LEN(SBF)
      LSTRB = L
 
      RETURN
      END
      SUBROUTINE MORMEM(NL,LW)                                              INOU
 
C* REVISED 26-JUL-89.
C* PRINTS MESSAGE - NOT ENOUGH STORAGE - AND TERMINATES.
 
C  NL RECEIVES THE LENGTH REQUIRED.
C  LW RECEIVES THE LENGTH AVAILABLE.
 
      DIMENSION IVAL(2)
 
      IVAL(1) = NL
      IVAL(2) = LW
      CALL MESSB (85, IVAL, 2, -3, 1)
 
  200 RETURN
      END
      SUBROUTINE MPRT (IPOINT, LUNTYP)                                      INOU
C
C  REVISED 9/4/86.
C  PRINTS INPUT LINE, WITH POSITION INDICATED BY AN ARROW.
C
C  IPOINT RECEIVES THE POSITION IN THE INPUT BUFFER (IBUF)
C    UNDER WHICH THE ARROW WILL BE PRINTED.
C  LUNTYP RECEIVES THE LOGICAL UNIT TYPE FOR OUTPUT.
C
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
      JPOINT = MIN0(MAX0(IPOINT,0),JEDAT)
      CALL IPRT (LUNTYP, JPOINT)
      CALL ARROW (JPOINT, LUNTYP)
      RETURN
      END
      SUBROUTINE NEXTWD (JE)                                                INOU
C
C  REVISED 10/11/77.
C  FINDS THE NEXT WORD.
C
C  JE RETURNS THE POSITION IMMEDIATELY AFTER THE END OF THE WORD.
C
C  ON EXIT, JBUF IS AT THE START OF THE WORD.
C
      COMMON /BLKXXX/ KBLANK
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
      CALL SKNONB
      JE = JBUF + 1
   10 IF (IBUF(JE).EQ.KBLANK)  GO TO 20
        JE = JE + 1
        GO TO 10
   20 RETURN
      END
      FUNCTION   NONZER (IA, N)                                             INOU
C
C  REVISED 5/2/80.
C  COUNTS NON-ZERO ELEMENTS OF AN INTEGER ARRAY.
C
C  IA RECEIVES THE ARRAY TO BE COUNTED.
C  N RECEIVES THE LENGTH OF IA.
C
      DIMENSION IA(N)
C
      NONZER = 0
      DO 10 I = 1, N
        IF (IA(I).NE.0)  NONZER = NONZER + 1
   10   CONTINUE
      RETURN
      END
      SUBROUTINE OUTNUM (R, IDAT, JB, LL, IVDEC)                            INOU
 
C  REVISED 14-MAR-91.
C  INSERT NUMERIC INTO INTEGER ARRAY.
 
      COMMON /BLKXXX/ KBLANK
 
      PARAMETER (LW=20)
      DIMENSION IW(LW),IDAT(1)
 
      CALL RNKOD (R, -5, IW, JW, LW, IVDEC)
      CALL COPIA (IW, IDAT(JB+1), JW)
      JB = JB + JW
      LL = LL - JW
      CALL OUTSYM (KBLANK, IDAT, JB, LL)
      RETURN
      END
      SUBROUTINE OUTSYM (KSYM, IDAT, JB, LL)                                INOU
 
C  REVISED 15-SEP-92.
C  INSERT SYMBOL INTO INTEGER ARRAY.
 
      DIMENSION IDAT(1)
 
      IF (LL.GT.0)  THEN
        IDAT(JB+1) = KSYM
        JB = JB + 1
        LL = LL - 1
      ENDIF
      RETURN
      END
      SUBROUTINE OUTWRD (IWD, IDAT, LIDAT, JB, LL)                          INOU
 
C  REVISED 15-SEP-92.
C  INSERT WORD STRING INTO INTEGER ARRAY.
 
      COMMON /BLKXXX/ KBLANK
      COMMON /VWDXXX/ VWORD(18)
        CHARACTER*40 VWORD
      COMMON /VLWXXX/ NVWD,MAXVWD,LVWD(18),IBPUNC,IEPUNC,
     * KVSTOP,KVCOM1,KVCOM2,KVSEMI,KVDEC
 
      DIMENSION IDAT(LIDAT)
 
      NCOPY = MIN(LVWD(IWD), LL)
 
      CALL COPSIA (VWORD(IWD), IDAT(JB+1), NCOPY)
      JB = JB + LVWD(IWD)
      LL = LL - LVWD(IWD)
      CALL OUTSYM (KBLANK, IDAT, JB, LL)
      RETURN
      END
      SUBROUTINE PRANGE (ITS, ITYPMK, LIDAT, LUNTYP)                        INOU
 
C* REVISED 13-MAY-91.
C* OUTPUTS 'RANGE' OR 'AND' SYMBOL.
C
C  ITS RECEIVES 1 FOR 'RANGE', 2 FOR 'AND'.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  LIDAT RECEIVES THE LENGTH OF ITYPMK.
C  LUNTYP RECEIVES THE TYPE OF THE OUTPUT LOGICAL UNIT.
C
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
C
      IF (ITS.NE.1)  GO TO 20
C
      IF (ITPSET.GT.0 .AND. LUNTYP.EQ.3)  GO TO 10
      CALL JSTS (KDRANG, -1, LUNTYP)
      GO TO 100
C     [X-]
   10 CALL JSTTPS (1, ITYPMK, LIDAT, NTYPMK, LUNTYP)
      GO TO 100
C
   20 CALL JSTS (KDAMP, -1, LUNTYP)
C
  100 RETURN
      END
      SUBROUTINE PROGID (LUNTYP)                                            INOU
 
C* REVISED 11-JUN-91.
C* OUTPUTS PROGRAM IDENTIFICATION.
 
C  LUN RECEIVES THE LOGICAL UNIT FOR THE OUTPUT.
 
      COMMON /BLKXXX/ KBLANK
      COMMON /PIDXXX/ PID
        CHARACTER*230 PID
 
      DIMENSION MBUF(230)
      CHARACTER ENDLN*1, MESS*200
      PARAMETER(ENDLN='|')
 
      IB = 1
      L = LSTR(PID)
   10 L1 = INDEX(PID(IB:L), ENDLN) - 1
      IF (L1.LT.0)  L1 = L - IB + 1
      IF (L1.GT.0)  THEN
        CALL COPSIA (PID(IB:IB+L1-1), MBUF, L1)
        CALL WRTREC (MBUF, L1, LUNTYP, 4)
      ELSE
        CALL WRTREC(KBLANK, 1, LUNTYP, 4)
      ENDIF
      IB = IB + L1 + 1
      IF (IB.LE.L)  GOTO 10
 
C     OUTPUT NAMES OF TRANSLATORS OF MESSAGES.
      CALL FETMES (133, MESS, LMESS, IDUM)
      IF (LMESS.GT.1)  THEN
        CALL COPSIA (MESS, MBUF, LMESS-1)
        CALL WRTREC (MBUF, LMESS-1, LUNTYP, 4)
        CALL WRTREC(KBLANK, 1, LUNTYP, 4)
      ENDIF
 
      RETURN
      END
      SUBROUTINE RDBUF                                                      INOU
 
C* REVISED 14-AUG-00.
C* READS NEXT INPUT RECORD.
C
C  A RECORD OF LENGTH MIREC IS READ FROM LOGICAL UNIT LUNI AND STORED
C    IN IBUF, 1 SYMBOL PER WORD.
C  THE FIRST BLANK-TERMINATED GROUP OF SYMBOLS ON EACH RECORD IS
C    INTERPRETED AS A SEQUENCE NUMBER, UNLESS THE FIRST SYMBOL IS BLANK
C    OR ISEQ=0. THE SEQUENCE NUMBERS MUST BE POSITIVE REAL NUMBERS
C    (A DECIMAL POINT IS OPTIONAL) AND IN ASCENDING ORDER.
C    AN EMPTY SEQUENCE FIELD IS LEGAL ANYWHERE.
C  IF A SEQUENCE NUMBER IS INVALID OR OUT OF SEQUENCE, NCERR AND NSERR
C    ARE INCREMENTED AND A MESSAGE IS PRINTED.
C  SEQ IS SET TO THE SEQUENCE NUMBER READ, UNLESS IT IS INVALID
C    (NOT MERELY OUT OF SEQUENCE), WHEN SEQ IS NOT CHANGED.
C    IF THE SEQUENCE FIELD IS EMPTY, SEQ IS SET TO 0.
C  JBDAT IS SET TO THE POSITION OF THE START OF THE DATA FIELD.
C  JEDAT IS SET TO THE POSITION 1 PAST THE END OF THE DATA FIELD,
C    AND THIS LOCATION IN IBUF IS SET TO BLANK.
C  IF ILISTD IS NEGATIVE, EACH RECORD IS LISTED ON LUNO BEFORE THE NEXT
C    RECORD IS READ. IF ILISTD IS POSITIVE, THE CURRENT RECORD
C    (IF IT EXITS) IS LISTED ON LUNO AFTER IT IS READ.
C  THE CURRENT VALUE OF LUNI IS SAVED IN LLUNI.
C  THE TOTAL NUMBER OF RECORDS READ IS ACCUMULATED IN LUNREC(LUNI).
C  JBUF IS SET TO JBDAT.
C
C  THE END OF AN EMPTY FIELD IS CONSIDERED TO BE IMMEDIATELY BEFORE
C    ITS START.
C
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /EOFXXX/ IEOF
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /INQXXX/ ISEQ,SEQ,LIBUF,MIREC,LISIND,LLUNI,JLIS,LISOUT(132)
      COMMON /LISXXX/ ILISTC,ILISTD,ILISTI,ILISTP,NEM(19),NEMM
      COMMON /LUFXXX/ FNAME(19),LFNAME(19)
        CHARACTER FNAME*80
      COMMON /LUNDXX/ LUND
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
C
C     LIST PREVIOUS RECORD IF NECESSARY, AND INITIALIZE FLAGS.
      IF (ILISTD.NE.0)  CALL IPRT (2, -1)
      JLIS = 0
      CALL SETIA (NEM, NUN, -1)
      LLUNI = LUNI
      JEDAT = 0
      IEOF = 0
 
C-    READ NEXT RECORD.
      CALL RREC (IBUF, MIREC, LUNI, JEDAT)
C     *  FNAME(LUNI), LFNAME(LUNI), LUNREC(LUNI))
      LUNREC(LUNI) = LUNREC(LUNI) + 1
 
C     CHECK FOR END OF FILE.
      IF (JEDAT.LT.0) THEN
        IEOF = 1
        CLOSE (UNIT=LUNI)
        LUNUSE(LUNI) = -1
C        LUNREC(LUNI) = 0
        ISEQ = 0
        IF (LUNI.EQ.LUND)  THEN
          CALL COPSIA ('*END', IBUF, 4)
          JEDAT = 4
        ELSE
          CALL COPSIA ('*PREVIOUS INPUT FILE', IBUF, 20)
          JEDAT = 20
        ENDIF
      ENDIF
 
C     CHECK FOR TRUNCATED RECORD.
      ITRUNC = 0
      IF (JEDAT.GT.MIREC) THEN
        ITRUNC = JEDAT
        JEDAT = MIREC
      ENDIF
 
C     FIND LAST NON-BLANK ON RECORD.
   64 IF (JEDAT.LT.1)  GO TO 180
        IF (IBUF(JEDAT).NE.KBLANK)  GO TO 66
        JEDAT = JEDAT - 1
        GO TO 64
C
C-    CHECK SEQUENCE NUMBER, IF PRESENT.
   66 IF (ISEQ.EQ.0.OR.IBUF(1).EQ.KBLANK.OR.IBUF(1).EQ.KDSTAR) GO TO 180
C     FIND END OF SEQUENCE NUMBER.
      JES = 1
   70 IF (JES.GT.JEDAT)  GO TO 110
        IF (IBUF(JES).EQ.KBLANK)  GO TO 110
        JES = JES + 1
        GO TO 70
C     DECODE SEQUENCE NUMBER.
  110 CALL RDKOD (SEQN, IBUF, JES-1, ILEGAL)
      IF (ILEGAL.NE.0.OR.SEQN.LE.0.)  GO TO 140
      IF (SEQN.LE.SEQ)  GO TO 120
      ISEQ = 1
      SEQ = SEQN
      GO TO 200
C     ERROR MESSAGES.
  120 JEDAT = JEDAT + 1
      CALL MESSA (86, 3, 1)
      SEQ = SEQN
      GO TO 150
  140 IF (ISEQ.LT.0)  THEN
        JES = 0
        ISEQ = 0
        GOTO 200
      ELSE
        JEDAT = JEDAT + 1
        CALL MESSA (87, 3, ILEGAL)
      ENDIF
  150 NSERR = NSERR + 1
      SEQ = 0.
      JEDAT = JEDAT - 1
C
  180 SEQ = 0.
      JES = 0
C
C-    FIND START OF DATA FIELD.
  200 IF (JES.GE.JEDAT)  GO TO 500
      JBDAT = JES + 1
      IF (IBUF(JBDAT).EQ.KDSTAR)  ISEQ = 0
  250 IF (IBUF(JBDAT).NE.KBLANK)  GO TO 550
        JBDAT = JBDAT + 1
        GO TO 250
C-
C     EMPTY DATA FIELD.
  500 JBDAT = JEDAT + 1
C
  550 JEDAT = JEDAT + 1
      IBUF(JEDAT) = KBLANK
      JBUF = JBDAT
C     LONG RECORDS CAUSE TERMINATION OF PROGRAM.
      IF (ITRUNC.GT.0)  CALL MESSA (88, -3, ITRUNC)
 
C     LIST RECORD IF REQUIRED.
      IF (ILISTD.LT.0)  CALL IPRT (2, -1)
C
      RETURN
      END
      SUBROUTINE RDBUFS (ISTAR)                                             INOU
C
C* REVISED 12/6/83.
C* READS NEXT INPUT RECORD AND TESTS FOR STAR AT START.
C
C  ISTAR RETURNS 1 IF THE FIRST NON-BLANK SYMBOL OF THE RECORD IS
C    STAR (KDSTAR), OTHERWISE 0.
C
C  THE RECORD IS NOT PROCESSED FOR A SEQUENCE NUMBER.
C
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /INQXXX/ ISEQ,SEQ,LIBUF,MIREC,LISIND,LLUNI,JLIS,LISOUT(132)
C
      ISTAR = 0
      JSEQ = ISEQ
      ISEQ = 0
      CALL RDBUF
      DO 20 I = 1, JEDAT
        IF (IBUF(I).NE.KBLANK)  GO TO 40
   20   CONTINUE
      GO TO 100
C
   40 IF (IBUF(I).EQ.KDSTAR)  ISTAR = 1
C
  100 ISEQ = JSEQ
      END
      SUBROUTINE RDDAI (IA, N, LUN, LREC, IREC)                             INOU
 
C  REVISED 13-DEC-95.
C  READS N INTEGER WORDS FROM A DIRECT-ACCESS FILE INTO THE ARRAY IA.
C  READING COMMENCES AT RECORD IREC ON LOGICAL UNIT LUN.
 
      DIMENSION IA(N)
      DIMENSION IBUF(256)
 
      I = 0
      L = N
      JREC = IREC
      J = 0
 
      IF (LREC.GT.256)  CALL BUG (32, LREC)
 
      DO WHILE (L.GT.0)
        NREAD = MIN0(LREC, L)
        READ(LUN, REC=JREC)(IBUF(I),I=1,NREAD)
        DO I = 1, NREAD
          J = J +1 
          IA(J) = IBUF(I)
        END DO
        L = L - NREAD
        JREC = JREC + 1
      END DO

C   10 IF (L.LE.0)  GOTO 20
C        IREAD = MIN0 (L,LREC)
C        READ(LUN,REC=JREC) (IA(J),J=I+1,I+IREAD)
C        I = I + IREAD
C        JREC = JREC + 1
C        L = L - IREAD
C        GOTO 10
 
   20 RETURN
      END
      SUBROUTINE RDKOD (X, IBF, M, ILEGAL)                                  INOU
 
C  REVISED 29-AUG-88.
C  DECODES A REAL NUMBER FROM THE ARRAY IBF.
 
C  X RETURNS THE DECODED VALUE, OR 0 IF THE NUMBER IS INVALID.
C  IBF RECEIVES THE CHARACTERS TO BE DECODED.
C  M RECEIVES THE NUMBER OF CHARACTERS TO BE DECODED.
C  ILEGAL RETURNS 0 IF THE NUMBER IS VALID, OR THE POSITION OF THE
C    FIRST ILLEGAL CHARACTER OTHERWISE.
 
C  EMBEDDED AND TRAILING BLANKS ARE ILLEGAL.
 
C  NOTE: 13-MAR-91.
C  AS EFFICIENCY MEASURE, TRIED USING ARRAY LOOKUP INSTEAD OF FUNCTION CALL
C  TO DECODE VALUES WITH NO APPARENT IMPROVEMENT.
 
      DIMENSION IBF(M)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /NUMXXX/ KNUM(10),KDEC,KMINUS
 
      CHARACTER STR*20
 
      LOGICAL*4 DEC
 
      PARAMETER (LSTR = 20)
 
      X = 0.
      ILEGAL = 0
      DEC = .FALSE.
      I = 1
      STR = CHAR(KBLANK)
 
   10 IF (I.GT.M)  GO TO 100
        IF (IBF(I).NE.KBLANK)  GO TO 12
        I = I + 1
        GO TO 10
 
   12 LR = M - I + 1
      K = LSTR - LR
C     (NOTE: MINUS CAN ALSO MEAN NOT APPLICABLE.)
      IF (IBF(I).EQ.KMINUS)  THEN
        IF (I.GE.M)  GOTO 90
        GOTO 14
      ENDIF
 
   13 IF (IBF(I).EQ.KDEC)  THEN
        IF (DEC)  GOTO 90
        DEC = .TRUE.
        GOTO 14
      ENDIF
 
      IF (INUM(IBF(I)).LT.0)  GOTO 90
 
   14 K = K + 1
      STR(K:K) = CHAR(IBF(I))
      IF (I.GE.M)  GOTO 15
      I = I + 1
      GOTO 13
 
C     DECODE VALUE IN STR.
   15 READ (STR,'(F20.0)',ERR=90) X
      GOTO 100
 
   90 ILEGAL = I
      X = 0.
 
  100 RETURN
      END
      FUNCTION   RELIN(LR)                                                  INOU
 
C* REVISED 6/7/87.
C* RETURNS THE VALUE OF A REAL FROM THE INTEGER LOCATION LR.
 
      EQUIVALENCE (VS,LS)
 
      LS = LR
      RELIN = VS
 
      RETURN
      END
      SUBROUTINE RELOUT(VR,LR)                                              INOU
 
C* REVISED 6/7/87.
C* STORES THE REAL VALUE VR IN THE INTEGER LOCATION LR.
 
      EQUIVALENCE (VS,LS)
 
      VS = VR
      LR = LS
 
      RETURN
      END
      SUBROUTINE RNKOD (R, NDEC, IBF, JBF, LBF, IVDEC)                      INOU
 
C  REVISED 15-SEP-92.
C  ENCODES A REAL NUMBER.
 
C  R RECEIVES THE NUMBER TO BE ENCODED.
C  NDEC RECEIVES THE NUMBER OF FIGURES REQUIRED IN THE RESULT.
C    IF NDEC IS NON-NEGATIVE, THE NUMBER IS ENCODED TO NDEC DECIMAL
C    PLACES. IF NDEC IS NEGATIVE, THE NUMBER IS ENCODED TO -NDEC
C    SIGNIFICANT FIGURES, EXCEPT THAT TRAILING ZEROS AFTER THE DECIMAL
C    POINT ARE OMITTED, AND IF THERE ARE MORE THAN -NDEC FIGURES
C    BEFORE THE DECIMAL POINT, THE EXCESS FIGURES ARE NOT ROUNDED.
C    IF THERE IS NOT ENOUGH BUFFER SPACE TO ENCODE THE NUMBER IN
C    THE SPECIFIED FORMAT, THE SPECIFICATION IS RELAXED. IF THE NUMBER
C    STILL CANNOT BE ENCODED, JBF RETURNS THE VALUE 0.
C    THE NUMBER CANNOT BE ENCODED IF THE NUMBER OF SYMBOLS REQUIRED
C    IS GREATER THAN LBF, OR IF THE NUMBER OF DIGITS REQUIRED
C    IS GREATER THAN LW (THE LENGTH OF THE LOCAL ARRAY IW).
C  IBF RETURNS THE RESULT.
C  JBF RETURNS THE NUMBER OF SYMBOLS IN THE RESULT, OR 0 IF THE NUMBER
C    CANNOT BE ENCODED.
C  LBF RECEIVES THE LENGTH OF IBF.
C  IVDEC RECEIVES WHETHER TO USE THE DECIMAL POINT DEFINED IN THE VOCABULARY.
 
      DIMENSION IBF(LBF),IW(10)
C
      COMMON /NUMXXX/ KNUM(10),KDEC,KMINUS
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
      COMMON /VWDXXX/ VWORD(18)
        CHARACTER*40 VWORD
      COMMON /VLWXXX/ NVWD,MAXVWD,LVWD(18),IBPUNC,IEPUNC,
     * KVSTOP,KVCOM1,KVCOM2,KVSEMI,KVDEC
 
C     DETERMINES THE MAXIMUM NUMBER OF DIGITS WHICH CAN BE ENCODED.           =/
      DATA LW/10/                                                             =*
C
      IF (LBF.LT.1)  CALL BUG (8, LBF)
      LB = LBF
C
C-    ENCODE MINUS SIGN.
      JBF = 0
      A = R
      IF (R.GE.0.)  GO TO 20
      JBF = 1
      IBF(1) = KMINUS
      LB = LB - 1
      A = ABS(R)
C
C-    FIND REQUIRED NUMBER OF DIGITS.
   20 NBD = 1
   30 IF (A.LT.10.)  GO TO 34
        A = A*.1
        IF (NBD.GE.LW)  GO TO 150
        NBD = NBD + 1
        GO TO 30
C
   34 IF (NBD.LT.LB)  LB = LB - 1
      IF (NDEC.GE.0)  GO TO 42
      NZ = 0
      IF (A.EQ.0.)  GO TO 40
      AA = A
   36 IF (AA.GE.1.)  GO TO 40
        AA = AA*10.
        NZ = NZ + 1
C       ON CYBER 76, TRAPS TYPE-INTEGER ARGUMENT.                             C/
        IF (NZ.GT.400)  CALL BUG (11, 0)
        GO TO 36
   40 NE = MIN0(MAX0(-NDEC,NBD)+NZ,LB,LW)
      GO TO 48
   42 NE = MIN0(NBD+NDEC,LB,LW)
C
C-    EXTRACT FIGURES.
   48 J = 1
   50 IW(J) = MIN0(INT(A),9)
        A = A - FLOAT(IW(J))
        IF (J.GE.NE)  GO TO 60
        A = A*10.
        J = J + 1
        GO TO 50
C
   60 NE = J
      IF (A.LT.0.5)  GO TO 80
C
C-    ROUND UP.
      IW(J) = IW(J) + 1
   70 IF (IW(J).LE.9)  GO TO 80
        IW(J) = 0
        IF (J.LE.1)  GO TO 72
        J = J - 1
        IW(J) = IW(J) + 1
        GO TO 70
   72 IW(1) = 1
      NBD = NBD + 1
      IF (NE.GE.LB)  GO TO 80
      NE = NE + 1
      IW(NE) = 0
C
C-    CLEAN UP ZEROS.
   80 IF (NDEC.GE.0)  GO TO 90
   82 IF (NE.LE.NBD.OR.IW(NE).NE.0)  GO TO 90
        NE = NE - 1
        GO TO 82
   90 NB = 1
      IF (IW(1).EQ.0.AND.NBD.GT.1) NB = 2
C
C-    TRANSFER RESULT AND ADD DECIMAL POINT.
      IF (NE.LT.NBD)  GO TO 150
      DO 100 J = NB, NE
        IF (JBF+1.GT.LBF)  GOTO 150
        JBF = JBF + 1
        I = IW(J) + 1
        IBF(JBF) = KNUM(I)
        IF (J.NE.NBD)  GO TO 100
        IF (J.GE.NE)  GO TO 200
        IF (JBF+1.GT.LBF)  GOTO 150
        JBF = JBF + 1
        IF (IVDEC.EQ.0)  THEN
          IBF(JBF) = KDEC
        ELSE
C         USE VALUE OF DECIMAL POINT FROM THE VOCABULARY.
          IF (JBF+LVWD(18)-1.GT.LBF)  GOTO 150
          CALL COPSIA (VWORD(18), IBF(JBF), LVWD(18))
          JBF = JBF + LVWD(18) - 1
        ENDIF
  100   CONTINUE
      GO TO 200
C-
  150 JBF = 0
      CALL SETIA (IBF, LBF, KSTAR)
C-
  200 RETURN
      END
      SUBROUTINE RTF2HTML (IBF, N, JIN, HTMLSTR, LSTR)                      INOU
 
C  REVISED 1-MAY-00.
C  REPLACES RTF STRINGS WITH HTML.
 
      DIMENSION IBF(N)
      CHARACTER*(*) HTMLSTR
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /NUMXXX/ KNUM(10),KDEC,KMINUS
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
      COMMON /WRKXXX/ IWRK(132)
 
      CHARACTER*10 RTFWD(23),TEMP
      CHARACTER*8 RTF2HTM(24)
      INTEGER HEX2DEC
 
C     MAXHTML is maximum number of characters in an HTML control word.
C     MAXRTF is maximum number of characters in an RTF control word.
C     MSUBSUP is the position if the RTFWD array of the control word 'sub'.
      PARAMETER (MAXHTML=8, MAXRTF=10, MSUBSUP=21, NRTFWD=23)
 
      SAVE INSUBSUP

C     The control words \sub, \super and \nosupersub should always
C     be the last three words in the array.
      DATA (RTFWD(I),I=1,NRTFWD)
     */'b         ','b0        ','i         ','i0        ',
     * '~         ','{         ','}         ','\         ',
     * '_         ','-         ','u         ','''         ',
     * 'ldblquote ','rdblquote ','lquote    ','rquote    ',
     * 'par       ','endash  '  ,'emdash    ','line      ',
     * 'sub       ','super     ','nosupersub'/
 
      DATA (RTF2HTM(I),I=1,NRTFWD+1)
     */'<B>     ','</B>    ','<I>     ','</I>    ',
     * '&nbsp;  ','{       ','}       ','\       ',
     * '-       ','        ','        ','        ',
     * '&#145;  ','&#146;  ','&#145;  ','&#146;  ',
     * '<P>     ','&#150;  ','&#151;  ','<BR>    ',
     * '<SUB>   ','</SUB>  ','<SUP> ','</SUP>'/

      LHTML = 0
      NTEMP = 0
      II = 0
      DO WHILE (JIN+II.LT.N)
        II = II + 1
        K = IBF(JIN+II)
        IF (II.EQ.1) THEN
          IF (K.EQ.KDBSLSH) THEN
C           Special case: Have we got "\\" i.e a simple backslash?
            NTEMP = NTEMP + 1
            TEMP(NTEMP:NTEMP) = CHAR(K)
            KTERM = 0
            MATCH = 0
            GOTO 143
          ELSEIF (K.EQ.KMINUS) THEN
C           Special case: Optional hyphen (\-)
            NTEMP = NTEMP + 1
            TEMP(NTEMP:NTEMP) = CHAR(K)
            KTERM = 0
            GOTO 141
          ELSEIF (K.EQ.ICHAR(RTFWD(11)(1:1))) THEN
C           Special case:
C             \uN\'xx or \uNC - Unicode character and alternate character.
C             (where N is a Unicode character value expressed as a decimal
C                    \'xx is the hex value of a character
C                    C is the actual character)
C           Output the Unicode character as &#N; and skip over the alternate character.
C           Assume there will be one, and ONLY one, alternate character.
            MATCH = 11
            RTF2HTM(11)(1:2) = '&#'
            LHTML = 2
            KK = JIN + II + 1
C           Process decimal digits.
            IF (IBF(KK).EQ.KMINUS) THEN
C             Convert negative number to positive
              KK = KK + 1
              ISUM = 0
              DO WHILE (ISNUM(IBF(KK)).NE.0)
                ISUM = ISUM*10 + INUM(IBF(KK))
                KK = KK + 1
              ENDDO
              ISUM = ISUM + 32767
              CALL INKOD (ISUM, IWRK, NN, 132)
              DO IK = 1, NN
                LHTML = LHTML + 1
                RTF2HTM(11)(LHTML:LHTML) = CHAR(IWRK(IK))
              ENDDO
            ELSE
              DO WHILE (ISNUM(IBF(KK)).NE.0)
                LHTML = LHTML + 1
                RTF2HTM(11)(LHTML:LHTML) = CHAR(IBF(KK))
                KK = KK + 1
              ENDDO
            ENDIF
            KTERM = KDBSLSH
            LHTML = LHTML + 1
            RTF2HTM(11)(LHTML:LHTML) = CHAR(KSEMIC)
C           Skip over alternate character.
            IF (IBF(KK).EQ.KDBSLSH) THEN
              JIN = KK + 3
            ELSE
              JIN = KK
            ENDIF
            GOTO 150
          ELSEIF (K.EQ.ICHAR(RTFWD(12)(1:1))) THEN
C           Special case: \'xx - character whose hex value is xx.
            MATCH = 12
            JJ = JIN + II
            IVAL = 0
            DO I = 1, 2
              JJ = JJ + 1
              IVAL = IVAL*16 + HEX2DEC(IBF(JJ))
            ENDDO
            LHTML = 1
            RTF2HTM(MATCH)(1:1) = CHAR(IVAL)
            JIN = JIN + 3
            GOTO 150
          ENDIF
        ENDIF
C       Control word is terminated by '\' or other non-alpha character?
        IF (K.EQ.KBLANK.OR.K.EQ.KDBSLSH.OR.
     *      (K.NE.KMINUS.AND.ISNUM(K).EQ.0.AND.ISALPHA(K).EQ.0)) THEN
          KTERM = K
C         Check for {} as command terminator.
          IF (KTERM.EQ.KLBRACE.AND.IBF(JIN+II+1).EQ.KRBRACE)  THEN
            KTERM = KRBRACE
          ELSE
C             Case of \x, where x is some non-alphanumeric character
C             This is an RTF special symbol.
            IF (NTEMP.EQ.0)  THEN
              NTEMP = NTEMP + 1
              TEMP(NTEMP:NTEMP) = CHAR(K)
            ENDIF
          ENDIF
          GOTO 141
        ENDIF
        NTEMP = NTEMP + 1
C       If RTF command is greater than MAXRTF, then it is not in the table anyway
        IF (NTEMP.LE.MAXRTF) TEMP(NTEMP:NTEMP) = CHAR(K)
      ENDDO
  141 MATCH = 0
C     Is it in the table of conversions?
      NCMP = MIN(NTEMP, MAXRTF)
      DO II = 1, NRTFWD
        DO JJ = 1, NCMP
          IF (TEMP(JJ:JJ).NE.RTFWD(II)(JJ:JJ))  GOTO 142
        ENDDO
        MATCH = II
        IF (NCMP.LT.MAXRTF.AND.
     *    RTFWD(II)(NCMP+1:NCMP+1).NE.CHAR(KBLANK))  MATCH = 0
        IF (MATCH.NE.0)  GOTO 143
  142   CONTINUE
      ENDDO
  143 IF (MATCH.NE.0)  THEN
C       Handle subscripts and superscripts. (Note these match values
C       depend on the positions of the relevant control words in the
C       RTFWD array.)
C       \sub or \super?
        IF (MATCH.EQ.MSUBSUP.OR.MATCH.EQ.MSUBSUP+1) THEN
C         \super -> SUPER
          IF (MATCH.EQ.MSUBSUP+1) MATCH = MATCH + 1
          INSUBSUP = MATCH
C       \nosupersub? The line below assumes there was a previous \sub or \super.
        ELSE IF (MATCH.EQ.MSUBSUP+2) THEN
          MATCH = INSUBSUP + 1
        ENDIF
        DO KK = 1, MAXHTML
          IF (RTF2HTM(MATCH)(KK:KK).EQ.CHAR(KBLANK)) GOTO 144
          LHTML = LHTML + 1
        ENDDO
  144   CONTINUE
      ENDIF
C     Skip over RTF control word in input buffer.
      JIN = JIN + NTEMP
      IF (KTERM.EQ.KBLANK) THEN
        JIN = JIN + 1
      ELSEIF (KTERM.EQ.KRBRACE) THEN
C       Command is terminated by {}.
        JIN = JIN + 2
      ENDIF
  150 IF (MATCH.NE.0)  THEN
        IF (LHTML.EQ.0)  THEN
C         Signal caller to ignore this RTF control word.
          LSTR = -1
        ELSE
          LSTR = LHTML
          DO KK = 1, LHTML
            HTMLSTR(KK:KK) = RTF2HTM(MATCH)(KK:KK)
          ENDDO
        ENDIF
      ELSE
C       Signal caller to ignore this RTF control word.
        LSTR = -1
      ENDIF
 
      RETURN
      END
      SUBROUTINE SETIA (IA, N, IV)                                          INOU
C
C  REVISED 28/11/77.
C  SETS THE ARRAY IA TO IV.
C
C  IA RETURNS THE SET ARRAY.
C  N RECEIVES THE LENGTH OF IA.
C  IV RECEIVES THE VALUES TO BE SET IN IA.
C
      DIMENSION IA(N)
 
      DO 10 I = 1, N
   10   IA(I) = IV
 
      RETURN
      END
      SUBROUTINE SETLUN (FSPEC, LUN, LUNTYP)                                INOU
 
C* REVISED 1-OCT-92.
C* SETS ATTRIBUTES OF A NEW LOGICAL UNIT.
 
C  FSPEC RECEIVES THE FULL FILE SPECIFICATION.
C  LUN RECEIVES THE LOGICAL UNIT.
C  LUNTYP RECEIVES THE TYPE OF THE FILE.
 
C     NUMBER OF LOGICAL UNITS IN LUNXXX.
      PARAMETER (NU=15)                                                       =*
 
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /LUFXXX/ FNAME(19),LFNAME(19)
        CHARACTER FNAME*80
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
      COMMON /LUTXXX/ LUNTI,LUNTO
 
      CHARACTER*(*) FSPEC
      DIMENSION LU(NU)
      EQUIVALENCE (LU(1),LUNE)
 
C      CALL EXNAME (FSPEC, FNAME(LUN))
 
C     STORE FULL PATH NAME. 30-JUN-95.
      FNAME(LUN) = FSPEC
      LFNAME(LUN) = LSTRB(FNAME(LUN))
      LUNUSE(LUN) = LUNCOM(LUNTYP)
      LUNPRE(LUNTYP) = LU(LUNTYP)
      LU(LUNTYP) = LUN
C     IF (LUNUSE(LUN).GE.4.OR.LUN.EQ.LUNTO) LUNPAG(LUN) = 0
      IF (LUNUSE(LUN).LE.3.AND.LPRINT.GT.0) LUNPAG(LUN) = 1
      IF (LUNUSE(LUN).EQ.3.AND.LWIDTH(3).LT.0) LUNPAG(LUN) = 0
 
      RETURN
      END
      SUBROUTINE SETRA (RA, N, RV)                                          INOU
C
C  REVISED 16/12/77.
C  SETS THE ARRAY RA TO RV.
C
C  RA RETURNS THE SET ARRAY.
C  N RECEIVES THE LENGTH OF RA.
C  RV RECEIVES THE VALUES TO BE SET IN RA.
C
      DIMENSION RA(N)
C
      DO 10 I = 1, N
   10   RA(I) = RV
      RETURN
      END
      SUBROUTINE SKB                                                        INOU
C
C  REVISED 16/10/78.
C  SKIPS TO THE FIRST BLANK SYMBOL.
C
C  NEW RECORDS ARE READ IF REQUIRED.
C  ON EXIT, JBUF IS AT THE BLANK SYMBOL.
C
      COMMON /BLKXXX/ KBLANK
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
   10 IF (IBUF(JBUF).EQ.KBLANK)  GO TO 20
        JBUF = JBUF + 1
        GO TO 10
   20 RETURN
      END
      SUBROUTINE SKNONB                                                     INOU
C
C  REVISED 10/11/77.
C  SKIPS TO THE FIRST NON-BLANK CHARACTER.
C
C  NEW RECORDS ARE READ IF REQUIRED.
C  ON EXIT, JBUF IS AT THE NON-BLANK CHARACTER.
C
      COMMON /BLKXXX/ KBLANK
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
C
   10 IF (IBUF(JBUF).NE.KBLANK)  GO TO 20
        JBUF = JBUF + 1
        IF (JBUF.GT.JEDAT)  CALL RDBUF
        GO TO 10
   20 RETURN
      END
      SUBROUTINE SNKOD (R, NDEC, IBF, LBF, IVDEC)                           INOU
 
C  REVISED 14-MAR-91.
C  ENCODES A REAL NUMBER RIGHT-JUSTIFIED IN AN ARRAY.
 
C  R RECEIVES THE NUMBER TO BE ENCODED.
C  NDEC RECEIVES THE NUMBER OF FIGURES REQUIRED IN THE RESULT.
C    IF NDEC IS NON-NEGATIVE, THE NUMBER IS ENCODED TO NDEC DECIMAL
C    PLACES. IF NDEC IS NEGATIVE, THE NUMBER IS ENCODED TO -NDEC
C    SIGNIFICANT FIGURES, EXCEPT THAT TRAILING ZEROS AFTER THE DECIMAL
C    POINT ARE OMITTED, AND IF THERE ARE MORE THAN -NDEC FIGURES
C    BEFORE THE DECIMAL POINT, THE EXCESS FIGURES ARE NOT ROUNDED.
C    IF THERE IS NOT ENOUGH BUFFER SPACE TO ENCODE THE NUMBER IN
C    THE SPECIFIED FORMAT, THE SPECIFICATION IS RELAXED. IF THE NUMBER
C    STILL CANNOT BE ENCODED, IBF IS FILLED WITH STARS.
C  IBF RETURNS THE RESULT.
C  LBF RECEIVES THE LENGTH OF IBF.
C  IVDEC RECEIVES WHETHER TO USE THE DECIMAL POINT DEFINED IN THE VOCABULARY.
 
      DIMENSION IBF(LBF)
 
      COMMON /BLKXXX/ KBLANK
 
      IF (LBF.LE.0)  GO TO 100
      CALL RNKOD (R, NDEC, IBF, NBF, LBF, IVDEC)
      IF (NBF.LE.0)  GO TO 50
C
      J = NBF
      I = LBF
   10 IBF(I) = IBF(J)
        IF (J.LE.1)  GO TO 20
        I = I - 1
        J = J - 1
        GO TO 10
   20 I = I - 1
        IF (I.LT.1)  GO TO 100
        IBF(I) = KBLANK
        GO TO 20
C
   50 CALL MESSA (84, 1, 0)
C
  100 RETURN
      END
      SUBROUTINE SUBSTIT (IBF, N, JIN, IHTML, HTML, MAXHTML, REPLSTR,       INOU
     * LREPSTR, LSTR)
 
C  REVISED 07-JUN-99.
C  REPLACES KEYWORDS WITH REQUIRED TEXT.
 
      DIMENSION IBF(N)
      CHARACTER*8 HTML(32:255)
 
      COMMON /ALPLCX/ KLA,KLB,KLC,KLD,KLE,KLF,KLG,KLH,KLI,KLJ,KLK,KLL,
     *                KLM,KLN,KLO,KLP,KLQ,KLR,KLS,KLT,KLU,KLV,KLW,KLX,
     *                KLY,KLZ
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /NUMXXX/ KNUM(10),KDEC,KMINUS
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
      COMMON /TNAMEX/ TNAME,LTNAME
        CHARACTER*256 TNAME
      COMMON /WRKXXX/ IWRK(132)
 
      INTEGER HEX2DEC
      CHARACTER*8 KEYWD(2),TEMP
      CHARACTER*256 TXNAM
      CHARACTER*(*) REPLSTR
 
C     MAXKEY is maximum number of characters in a keyword.
      PARAMETER (MAXKEY=8, NKEY=2)
 
      DATA (KEYWD(I),I=1,NKEY)
     */'name   ','NAME    '/
 
      LSTR = 0
      NTEMP = 0
      DO II = 1, MAXKEY
        IF (JIN+II.GT.N) GOTO 20
        K = IBF(JIN+II)
        NTEMP = NTEMP + 1
        TEMP(NTEMP:NTEMP) = CHAR(K)
   20   MATCH = 0
C       Is it in the table of keywords?
        DO KK = 1, NKEY
          DO JJ = 1, NTEMP
            IF (TEMP(JJ:JJ).NE.KEYWD(KK)(JJ:JJ))  GOTO 30
          ENDDO
          MATCH = KK
          IF (NTEMP.LT.MAXKEY.AND.
     *      KEYWD(KK)(NTEMP+1:NTEMP+1).NE.CHAR(KBLANK))  MATCH = 0
          IF (MATCH.NE.0)  GOTO 40
   30     CONTINUE
        ENDDO
      ENDDO

   40 IF (MATCH.NE.0)  THEN
C       Skip over keyword in input buffer.
        JIN = JIN + NTEMP
        GOTO (100,100), MATCH
 
C       @name - insert taxon name, removing RTF marks and angle brackets (i.e. < and >)
 100    CONTINUE
C       Scan name for RTF command \uN\'xx or \uNC - Unicode character and
C       alternate character.
C       Need to insert approriate character - &#N; for HTML output,
C       else the alternate character.
        LTX = 0
        I = 1
        DO WHILE (I.LT.LTNAME)
          J = ICHAR(TNAME(I:I))
          IF (J.EQ.KDBSLSH.AND.ICHAR(TNAME(I+1:I+1)).EQ.KLU) THEN
            IF (IHTML.NE.0)  THEN
              TXNAM(LTX+1:) = '&#'
              LTX = LTX + 2
              KK = I + 2
              IF (TNAME(KK:KK).EQ.CHAR(KMINUS)) THEN
C               Convert negative number to positive
                KK = KK + 1
                ISUM = 0
                J = ICHAR(TNAME(KK:KK))
                DO WHILE (ISNUM(J).NE.0)
                  ISUM = ISUM*10 + INUM(J)
                  KK = KK + 1
                  J = ICHAR(TNAME(KK:KK))
                ENDDO
                ISUM = ISUM + 32767
                CALL INKOD (ISUM, IWRK, NN, 132)
                DO IK = 1, NN
                  LTX = LTX + 1
                  TXNAM(LTX:LTX) = CHAR(IWRK(IK))
                ENDDO
              ELSE
                J = ICHAR(TNAME(KK:KK))
                DO WHILE (ISNUM(J).NE.0)
                  LTX = LTX + 1
                  TXNAM(LTX:LTX) = TNAME(KK:KK)
                  KK = KK + 1
                  J = ICHAR(TNAME(KK:KK))
                ENDDO
              ENDIF
              LTX = LTX + 1
              TXNAM(LTX:LTX) = CHAR(KSEMIC)
              IF (TNAME(KK:KK).EQ.CHAR(KDBSLSH)) THEN
C               Skip over \'xx
                KK = KK + 4
              ELSE
C               Skip over single character
                KK = KK + 1
              ENDIF
            ELSE
C             Use alternate character.
              KK = I + 2
C             Skip over Unicode character value.
              DO WHILE (TNAME(KK:KK).EQ.CHAR(KMINUS).OR.
     *                  ISNUM(ICHAR(TNAME(KK:KK))).NE.0)
                KK = KK + 1
              ENDDO
              IF (TNAME(KK:KK).EQ.CHAR(KDBSLSH)) THEN
C               Covert hex code to decimal.
                KK = KK + 2
                IVAL = 0
                DO JJ = 1, 2
                  IVAL = IVAL*16 + HEX2DEC(ICHAR(TNAME(KK:KK)))
                  KK = KK + 1
                ENDDO
                LTX = LTX + 1
                TXNAM(LTX:LTX) = CHAR(IVAL)
              ELSE
                LTX = LTX + 1
                TXNAM(LTX:LTX) = TNAME(KK:KK)
                KK = KK + 1
              ENDIF
            ENDIF
            I = KK
          ELSE
            LTX = LTX + 1
            TXNAM(LTX:LTX) = TNAME(I:I)
            I = I + 1
          ENDIF
        ENDDO
C       Add final character.
        LTX = LTX + 1
        TXNAM(LTX:LTX) = TNAME(LTNAME:LTNAME)
        LSTR = 0
        DO 120 I = 1, LTX
          J = ICHAR(TXNAM(I:I))
          IF (J.EQ.KDLBRA.OR.J.EQ.KDRBRA) GOTO 120
          IF (IGNOR(J).EQ.0)  THEN
            IF ((I.LT.LTX.AND.TXNAM(I:I).EQ.CHAR(KDAMP).AND.
     *           TXNAM(I+1:I+1).EQ.CHAR(KDNUM)) .OR. IHTML.EQ.0
     *         .OR.J.LT.32.OR.HTML(J)(1:1).EQ.CHAR(KBLANK)) THEN
C             Copy character unchanged.
              LSTR = LSTR + 1
              REPLSTR(LSTR:LSTR) = TXNAM(I:I)
            ELSE
C             Convert characters to equivalent HTML.
              K = 1
              DO WHILE (K.LE.MAXHTML.AND.HTML(J)(K:K).NE.CHAR(KBLANK))
                LSTR = LSTR + 1
                REPLSTR(LSTR:LSTR) = HTML(J)(K:K)
                K = K + 1
              ENDDO
            ENDIF
          IF (LSTR.GE.LREPSTR)  GOTO 200
          ENDIF
  120   CONTINUE
      ENDIF
 
  200 RETURN
      END
      SUBROUTINE TAB (IND, LUNTYP)                                          INOU
C
C  REVISED 14/2/84.
C  SKIPS TO A GIVEN COLUMN IN THE OUTPUT BUFFER.
C
C  IND RECEIVES THE NUMBER OF THE LAST COLUMN TO BE SKIPPED..
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT.
C
      COMMON /BLKXXX/ KBLANK
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
C
      JOUT = JIOUT(LUNTYP)
      IF (IND.GT.ABS(LWIDTH(LUNTYP))-1)  GO TO 100
   20 IF (JOUT.GE.IND)  GO TO 100
        JOUT = JOUT + 1
        IOUT(JOUT,LUNTYP) = KBLANK
        GO TO 20
  100 JIOUT(LUNTYP) = JOUT
      RETURN
      END
      SUBROUTINE UCLOSE                                                     INOU
 
C* REVISED 2-SEP-99.
C* CLOSES FILES AND LISTS NAMES OF OUTPUT FILES.
 
C  NOTE. LUNPAG IS USED AS WORKING SPACE FOR FLAGS, AS ITS ORIGINAL
C    CONTENTS ARE NO LONGER NEEDED. 0 - DO NOT CLOSE FILE.
C    1 - CLOSE. 2 - CLOSE, LIST AS NON-EMPTY OUTPUT FILE.
C    3 - CLOSE AND DELETE. 4 - CLOSE AND DELETE, LIST AS EMPTY
C    OUTPUT FILE.
 
      LOGICAL*4 O,N,E
C     LENGTH OF LUNFLG MUST BE EQUAL TO NUN.                                  =/
      DIMENSION LUNFLG(18)                                                    =*
      CHARACTER*80 MBUF
 
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /LUFXXX/ FNAME(19),LFNAME(19)
        CHARACTER FNAME*80
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
      COMMON /LUTXXX/ LUNTI,LUNTO
 
 
   10 FORMAT (3X, A, '%')
 
C     WHETHER THERE ARE NON-EMPTY AND EMPTY OUTPUT FILES TO BE LISTED.
      N = .FALSE.
      E = .FALSE.
 
C--   SET FLAGS TO SHOW HOW EACH UNIT MUST BE TREATED.
      DO 100 LUN = 1, NUN
        L = LUNUSE(LUN)
 
C-      UNUSED OR TERMINAL.
        IF (L.LE.0 .OR. LUN.EQ.LUNTO .OR. LUN.EQ.LUNTI) THEN
          LUNFLG(LUN) = 0
 
C-      OUTPUT.
        ELSEIF (L.EQ.1 .OR. L.EQ.2 .OR. L.EQ.3 .OR. L.EQ.4 .OR.
     *    L.EQ.6 .OR. L.EQ.9) THEN
          IF (LUNREC(LUN).GT.0) THEN
            IF (L.EQ.9 .AND. NCERR.GT.0) THEN
              LUNFLG(LUN) = 3
            ELSE
              LUNFLG(LUN) = 2
              N = .TRUE.
            ENDIF
          ELSE
            IF (NCERR.GT.0) THEN
              LUNFLG(LUN) = 3
            ELSE
              LUNFLG(LUN) = 4
              E = .TRUE.
            ENDIF
          ENDIF
 
C-      SCRATCH.
        ELSEIF (L.EQ.5 .OR. L.EQ.10 .OR. L.EQ.11 .OR. L.EQ.12 .OR.
     *   L.EQ.13 .OR. L.EQ.14 .OR. L.EQ.15) THEN
          LUNFLG(LUN) = 3
 
C-      INPUT.
        ELSE
          LUNFLG(LUN) = 1
        ENDIF
 
  100 CONTINUE
 
C--   PRINT NAMES OF NON-EMPTY OUTPUT FILES.
      IF (N) THEN
        CALL BLKLIN (1, 2, 1)
        IF (LUNE.NE.LUNL) CALL BLKLIN (1, 2, 2)
        CALL MESSF (89, IDUM, 1)
        DO 200 LUN = 1, NUN
          IF (LUNFLG(LUN).EQ.2) THEN
            WRITE (MBUF,10) FNAME(LUN)(1:LFNAME(LUN))
            CALL MESS (MBUF)
          ENDIF
  200   CONTINUE
      ENDIF
 
C--   PRINT NAMES OF EMPTY OUTPUT FILES.
      IF (E) THEN
        CALL BLKLIN (1, 2, 1)
        IF (LUNE.NE.LUNL) CALL BLKLIN (1, 2, 2)
C        CALL MESSF (90, IDUM, 1)
        DO 300 LUN = 1, NUN
          IF (LUNFLG(LUN).EQ.4) THEN
            CALL MESSC (118, IDUM, 1, 0, 0, FNAME(LUN)(1:LFNAME(LUN)),
     *        LFNAME(LUN), 1)
C            WRITE (MBUF,10) FNAME(LUN)(1:LFNAME(LUN))
C            CALL MESS (MBUF)
          ENDIF
  300   CONTINUE
      ENDIF
 
C--   CLOSE FILES.
      DO 400 LUN = 1, NUN
        IF (LUNFLG(LUN).LE.0) GOTO 400
        INQUIRE (UNIT=LUN, OPENED=O)
        IF (.NOT.O) GOTO 400
        IF (LUNFLG(LUN).LE.2) THEN
c For g77, force write of EOF on output files.
c We need this if we are over-writing an old file
c          if (lunflg(lun).eq.2) ENDFILE(UNIT=LUN) 
          CLOSE (UNIT=LUN)
        ELSE
          CLOSE (UNIT=LUN, STATUS='DELETE')
        ENDIF
  400 CONTINUE
 
      RETURN
      END
C      SUBROUTINE UNJOUT (IBF, LBF, LREC, LUNTYP)                           INOU
CC
CC  REVISED 23/4/85.
CC  OUTPUTS THE CONTENTS OF AN ARRAY IN ONE OR MORE RECORDS OF SPECIFIED
CC   LENGTH. TYPESETTING MARKS ARE REMOVED.
CC
CC  IBF RECEIVES THE ARRAY.
CC  JBF RECEIVES THE NUMBER OF CHARACTERS TO BE OUTPUT.
CC  LREC RECEIVES THE MAXIMUM OUTPUT RECORD LENGTH.
CC  LUNTYP RECEIVES THE LOGICAL UNIT TYPE.
CC
C      DIMENSION IBF(LBF)
CC
C      COMMON /WRKXXX/ IWRK(132)
CC
C      J = 0
C      DO 100 I = 1, LBF
C        IF (IGNOR(IBF(I)).NE.0)  GOTO 100
C        J = J + 1
C        IWRK(J) = IBF(I)
C        IF (J.LT.LREC)  GOTO 100
C        CALL WRTREC (IWRK, J, LUNTYP, 4)
C        J = 0
C  100   CONTINUE
CC
C      IF (J.GT.0)  CALL WRTREC (IWRK, J, LUNTYP, 4)
CC
C      RETURN
C      END
      SUBROUTINE WRCSTR (ICSTR, LSTR, N, LUN, LREC, IREC)                   INOU
C
C  REVISED 20-FEB-96.
C  OUTPUTS A CHARACTER STRING AND THE LENGTHS OF ITS INTERNAL
C   SUBSTRINGS.
C
C  ICSTR RECEIVES THE INFORMATION TO BE OUTPUT IN INTEGER FORMAT.
C  LSTR RECEIVES THE TOTAL LENGTH OF ICSTR.
C  N RECEIVES THE NUMBER OF SUBSTRINGS. THE FIRST N ELEMENTS OF ICSTR
C   CONTAIN THE LENGTHS OF THE SUBSTRINGS.
C  LUN RECEIVES THE LOGICAL UNIT.
C  LREC RECEIVES THE RECORD LENGTH.
C  IREC RECEIVES AND RETURNS THE RECORD NUMBER.
C
C  THE LENGTH OF THE CHARACTER ARRAY C SHOULD AT LEAST BE EQUAL TO
C   THE RECORD LENGTH (IN CHARACTERS) OF THE DIRECT ACCESS FILE.
C   WE ARE USING A LOCAL ARRAY TO DO THE TRANSFER BECAUSE OF PROBLEMS
C   IN THE WINDOWS VERSION OF CONFOR WITH ARRAY INDICES > 64K.
C
      DIMENSION ICSTR(LSTR)
      CHARACTER*1 C(128)                                                      =*
C
      COMMON /WRDSIZ/ NBITS,NCHRWD
 
C     RECORD LENGTH IN CHARACTERS.
      LCREC = LREC * NCHRWD
      LS = LSTR - N
C
C--   OUTPUT LENGTHS.
      IF (N.GT.0)  CALL WRDAI (ICSTR, N, LUN, LREC, IREC)
C
      I = N
   60 IF (LS.LE.0)  GOTO 100
        IOUT = MIN0 (LS,LCREC)
        DO 70 K = 1, IOUT
          C(K) = CHAR(ICSTR(I+K))
   70     CONTINUE
        IREC = IREC + 1
        WRITE (LUN, REC=IREC) (C(K),K=1,IOUT)
        CALL LCOUNT (LUN)
        I = I + IOUT
        LS = LS - IOUT
        GOTO 60
C
  100 RETURN
      END
      SUBROUTINE WRDAI (IA, N, LUN, LREC, IREC)                             INOU
 
C* REVISED 21-FEB-96.
C* OUTPUTS AN INTEGER ARRAY TO A DIRECT ACCESS FILE.
 
      DIMENSION IA(N)
 
C     ***NOTE:  THE LENGTH OF IBUF MUST BE GREATER THAN OR EQUAL TO THE RECORD
C     LENGTH OF ANY DIRECT-ACCESS FILE THAT USES THIS FUNCTION.
C     WE ARE USING A LOCAL ARRAY TO DO THE TRANSFER BECAUSE OF PROBLEMS
C     IN THE WINDOWS VERSION OF CONFOR WITH ARRAY INDICES > 64K.
      DIMENSION IBUF(256)
 
      L = N
      I = 0
 
   10 IF (L.LE.0)  GOTO 100
        IOUT = MIN0 (L,LREC)
        IREC = IREC + 1
        DO K = 1, IOUT
          IBUF(K) = IA(I+K)
        ENDDO
        WRITE (LUN, REC=IREC) (IBUF(K),K=1,IOUT)
        CALL LCOUNT (LUN)
        I = I + IOUT
        L = L - IOUT
      GOTO 10
C
  100 RETURN
      END
      SUBROUTINE WRDAR (A, N, LUN, LREC, IREC)                              INOU
C
C  REVISED 20-FEB-96.
C  OUTPUTS A REAL ARRAY TO A DIRECT ACCESS FILE.
C
      DIMENSION A(N)
 
C     ***NOTE:  THE LENGTH OF BUF MUST BE GREATER THAN OR EQUAL TO THE RECORD
C     LENGTH OF ANY DIRECT-ACCESS FILE THAT USES THIS FUNCTION.
C     WE ARE USING A LOCAL ARRAY TO DO THE TRANSFER BECAUSE OF PROBLEMS
C     IN THE WINDOWS VERSION OF CONFOR WITH ARRAY INDICES > 64K.
      DIMENSION BUF(256)

C
      L = N
      I = 0
C
   10 IF (L.LE.0)  GOTO 100
        IOUT = MIN0 (L,LREC)
        IREC = IREC + 1
        DO K = 1, IOUT
          BUF(K) = A(I+K)
        ENDDO
        WRITE (LUN, REC=IREC) (BUF(K),K=1,IOUT)
        CALL LCOUNT (LUN)
        I = I + IOUT
        L = L - IOUT
        GOTO 10
C
  100 RETURN
      END
      SUBROUTINE WRTREC (IREC, LREC, LUNTYP, IOTYP)                         INOU
 
C  REVISED 23-SEP-92.
C  COUNTS AND WRITES A RECORD.
 
C  IREC RECEIVES THE RECORD, 1 SYMBOL PER ELEMENT.
C  LREC RECEIVES THE RECORD LENGTH.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT.
C  IOTYP RECEIVES THE TYPE OF OUTPUT. 1 - LIST ON ERROR UNIT.
C    2 - LIST ON LISTING UNIT. 3 - ERROR MESSAGE OR ARROW ASSOCIATED
C    WITH IT. 4 - OTHER. 5 - BLANK LINE.
C
      DIMENSION IREC(LREC),LU(10)
 
      COMMON /BINXXX/ IENDRC,LENDRC,INSBLK
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /LISXXX/ ILISTC,ILISTD,ILISTI,ILISTP,NEM(19),NEMM
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
      COMMON /LUTXXX/ LUNTI,LUNTO
C
      EQUIVALENCE (LU(1), LUNE)
C
      LUN = LU(LUNTYP)
 
C--   ADJUST NEM.
      GOTO (100,200,300,400,500), IOTYP
 
C-    LIST ON ERROR UNIT.
  100 IF (NEM(LUN).GE.2) GOTO 1000
      NEM(LUN) = NEMM
      IF (LUN.NE.LUNTO.AND.LUNPAG(LUN).NE.0) THEN
        IF (LPRINT-LUNREC(LUN).LT.3) THEN
          LUNREC(LUN) = LPRINT
        ELSE
          NEM(LUN) = MIN(NEM(LUN),LPRINT-LUNREC(LUN)-1)
        ENDIF
      ENDIF
      GOTO 500
 
C-    LIST ON LISTING UNIT.
  200 IF (NEM(LUN).GE.0)  GOTO 1000
      NEM(LUN) = NEMM
      IF (LUN.NE.LUNTO.AND.LUNPAG(LUN).NE.0) THEN
        IF (LPRINT-LUNREC(LUN).LE.0) THEN
          LUNREC(LUN) = LPRINT
        ELSE
          NEM(LUN) = MIN(NEM(LUN),LPRINT-LUNREC(LUN)-1)
        ENDIF
      ENDIF
      GOTO 500
 
C-    ERROR MESSAGE.
  300 NEM(LUN) = NEM(LUN) - 1
      GOTO 500
 
C-    OTHER.
  400 NEM(LUN) = MIN(NEM(LUN),0)
 
C--   OUTPUT THE LINE.
  500 CALL LCOUNT (LUN)
C     BINARY ?
      IF (LUNTYP.EQ.3)  THEN
        IF (LWIDTH(3).GT.0)  IENDRC = 1
        CALL WRECB (IREC, LREC, LUN)
        IENDRC = 0
      ELSE
        CALL WREC (IREC, LREC, LUN)
      ENDIF
 
C--
 1000 RETURN
      END
