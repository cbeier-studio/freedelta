      SUBROUTINE RDINTC (IT, IDAT, JTYPC, MINC, MAXC, ITMPTR, ITPTR, X,     TINT
     * NAFLG, LFLG)
 
C  REVISED 19-APR-93.
C  READS AND OUTPUTS NEXT INTEGER VALUE.
 
C  IT RECEIVES THE ITEM NUMBER.
C  IDAT RECEIVES THE DATA BUFFER.
C  JTYPC RECEIVES THE CHARACTER TYPE. -4=INTEGER TO BE OUTPUT AS REAL,
C   3=INTEGER TO BE OUTPUT AS BIT PATTERN.
C  MINC RECEIVES THE MINIMUM RECORDED VALUE FOR THE CHARACTER.
C  MAXC RECEIVES THE MAXIMUM RECORDED VALUE FOR THE CHARACTER.
C  ITMPTR RECEIVES AND RETURNS A POINTER TO THE ITEM IN IDAT.
C  ITPTR RECEIVES AND RETURNS A POINTER TO THE ITEM ON THE INPUT FILE.
C  X RETURNS THE RANGE IF THE CHARACTER IS OUTPUT AS REAL.
C  NAFLG RECEIVES WORKING SPACE TO STORE FLAGS FOR INAPPLICABLE
C   CHARACTERS.
C  LFLG RECEIVES THE LENGTH OF NAFLG.
 
      COMMON /DAOXXX/ IWOUT,IBOUT,IOUT(32)
      COMMON /LUNDAX/ LRECDA,IRECDA
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /SCR4XX/ LRECS4,IRECS4
      COMMON /WRDSIZ/ NBITS,NCHRWD
 
      PARAMETER (MAXINT=2**29, MININT=-MAXINT)
 
C     DIMENSION OF IBINT MUST BE EQUAL TO 1+(NSLIM2-1)/NBITS.                 */
      DIMENSION IBINT(7)                                                      =*
      DIMENSION IDAT(LRECS4),ITSF(3),JTSF(3),X(2),NAFLG(LFLG)
      LOGICAL BITTST
 
C     CHECK IF CHARACTER UNCODED FOR ENTIRE DATASET.
      IF (MINC.EQ.MAXINT.AND.MAXC.EQ.MININT)  THEN
        MAXC = MAXINT
        MINC = MAXINT
      ENDIF
 
      CALL SETIA (ITSF, 3, 0)
 
      IF (JTYPC.GT.0)  THEN
        CALL SETIA (IBINT, 7, 0)
        NS = MAXC - MINC + 1
        LESS = 0
        MORE = 0
      ELSE
        MINV = MAXINT
        MAXV = MININT
      ENDIF
 
      IF (ITMPTR.GT.LRECS4)  THEN
        CALL RDSCRI (IDAT, ITPTR)
        ITMPTR = 1
      ENDIF
      NR = IDAT(ITMPTR)
      ITMPTR = ITMPTR + 1
 
      ICODED = 0
      DO 100 IR = 1, NR
        DO 10 I = 1, 2
          IF (ITMPTR.GT.LRECS4)  THEN
            CALL RDSCRI (IDAT, ITPTR)
            ITMPTR = 1
          ENDIF
          IF (I.EQ.1)  THEN
            IB = IDAT(ITMPTR)
          ELSE
            IE = IDAT(ITMPTR)
          ENDIF
          ITMPTR = ITMPTR + 1
   10   CONTINUE
 
        CALL SETIA (JTSF, 3, 0)
C       CHECK FOR PSEUDO VALUES.
C       VARIABLE.
        IF (IB.EQ.MAXINT.AND.IE.EQ.MAXINT-1)  JTSF(1) = 1
C       UNKNOWN.
        IF (IB.EQ.MAXINT.AND.IE.EQ.MININT)  JTSF(2) = 1
C       NOT APPLICABLE.
        IF (IB.EQ.MININT.AND.IE.EQ.MININT-1)  JTSF(3) = 1
 
        IF (JTYPC.GT.0)  THEN
          NS = MAXC - MINC + 1
          IF (JTSF(1).NE.0)  THEN
            DO 20 IS = 1, NS
              CALL SETBIT (IS+1, IBINT, NBITS)
   20       CONTINUE
          ELSEIF (JTSF(2).NE.0)  THEN
            CONTINUE
          ELSE IF (JTSF(3).NE.0)  THEN
            CALL SETBIT (NS+3, IBINT, NBITS)
          ELSE
            DO 30 IS = IB, IE
              IF (IS.LT.MINC)  THEN
                LESS = 1
              ELSEIF (IS.GT.MAXC)  THEN
                MORE = 1
              ELSE
                CALL SETBIT (IS-MINC+2, IBINT, NBITS)
              ENDIF
   30       CONTINUE
          ENDIF
        ELSE
          IF (JTSF(3).NE.0)  THEN
            ITSF(3) = 1
          ELSE
            MINV = MIN (IB, MINV)
            MAXV = MAX (IE, MAXV)
            ICODED = 1
          ENDIF
        ENDIF
 
  100 CONTINUE
 
      IF (JTYPC.GT.0)  THEN
        IF (LESS.NE.0)  CALL SETBIT (1, IBINT, NBITS)
        IF (MORE.NE.0)  CALL SETBIT (NS+2, IBINT, NBITS)
C       COPY BIT PATTERN TO OUTPUT BUFFER.
        DO 140 IS = 1, NS+3
          IF (IBOUT.GE.NBITS)  THEN
            IF (IWOUT.GE.LRECDA)  THEN
              CALL WRDAI (IOUT, IWOUT, LUNDA, LRECDA, IRECDA)
              CALL SETIA (IOUT, LRECDA, 0)
              IWOUT = 0
            ENDIF
            IWOUT = IWOUT + 1
            IBOUT = 0
          ENDIF
          IBOUT = IBOUT + 1
          IF (BITTST(IS, IBINT, NBITS))
     *     CALL SETBIT (IBOUT, IOUT(IWOUT), NBITS)
  140   CONTINUE
 
      ELSE
C       CONVERT TO REAL.
        IF (ITSF(3).NE.0)  CALL SETBIT (IT, NAFLG, NBITS)
        IF (ICODED.EQ.0)  THEN
          X(1) = 1.
          X(2) = 0.
        ELSE
          X(1) = FLOAT (MINV)
          X(2) = FLOAT (MAXV)
        ENDIF
        DO 150 I = 1, 2
          IWOUT = IWOUT + 1
          CALL RELOUT (X(I), IOUT(IWOUT))
          IF (IWOUT.GE.LRECDA)  THEN
            CALL WRDAI (IOUT, IWOUT, LUNDA, LRECDA, IRECDA)
            CALL SETIA (IOUT, LRECDA, 0)
            IWOUT = 0
          ENDIF
  150   CONTINUE
      ENDIF
 
      RETURN
      END
      SUBROUTINE PROCI (IC, JTYPC, INTGRS, N, LIM, MIN, MAX)                TINT
 
C  REVISED 26-JUL-89.
C  PROCESSES INTEGER DATA IF NUMBER OF STATES EXCEEDS SPECIFIED LIMIT.
 
C  JTYPC RECEIVES AND RETURNS THE CHARACTER TYPE.
C  INTGRS RECEVIES AND RETURNS THE SET OF INTEGERS.
C  N RECEIVES THE LENGTH ON INTGRS.
C  LIM RECEIVES THE MAXIMUM NUMBER OF STATES PERMITTED.
C  MIN RETURNS THE MINIMUM OF VALUE IN INTGRS.
C  MAX RETURNS THE MAXIMUM OF VALUE IN INTGRS.
 
      DIMENSION INTGRS(N)
 
      NKEPT = INTGRS(1)
      NLOST = INTGRS(2)
 
   10 IF (NKEPT.LE.NLOST) GOTO 100
      NKEPT = NKEPT - 1
      NLOST = NLOST + 1
      DO 20 I = 1, NKEPT
        IF (INTGRS(I+2).LT.MIN)  MIN = INTGRS(I+2)
        IF (INTGRS(I+2).GT.MAX)  MAX = INTGRS(I+2)
   20 CONTINUE
      NS = MAX - MIN + 1
      IF (NS.GT.LIM)  THEN
        ITMP = MIN
        MIN = MAX
        MAX = ITMP
        GOTO 10
      ENDIF
      GOTO 200
 
  100 CALL MESSB (106, IC, 1, 2, 0)
      JTYPC = -4
 
  200 RETURN
      END
