      SUBROUTINE ADDEMPC (IDAM, IDAV, ICDEP, LIDAT, IREC, IEMPC,            ITEM
     * NSTAT, ITYPC, NC, ICSTAT, ISTAT, MS)
 
C  REVISED 7-NOV-96.
C  ADDS EMPHASIZED CHARACTERS TO A VARIANT ITEM SO THAT THEY WILL BE OUTPUT
C  IN NATURAL LANGUAGE DESCRIPTIONS.
 
C  IDAM RECEIVES THE MASTER ITEM.
C  IDAV RECEIVES AND RETURNS THE VARIANT ITEM.
C  ICDEP RECEIVES DEPENDENCY INFORMATION.
C  LIDAT RECEIVES THE LENGTH OF IDAM, IDAV.
C  IREC RECEIVES THE SCRATCH FILE RECORD NUMBER CONTAINING THE LIST OF
C   EMPHASIZED CHARACTERS.
C  IEMPC RECEIVES WORKING SPACE FOR THE LIST OF EMPHASIZED CHARACTERS.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
 
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /SCRCXX/ LRECSC
 
      DIMENSION IDAM(LIDAT),IDAV(LIDAT),ICDEP(LIDAT),IEMPC(NC),
     * NSTAT(NC),ITYPC(NC),ICSTAT(MS),ISTAT(MS),ITSF(3)
 
      CALL RDDAI (IEMPC, NC, LUNS5, LRECSC, IREC)
 
C     REMOVE ANY CHARACTERS FROM THE LIST THAT ARE IMPLICITLY INAPPLICABLE.
      DO 100 IC = 1, NC
        IF (IDAV(IC).EQ.0)  GOTO 100
        IF (ICDEP(IC).EQ.0)  GOTO 100
        ICDPTR = ICDEP(IC)
        CALL FINDST (IDAV, IC, LIDAT, ITYPC, NSTAT, NC,
     *    ISTAT, MS, ITSF)
        NS = NSTAT(IC)
C       CONTROLLING CHARACTER VARIABLE OR INAPPLICABLE -
C        SET ALL POSSIBLE DEPENDENCIES.
        IF (NONZER(ISTAT,NS).EQ.0.AND.(ITSF(1).NE.0.OR.ITSF(3).NE.0))
     *   CALL SETIA (ISTAT, NS, 1)
        CALL COPIA (ICDEP(ICDPTR), ICSTAT, NS)
 
        DO 50 IS = 1, NS
          IF (ICSTAT(IS).EQ.0)  GOTO 50
          IF (ISTAT(IS).EQ.0)  GOTO 50
          ICNTRL = ICSTAT(IS)
          NR = ICDEP(ICNTRL)

C         CONTROLLING STATE PRESENT
          DO 25 IR = 1, NR
            IB = ICDEP(ICNTRL+2*IR-1)
            IE = ICDEP(ICNTRL+2*IR)
            DO KC = IB, IE
              IEMPC(KC) = 0
            ENDDO
   25     CONTINUE
   50   CONTINUE
  100 CONTINUE

          
C     CURRENT LENGTH OF VARIANT ITEM
      JIDAT = NC + IDAV(NC+1)
 
      DO 500 IC = 1, NC
        IF (IEMPC(IC).EQ.0)  GOTO 500
        IF (IDAV(IC).NE.0)  GOTO 500
        IF (IDAM(IC).EQ.0)  GOTO 500
 
C       ADD THE CHARACTER TO THE VARIANT ITEM.
        JG = IDAM(IC)
        L = IDAM(JG)
        IF (JIDAT+L.GT.LIDAT)  GOTO 1000
        JGI = JIDAT + 1
        CALL COPIA (IDAM(JG), IDAV(JGI), L)
        IDAV(IC) = JGI
        JIDAT = JIDAT + L
 
  500 CONTINUE
      IDAV(NC+1) = JIDAT - NC
      RETURN
 
 1000 CALL MESSB (35, LIDAT, 1, -1, 0)
      END
      SUBROUTINE ADDILNK (ICTIMGE, NC, ITEM, ITYPMK, MIDAT,                 ITEM
     * IDAT1, IDAT2, LIDAT, IREC, INSIMGFN, IRTF, IHTML)
 
C  REVISED 27-APR-00.
C  ADDS HTML IMAGE LINKS TO AN ITEM FOR HTML OUTPUT.
C  THIS CODE EMBEDS THE LINK INFORMATION IN THE CHARACTER SPECIFIED BY THE
C  `CHARACTER FOR TAXON IMAGES' DIRECTIVE.
 
C  ICTIMGE RECEIVES THE NUMBER OF THE "CHARACTER FOR TAXON IMAGES".
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  ITEM RECEIVES THE ITEM.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  MIDAT RECEIVES THE LENGTH OF ITEM AND ITYPMK.
C  IDAT1 RECEIVES WORKING SPACE.
C  IDAT2 RECEIVES WORKING SPACE.
C  LIDAT RECEIVES THE LENGTH OF IDAT1 AND IDAT2.
C  IREC RECEIVES THE RECORD NUMBER ON SCRATCH6 WHERE THE TAXON IMAGES
C  INFORMATION BEGINS.
 
      DIMENSION IDAT1(LIDAT),IDAT2(LIDAT),ITEM(MIDAT),ITYPMK(MIDAT)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /ALPXXX/ KA,KB,KC,KD,KE,KF,KG,KH,KI,KJ,KK,KL,KM,
     *                KN,KO,KP,KQ,KR,KS,KT,KU,KV,KW,KX,KY,KZ
      COMMON /ALPLCX/ KLA,KLB,KLC,KLD,KLE,KLF,KLG,KLH,KLI,KLJ,KLK,KLL,
     *                KLM,KLN,KLO,KLP,KLQ,KLR,KLS,KLT,KLU,KLV,KLW,KLX,
     *                KLY,KLZ
      COMMON /CAPXXX/ KCAPMK,IOMCAP
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /DIRYXX/ OUTDIR,LOUTDIR,IMGDIR,LIMGDIR
        CHARACTER*80 OUTDIR,IMGDIR
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /SCR6XX/ LRECS6,IRECS6
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
      COMMON /VLWXXX/ NVWD,MAXVWD,LVWD(18),IBPUNC,IEPUNC,
     * KVSTOP,KVCOM1,KVCOM2,KVSEMI,KVDEC
 
      CHARACTER ENDASH*11,ENDASHH*8,ENDASHR*11
      DATA ENDASHH /' &#150; '/
      DATA ENDASHR /' \endash{} '/
      DATA LDASHH /8/
      DATA LDASHR /11/
 
C     Read the TAXON IMAGES text.
      IREC6 = IREC
      CALL RDDAI (L, 1, LUNS6, LRECS6, IREC6)
      IF (L.LE.LIDAT)  THEN
        IREC6 = IREC6 + 1
        CALL RDDAI (IDAT1, L, LUNS6, LRECS6, IREC6)
      ENDIF

      JIDAT = 1
      ICADDED = 0
C     Look for image name and 'subject' in TAXON IMAGES text.
      IB = 4
   10 IF (IB.GT.L)  GOTO 200
C     Find next image name.
      CALL NEXWRD (IDAT1, L, IB, IE)
      IBNAM = IB
      LNAM = IE - IB
C     Decide wrether to include images directory with image file name.
C     If there already appears to be path information in the image file name,
C     omit the image directory.
      IUSEDIR = 1
      DO I = IB, IE
        IF (IDAT1(I).EQ.KDSOL.OR.IDAT1(I).EQ.KDBSLSH.OR.
     *      IDAT1(I).EQ.KDCOLN)  THEN
          IUSEDIR = 0
          GOTO 12
        ENDIF
      ENDDO
   12 IEND = IE
      IB = IE
C     Looking for @subject and @text in comments associated with image file name.
      ISUBFND = 0
      ISUBCPY = 0
   15 ITXTFND = 0
      LTXT = 0
C     Comment must follow image name.
   20 IF (IB.GT.L)  GOTO 25
      CALL GETCMT (IDAT1, L, IB, IE)
C     No more comments?
      IF (IB.LE.IE)  GOTO 30
C     Should only get here if no subject or no text found.
   25 IF (ISUBFND.EQ.0)  THEN
C       Use image file name if no subject found.
        IBSUB = IBNAM
        LSUB = LNAM
      ENDIF
      GOTO 80
   30 IEND = IE
      IE = MIN0(IE, L)
C     Step over '<'
      IB = IB + 1
      DO WHILE (IDAT1(IB).EQ.KBLANK)
        IB = IB + 1
      ENDDO
      IF (IDAT1(IB).EQ.KAT .AND.
     *  ((IDAT1(IB+1).EQ.KS.OR.IDAT1(IB+1).EQ.KLS) .AND.
     *   (IDAT1(IB+2).EQ.KU.OR.IDAT1(IB+2).EQ.KLU) .AND.
     *   (IDAT1(IB+3).EQ.KB.OR.IDAT1(IB+3).EQ.KLB) .AND.
     *   (IDAT1(IB+4).EQ.KJ.OR.IDAT1(IB+4).EQ.KLJ) .AND.
     *   (IDAT1(IB+5).EQ.KE.OR.IDAT1(IB+5).EQ.KLE) .AND.
     *   (IDAT1(IB+6).EQ.KC.OR.IDAT1(IB+6).EQ.KLC) .AND.
     *   (IDAT1(IB+7).EQ.KT.OR.IDAT1(IB+7).EQ.KLT))  .OR.
     *  ((IDAT1(IB+1).EQ.KT.OR.IDAT1(IB+1).EQ.KLT) .AND.
     *   (IDAT1(IB+2).EQ.KE.OR.IDAT1(IB+2).EQ.KLE) .AND.
     *   (IDAT1(IB+3).EQ.KX.OR.IDAT1(IB+3).EQ.KLX) .AND.
     *   (IDAT1(IB+4).EQ.KT.OR.IDAT1(IB+4).EQ.KLT)))  THEN
C       '@subject or @text' found. Look for '='
        IF (IDAT1(IB+1).EQ.KS.OR.IDAT1(IB+1).EQ.KLS)  THEN
C         @subject
          ISUBFND = 1
          I = IB + 8
          GOTO 60
        ELSE
C         @text
          ITXTFND = 1
          I = IB + 5
C         Look for `t='
   50     IF ((IDAT1(I).EQ.KT.OR.IDAT1(I).EQ.KLT).AND.
     *      IDAT1(I+1).EQ.KEQUAL)  THEN
              I = I + 2
              GOTO 60
          ELSE
            I = I + 1
            IF (I.GT.L)  GOTO 100
            GOTO 50
          ENDIF
        ENDIF
   60   IF (IDAT1(I).NE.KBLANK)  GOTO 70
          I = I + 1
          IF (I.GT.L)  GOTO 100
          GOTO 60
   70   IBX = I 
        DO WHILE (IDAT1(IE).NE.KDRBRA)
          IE = IE - 1
        ENDDO
        IE = IE - 1
        DO WHILE (IDAT1(IE).EQ.KBLANK)
          IE = IE - 1
        ENDDO
        LX = IE - IBX + 1
        IF (IDAT1(IB+1).EQ.KS.OR.IDAT1(IB+1).EQ.KLS)  THEN
          IBSUB = IBX
          LSUB = LX
        ELSE
          IBTXT = IBX
          LTXT = LX
        ENDIF
        IF (ISUBFND.NE.0.AND.ITXTFND.NE.0)  GOTO 80
      ENDIF 
      IB = IEND
      GOTO 20
 
C     Copy subject and image name to IDAT2.
   80 IF (ISUBCPY.NE.0)  GOTO 90
      IF (JIDAT.GT.1)  THEN
C       Separate images with a fullstop+blank.
        IF (CMPVCB(IDAT2, JIDAT-1, KVSTOP).NE.0) THEN
          IF (WD2BUF(KVSTOP, IDAT2, LIDAT, JIDAT).EQ.0) GOTO 500
        ENDIF
        IF (JIDAT+1.GT.LIDAT)  GOTO 500
        IDAT2(JIDAT) = KBLANK
        JIDAT = JIDAT + 1
      ENDIF
      IF (JIDAT+1.GT.LIDAT)  GOTO 500
C     Prevent capitalization for first letter.
      IDAT2(JIDAT) = KCAPMK
      JIDAT = JIDAT + 1
      IF (ITPSET.GT.0) THEN
        CALL TYP2BUF (IDAT2(JIDAT), LIDAT-JIDAT+1, 37, ITYPMK, LIDAT,
     *    NTYPMK, NCPY)
        JIDAT = JIDAT + NCPY
      ENDIF
C     Copy image directory.
      IF (IUSEDIR.GT.0)  THEN
        IF (JIDAT+LIMGDIR.GT.LIDAT)  GOTO 500
        IF (LIMGDIR.GT.0) THEN
          CALL COPSIA (IMGDIR, IDAT2(JIDAT), LIMGDIR)
          JIDAT = JIDAT + LIMGDIR
        ENDIF
      ENDIF
C     Copy image file name.
      IF (JIDAT+LNAM.GT.LIDAT)  GOTO 500
      CALL COPIA (IDAT1(IBNAM), IDAT2(JIDAT), LNAM)
      JIDAT = JIDAT + LNAM
      IF (ITPSET.GT.0) THEN
        CALL TYP2BUF (IDAT2(JIDAT), LIDAT-JIDAT+1, 38, ITYPMK, LIDAT,
     *    NTYPMK, NCPY)
        JIDAT = JIDAT + NCPY
      ENDIF
C     Copy subject and file name if requested..
      IF (INSIMGFN.NE.0.AND.ISUBFND.NE.0)  THEN
C       File name first (only if there is a separate subject name).
        CALL COPIA (IDAT1(IBNAM), IDAT2(JIDAT), LNAM)
        JIDAT = JIDAT + LNAM
C       Separate file name and subject with a dash.
        IF (IRTF.NE.0) THEN
          ENDASH = ENDASHR
          LDASH = LDASHR
        ELSE IF (IHTML.NE.0) THEN
          ENDASH = ENDASHH
          LDASH = LDASHH
        ENDIF
        CALL COPSIA (ENDASH, IDAT2(JIDAT), LDASH)
        JIDAT = JIDAT + LDASH
      ENDIF
C     Then copy subject.
      IF (IHTML.NE.0) THEN
        CALL COPHTML (IDAT1, IBSUB, LSUB, IDAT2, JIDAT, LIDAT)
      ELSEIF (IRTF.NE.0) THEN
        IF (JIDAT+LSUB.GT.LIDAT) GOTO 500
        CALL COPIA (IDAT1(IBSUB), IDAT2(JIDAT), LSUB)
        JIDAT = JIDAT + LSUB
      ENDIF
      ISUBCPY = 1
 
      IF (ITPSET.GT.0) THEN
        CALL TYP2BUF (IDAT2(JIDAT), LIDAT-JIDAT+1, 39, ITYPMK, LIDAT,
     *    NTYPMK, NCPY)
        JIDAT = JIDAT + NCPY
      ENDIF
 
C     Copy text associated with image.
   90 IF (LTXT.GT.0) THEN
C       Separate image components with fullstop+blank.
        IF (CMPVCB(IDAT2, JIDAT-1, KVSTOP).NE.0) THEN
          IF (WD2BUF(KVSTOP, IDAT2, LIDAT, JIDAT).EQ.0) GOTO 500
        ENDIF
        IF (JIDAT+1.GT.LIDAT)  GOTO 500
        IDAT2(JIDAT) = KBLANK
        JIDAT = JIDAT + 1
        IF (IHTML.NE.0) THEN
          CALL COPHTML (IDAT1, IBTXT, LTXT, IDAT2, JIDAT, LIDAT)
        ELSEIF (IRTF.NE.0) THEN
          IF (JIDAT+LTXT.GT.LIDAT) GOTO 500
          CALL COPIA (IDAT1(IBTXT), IDAT2(JIDAT), LTXT)
          JIDAT = JIDAT + LTXT
        ENDIF
      ENDIF
      ICADDED = 1

  100 IB = IEND
C     Look for more @text entries for this subject.
      IF (LTXT.GT.0)  GOTO 15
      GOTO 10
 
  200 IF (ICADDED.NE.0)  THEN
       JIDAT = JIDAT - 1
       LITEM = NC + ITEM(NC+1)
       IF (LITEM+JIDAT+5.GT.MIDAT)  GOTO 500
       JITM = LITEM + 1
       ITEM(ICTIMGE) = JITM
       L = JIDAT + 5
       ITEM(JITM) = L
       ITEM(JITM+1) = L - 1
       ITEM(JITM+2) = 0
       ITEM(JITM+3) = KDLBRA
       CALL COPIA (IDAT2, ITEM(JITM+4), JIDAT)
       ITEM(JITM+4+JIDAT) = KDRBRA
       ITEM(NC+1) = ITEM(NC+1) + L
      ENDIF
      GOTO 1000
 
C     NOTE: The arrays IDAT1 and IDAT2 are MIDAT/2 in length.
C     The array IDAV was split into two to create working space
C     for this subroutine.
  500 CALL MESSB (35, MIDAT, 1, -1, 0)

 1000 RETURN
      END
      SUBROUTINE CHKDEP (JITEM, ICDEP, NSTAT, ITYPC, ITMADD, LSTDEP,        ITEM
     * ICHDEP, IWRKC, NC, ICSTAT, ISTAT, MS, IDAT, LIDAT)
 
C  REVISED 24-JUN-99.
C  CHECKS ITEM DESCRIPTIONS AGAINST CHARACTER DEPENDENCY DECLARATIONS.
 
C  17/8/87. (1)ENFORCE CODING OF CONTROLLING CHARACTERS IF DEPENDENT
C   CHARACTERS ARE CODED. (2) IF CONTROLLING CHARACTER IS INAPPLICABLE,
C    ALL CHARACTERS DEPENDENT ON ANY STATE ARE ALSO INAPPLICABLE.
C  20/11/86. ROUTINE COMPLETELY REWRITTEN.
 
C  JITEM RECEIVES THE ITEM NUMBER.
C  ICDEP RECEIVES CHARACTER DEPENDENCY INFORMATION.
C  NSTAT RECEIVES THE NUMBER OF STATES.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  ITMADD RECEIVES WHERE DATA HAS BEEN ADDED THE ORIGINAL ITEM.
C  LSTDEP RETURNS A LIST OF CHARACTERS WHICH ARE IMPLICITLY N/A.
C  ICHDEP RECEIVES WORKING SPACE OF LENGTH NC.
C  IWRKC RECEIVES WORKING SPACE OF LENGTH NC.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  ICSTAT RECEIVES WORKING SPACE OF LENGTH MS.
C  ISTAT RECEIVES WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C  IDAT RECEIVES THE ITEM DESCRIPTION.
C  LIDAT RECEIVES THE LENGTH OF IDAT.
C
C  CHARACTER DEPENDENCY INFORMATION IS STORED IN THE ARRAY ICDEP.
C  THE FIRST NC LOCATIONS IN ICDEP ARE POINTERS TO DEPENDENCY DATA
C  ASSOCIATED WITH EACH CHARACTER. IF THE POINTER VALUE IS ZERO, NO
C  OTHER CHARACTERS ARE CONTROLLED BY THAT CHARACTER. OTHERWISE, THE
C  POINTER INDICATES THE STARTING LOCATION OF THE ENTRY FOR THE
C  CONTROLLING STATES OF THAT CHARACTER. THERE ARE NSTAT(IC) POINTERS.
C  IF A STATE POINTER VALUE IS ZERO, NO CHARACTERS ARE CONTROLLED BY
C  THAT STATE. OTHERWISE, THE POINTER IS THE LOCATION IN ICDEP
C  CONTAINING THE NUMBER OF RANGES OF DEPENDENT CHARACTERS, WHICH IS
C  FOLLOWED BY THE PAIRS OF VALUES DELIMITING EACH RANGE.
C
      DIMENSION ICDEP(LIDAT),NSTAT(NC),ITYPC(NC),IDAT(LIDAT),
     * ICSTAT(MS),ISTAT(MS),ITMADD(NC),ICHDEP(NC),LSTDEP(NC),IWRKC(NC),
     * IVAL(3)
 
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /TNAMEX/ TNAME,LTNAME
        CHARACTER*256 TNAME
 
      COMMON /ITSXXX/ ITSS
 
C      INTEGER*2 IHR,IMIN,ISEC,I100TH

C      CALL GETTIM(IHR,IMIN,ISEC,I100TH)
C      WRITE(LUNL,1) IHR,IMIN,ISEC,I100TH
C 1    FORMAT('BEGIN CHKDEP ', 4I3)
 
C     GET LIST OF CHARACTERS WHICH ARE IMPLICITLY N/A.
      CALL SETDEP (IDAT, LIDAT, ICDEP, NSTAT, ITYPC, LSTDEP, ICHDEP,
     * IWRKC, NC, ICSTAT, ISTAT, MS, 0)
 
C     CURRENT LENGTH OF ITEM.
      JITM = NC + IDAT(NC+1)
 
C---  FOR EACH CHARACTER.
      DO 500 IC = 1, NC
        ICDPTR = ICDEP(IC)
 
C-      CHECK IF THIS IS A CONTROLLING CHARACTER.
        IF (ICDPTR.EQ.0)  GO TO 500
 
C-      IS CHARACTER CODED?
        ICODED = 0
        ICODEDU = 0
        NS = NSTAT(IC)
        CALL COPIA (ICDEP(ICDPTR), ICSTAT, NS)
 
C       TREAT UNCODED CONTROLLING CHARACTER AS IF EXPLICITLY CODED AS `U'.
        IF (IDAT(IC).LE.0)  THEN
C         IS INAPPLICABLE BY VIRTUE OF OTHER DEPENDENCIES ?
          IF (LSTDEP(IC).NE.0)  GOTO 80
        GOTO 100
C 30-APR-96.    GO TO 15
        ENDIF
 
        JG = IDAT(IC)
        JSG = JG + 1
        JGN = JG + IDAT(JG)
        JTYPC = IABS(ITYPC(IC))
 
   10   IF (JSG.GE.JGN)  GOTO  100
          ITS = IDAT(JSG+1)
          IF (ITS.LE.0)  GOTO 90
          IF (ITS.LE.ITSS)  GOTO 30
C         CODED AS UNKNOWN - ADDED 30-apr-96.
          IF (ITS-ITSS.EQ.2)  THEN
            ICODEDU = 1
            GOTO 100
          ENDIF
C         CODED AS INAPPLICABLE
          IF (ITS-ITSS.EQ.3)  GOTO 80
C         CODED AS VARIABLE
C         ARE ALL STATES CONTROLLING STATES?
   15     DO 20 IS = 1, NS
            IF (ICSTAT(IS).EQ.0)  GOTO 500
   20       CONTINUE
          ICODED = 2
          GOTO 100
 
C         SCAN SUB-GROUPS. IF AT LEAST ONE SUB-GROUP IS NON-CONTROLLING,
C         DEPENDENCIES DO NOT HOLD.
 
   30     ICODED = 2
          JB = JSG + 2
          JE = JSG + IDAT(JSG) - 1
 
          IF (JTYPC.EQ.2.AND.ITS.EQ.1)  THEN
 
C           ORDERED MULTISTATE WITH "TO".
            IB = IDAT(JB)
            IE = IDAT(JE)
            DO 40 IS = IB, IE
              IF (ICSTAT(IS).EQ.0)  GOTO 500
   40         CONTINUE
            GOTO 90
 
          ELSE
 
C           UNORDERED MULTISTATE OR ORDERED MULTISTATE WITH "AND".
            DO 50 J = JB, JE
              IS = IDAT(J)
              IF (ICSTAT(IS).EQ.0)  GOTO 500
   50         CONTINUE
            GOTO 90
 
          ENDIF
 
C         NOT APPLICABLE.
   80     IF (ICODED.LE.0)  ICODED = 1
C         UNCODED ?
          IF (IDAT(IC).LE.0)  GOTO 100
 
   90     JSG = JSG + IDAT(JSG)
          GOTO 10
 
 
C       ALL SUB-GROUPS ARE CONTROLLING SUB-GROUPS.
C       DETERMINE THE SET OF CHARACTERS CONTROLLED.
  100   DO 105 J =1, NC
          ICHDEP(J) = 0
  105   CONTINUE
        KNT = 0
 
        IF (ICODED.GT.1)  GOTO 109
 
C       IF CONTROLLING CHARACTER IS TRULY NOT CODED AT ALL,
C       THEN IF CAN BE INAPPLICABLE BY VIRTUE OF ITS CONTROLLING CHARACTER
        IF (ICODED.EQ.0.AND.ICODEDU.EQ.0.AND.LSTDEP(IC).NE.0)
     *    ICODED = 1
 
C       CONTROLLING CHARACTER NOT CODED OR CODED AS INAPPLICABLE -
C        GET UNION OF SETS OF INAPPLICABLE CHARACTERS.
        DO 108 IS = 1, NS
          CALL GETDPU (ICDEP, LIDAT, IC, IS, ICHDEP, NC)
  108     CONTINUE
        GOTO 200
 
  109   JSG = JG + 1
        IFIRST = 1
C** THIS CODE SHOULD NEVER BE PROCESSED 30-apr-96.
C       UNCODED CONTROLLING CHARACTER TREATED AS UNKNOWN.
        IF (IDAT(IC).LE.0)  THEN
          GOTO 115
        ENDIF
 
C       CHARACTER IS CODED.
  110   IF (JSG.GE.JGN)  GOTO  200
          ITS = IDAT(JSG+1)
          IF (ITS.LE.0)  GOTO 195
          IF (ITS.LE.ITSS)  GOTO 130
 
C         CODED/INAPPLICABLE?
C         NO NEED TO DO MORE. JUST USE SET OF DEPENDENT CHARACTERS DERIVED FROM
C         CODED STATES.
          IF (ITS-ITSS.EQ.3) GOTO 195
 
C         CONTROLLING CHARACTER CODED AS VARIABLE (OR UNKNOWN: removed 30-apr-96) -
C          GET INTERSECTION OF SETS OF INAPPLICABLE CHARACTERS.
  115     DO 120 IS = 1, NS
            KNT = KNT + 1
            CALL GETDEP (ICDEP, LIDAT, IC, IS, ICHDEP, NC, KNT)
  120       CONTINUE
          NONZ = 0
          DO  KC = 1, NC
            IF (ICHDEP(KC).NE.KNT)  THEN
              ICHDEP(KC) = 0
            ELSE
              NONZ = 1
            ENDIF
          ENDDO
          IF (NONZ.EQ.1)  GOTO 200
          GOTO 500
 
C         PROCESS SUB-GROUPS TO DERIVE SET OF DEPENDENT CHARACTERS.
 
  130     JB = JSG + 2
          JE = JSG + IDAT(JSG) - 1
 
          IF (JTYPC.EQ.2.AND.ITS.EQ.1)  THEN
 
C           ORDERED MULTISTATE WITH "TO".
            IB = IDAT(JB)
            IE = IDAT(JE)
            DO 140 IS = IB, IE
              KNT = KNT + 1
              CALL GETDEP (ICDEP, LIDAT, IC, IS, ICHDEP, NC, KNT)
  140         CONTINUE
          NONZ = 0
          DO  KC = 1, NC
            IF (ICHDEP(KC).NE.KNT)  THEN
              ICHDEP(KC) = 0
            ELSE
              NONZ = 1
            ENDIF
          ENDDO
          IF (NONZ.EQ.0)  GOTO 500
 
          ELSE
 
C           UNORDERED MULTISTATE OR ORDERED MULTISTATE WITH "AND".
            DO 150 J = JB, JE
              IS = IDAT(J)
              KNT = KNT + 1
              CALL GETDEP (ICDEP, LIDAT, IC, IS, ICHDEP, NC, KNT)
  150         CONTINUE
          NONZ = 0
          DO  KC = 1, NC
            IF (ICHDEP(KC).NE.KNT)  THEN
              ICHDEP(KC) = 0
            ELSE
              NONZ = 1
            ENDIF
          ENDDO
          IF (NONZ.EQ.0)  GOTO 500
 
          ENDIF
 
  195     JSG = JSG + IDAT(JSG)
          GOTO 110
 
C       CHECK CODING OF DEPENDENT CHARACTERS IN DERIVED LIST.
  200   DO 250 KC = 1, NC
          IF (ICHDEP(KC).EQ.0)  GOTO 250
          IF (IDAT(KC).EQ.0)  GOTO 250
          JG = IDAT(KC)
          JGN = JG + IDAT(JG)
          LEN = 1
          JSG = JG + 1
  210     IF (JSG.GE.JGN)  GOTO 250
C           COMMENT OR INAPPLICABLE
            IF (IDAT(JSG+1).EQ.0.OR.IDAT(JSG+1).EQ.ITSS+3)  GOTO 240
C           CONTROLLING CHARACTER UNCODED OR U AND DEPENDENT CHARACTER UNKNOWN
            IF (ICODED.EQ.0.AND.IDAT(JSG+1).EQ.ITSS+2)  GOTO 240
C           REMOVE ADDED VALUE CAUSING DEPENDENCY ERROR.
            IF (ITMADD(KC).EQ.1)  THEN
C             TYPE-1 IMPLICIT VALUE.
              IDAT(KC) = 0
              ITMADD(KC) = 0
            ELSE IF (ITMADD(KC).EQ.2)  THEN
C             TYPE-2 IMPLICIT VALUE.
              JGI = JITM + 1
              IF (JITM+LEN.GT.LIDAT)  GOTO 600
              IDAT(KC) = JGI
              CALL COPIA (IDAT(JG), IDAT(JGI), LEN)
              JITM = JITM + LEN
              ITMADD(KC) = 0
            ELSE
c              IVAL(1) = JITEM
              IVAL(1) = IC
              IVAL(2) = KC
              IF (ICODED.EQ.2)  THEN
                CALL MESSC (92, IVAL, 2, 3, JBUF-1, TNAME, LTNAME, 1)
C             CONTROLLING CHARACTER IS EXPLICITLY INAPPLICABLE
              ELSE IF (ICODED.EQ.1.AND.IDAT(IC).GT.0)  THEN
                CALL MESSC (93, IVAL, 2, 3, JBUF-1, TNAME, LTNAME, 1)
C             CONTROLLING CHARACTER IS UNCODED, THOUGH MAY BE IMPLICITLY INAPPLICABLE
              ELSE IF (ICODED.EQ.0.OR.(ICODED.EQ.1.AND.IDAT(IC).LE.0))
     *         THEN
                CALL MESSC (94, IVAL, 2, 3, JBUF-1, TNAME, LTNAME, 1)
              ENDIF
            ENDIF
            GOTO 250
  240       LEN = LEN + IDAT(JSG)
            JSG = JSG + IDAT(JSG)
            GOTO 210
  250     CONTINUE
 
 
  500   CONTINUE
 
C      CALL GETTIM(IHR,IMIN,ISEC,I100TH)
C      WRITE(LUNL,501) IHR,IMIN,ISEC,I100TH
C  501 FORMAT('END CHKDEP ', 4I3)
 
      IDAT(NC+1) = JITM - NC
      RETURN
 
  600 CALL MESSB (35, LIDAT, 1, -1, 0)
      END
      SUBROUTINE CHKMAN (JITEM, MANDC, NSTAT, ITYPC, NC, IDAT, LIDAT,       ITEM
     * IDEPC, ICDEP, ISTAT, MS)
 
C  REVISED 9-JUL-96.
C  CHECKS CODING OF MANDATORY CHARACTERS.
 
C  JITEM RECEIVES THE ITEM NUMBER.
C  MANDC RECEIVES WHETHER CODING OF CHARACTERS IS MANDATORY.
C  NSTAT RECEIVES NUMBERS OF CHARACTER STATES.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  IDAT RECEIVES THE ITEM.
C  LIDAT RECEIVES THE LENGTH OF IDAT.
C  IDEPC RECEIVES WHETHER THERE ARE DEPENDENT CHARACTERS.
C  ICDEP RECEIVES THE DEPENDENCIES.
C  ISTAT RECEIVES WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
 
C  NOTES:
C  CHECKING STRATEGY.
C  FOR EACH CHARACTER, CHECK IF ALL STATES PRESENT ARE CONTROLLING STATES.
C  IF NOT, ANY CODING IS PERMISSIBLE IN DEPENDENT CHARACTERS. OTHERWISE,
C  DERIVE SET OF CHARACTERS WHICH MUST BE INAPPLICABLE AND COMPARE WITH CODED
C  ITEM.  IF MORE MEMORY WERE AVAILABLE, IT WOULD BE POSSIBLE TO COMPILE A
C  COMPLETE LIST (I.E. FOR ALL CHARACTERS) OF INAPPLICABLE CHARACTERS AND
C  PERFORM COMPARISON OPERATION ONCE ONLY. THIS REQUIRES ANOTHER WORKING ARRAY
C  OF LENGTH NC.
 
      DIMENSION MANDC(NC),NSTAT(NC),ITYPC(NC),IDAT(LIDAT),
     * ICDEP(LIDAT),ISTAT(MS),IVAL(2)
 
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /ITSXXX/ ITSS
      COMMON /TNAMEX/ TNAME,LTNAME
        CHARACTER*256 TNAME
 
      DO 100 IC = 1, NC
        IF (MANDC(IC).EQ.0)  GOTO 100
        ICODED = 0
        IF (IDAT(IC).EQ.0)  GO TO 70
        JG = IDAT(IC)
        JSG = JG + 1
        L = IDAT(JG)
        IF (L.LE.1)  GO TO 70
   10   IF (JSG.GE.JG+IDAT(JG))  GO TO 70
          ITS = IDAT(JSG+1)
          IF (ITS.GE.0)  THEN
            IF (ITYPC(IC).EQ.5)  THEN
              IF (ITS.EQ.0.OR.ITS.EQ.8)  GO TO 20
            ELSE
              IF (ITS.GT.0.AND.ITS-ITSS.NE.2)  GO TO 20
            ENDIF
          ENDIF
          JSG = JSG + IDAT(JSG)
          GO TO 10
 
   20   ICODED = 1
        GO TO 90
 
   70   IF (ICODED.EQ.0.AND.IDEPC.NE.0)  CALL IFDEP (IC, NSTAT, ITYPC,
     *   NC, IDAT, ICDEP, LIDAT, ISTAT, MS, ICODED)
   90   IF (ICODED.EQ.0)  THEN
          IVAL(1) = IC
          IVAL(2) = JITEM
          CALL MESSC (95, IVAL, 1, 4, JBUF-1, TNAME, LTNAME, 1)
        ENDIF
  100   CONTINUE
 
      RETURN
      END
      SUBROUTINE CMPNAM(INAM, LNAM, JI, ITXNAM, NUMNAM, ITXREC, MI,
     * ICHARS, JCHARS, NC, IDAT, LIDAT, LUNS, LRECS, LUNSD, LRECSD,
     * IDUP, IERRNO, ITINDX)
 
C  REVISED 09-FEB-99.
C  COMPARES THE NAME IN INAM WITH THOSE IN THE LIST SPECIFIED IN THE
C  `TAXON IMAGES' DIRECTIVE.
 
C  INAM RECEIVES THE FULL TAXON NAME FROM THE ITEMS FILE.
C  LNAM RECEIVES THE LENGTH OF INAM.
C  JI RECEIVES THE ITEM NUMBER.
C  ITXNAM RECEIVES RECORD POINTERS TO TAXON NAMES ON LUNS.
C  ITXREC RETURNS TAXON IMAGE DATA RECORD POINTERS FOR SUCCESSFULLY MATCHED NAMES.
C  NUMNAM RECEIVES THE NUMBER OF TAXON NAME RECORDS.
C  MI RECEIVES THE MAXIMUM NUMBER OF ITEMS.
C  ICHARS RECEIVES WORKING SPACE OF LENGTH NC.
C  JCHARS RECEIVES WORKING SPACE OF LENGTH NC.
C  IDAT RECEIVES WORKING SPACE.
C  LIDAT RECEIVES THE LENGTH OF IDAT.
C  LUNS RECEIVES THE UNIT NUMBER CONTAINING THE NAMES.
C  LRECS RECEIVES THE RECORD LENGTH FOR LUNS.
C  LUNSD RECEIVES THE UNIT NUMBER CONTAINING THE ASSOCIATED DATA.
C  LRECSD RECEIVES THE RECORD LENGTH FOR LUNSD.
C  IDUP RECEIVES WHETHER A NAME CAN APPEAR MORE THAN ONCE IN THE LIST
C  IERRNO RECEIVES AN ERROR NUMBER IF DUPLICATES ARE NOT ALLOWED
C  ITXINDX RECEIVES THE AND RETURNS THE INDEX OF THE LAST NAME IN THE LIST
C   THAT WAS MATCHED.
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
 
      DIMENSION INAM(LNAM),ITXNAM(NUMNAM),ITXREC(MI),IDAT(LIDAT),
     * ICHARS(NC),JCHARS(NC)

C     The last index value is saved between calls, so that next search will
C     begin after the current match.
C     If names in the directive are in the same order as in the
C     items file, the search will be more efficient.
 
C     This code assumes the names being compared contain no typesetting marks.
C     This is done by S/R REMTPS. Thus, a simple comparison
C     of lengths provides a first test of equality.
 
      LLNAM = INAM(1)
 
      IFIRST = 1
      DO 500 JJJ = 1, NUMNAM
  
      ITINDX = ITINDX +1
      IF (ITINDX.GT.NUMNAM) ITINDX = 1
 
      KREC = IABS(ITXNAM(ITINDX))
 
C     READ NAME.
      CALL RDDAI (LEN, 1, LUNS, LRECS, KREC)
C     Compare lengths.
      IF (LEN.NE.LLNAM)  GOTO 500
      KREC1 = KREC + 1
      CALL RDDAI (IDAT, LEN, LUNS, LRECS, KREC1)
      KREC1 = KREC1 + (LRECS + LEN - 1)/LRECS
 
C     COMPARE NAMES, INCLUDING COMMENTS - A COMPLETE MATCH IS REQUIRED.
      IG = 1
      ISG = IG + 1
      IGN = IG + INAM(IG)
      JG = 1
      JSG = JG + 1
      JGN = JG + IDAT(JG)
      MISMATCH = 0
   20 IF (MISMATCH.NE.0.OR.ISG.GE.IGN.OR.JSG.GE.JGN)  GOTO 100
C       CHECK FOR COMMENTS IN BOTH NAMES.
        IF (INAM(ISG+1).NE.IDAT(JSG+1))  THEN
          MISMATCH = 1
          GOTO 20
        ELSE
          IF (INAM(ISG+1).EQ.0)  THEN
            INCMT = 1
          ELSE
            INCMT = 0
          ENDIF
          IB = ISG + 2
          IE = ISG + INAM(ISG) - 1
          JB = JSG + 2
          JE = JSG + IDAT(JSG) - 1
        ENDIF
CC       FIRST REMOVE ANY TYPESETTING MARKS FROM THE NAME IN IDAT WHICH
CC       WAS READ FROM THE SCRATCH FILE.
CC       CAN'T REMOVE TYPESETTING MARKS FROM INAM BY THIS METHOD, BECAUSE THIS
CC       IS PART OF THE CODED ITEM (NOT A COPY). WE WILL IGNORE TYPESETTING
CC       MARKS AS WE PROCESS INAM.
C        I1 = JB
C        DO I = JB, JE
C          IF (IGNOR(IDAT(I)).EQ.0)  THEN
C            IDAT(I1) = IDAT(I)
C            I1 = I1+1
C          ENDIF
C        ENDDO
C        JE = I1 - 1
        I = IB
        J = JB
        LASTI = 0
        LASTJ = 0
CC       IGNORE TYPESETTING MARKS AND MULTIPLE BLANKS IN COMMENTS.
C       IGNORE MULTIPLE BLANKS IN COMMENTS.
        DO WHILE (MISMATCH.EQ.0.AND.I.LE.IE.AND.J.LE.JE)
          INCI = 1
          INCJ = 1
          IF (INCMT.GT.0)  THEN
            IF ((INAM(I).EQ.KBLANK.AND.LASTI.EQ.KBLANK) .OR.
     *          (INAM(I).EQ.KBLANK.AND.LASTI.EQ.KDLBRA) .OR.
     *          (INAM(I).EQ.KBLANK.AND.INAM(I+1).EQ.KDRBRA)) THEN
C     *          (INAM(I).EQ.KBLANK.AND.INAM(I+1).EQ.KDRBRA) .OR.
C     *          (IGNOR(INAM(I)).NE.0))  THEN
              INCJ = 0
            ELSE IF ((IDAT(J).EQ.KBLANK.AND.LASTJ.EQ.KBLANK) .OR.
     *          (IDAT(J).EQ.KBLANK.AND.LASTJ.EQ.KDLBRA) .OR.
     *          (IDAT(J).EQ.KBLANK.AND.IDAT(J+1).EQ.KDRBRA)) THEN
              INCI = 0
            ENDIF
          ELSE
CC           NOT IN COMMENT, STILL CHECK FOR TYPSET MARKS.
C            IF (IGNOR(INAM(I)).NE.0)  INCJ = 0
          ENDIF
          IF (INCI+INCJ.EQ.2.AND.INAM(I).NE.IDAT(J))  THEN
            MISMATCH = 1
          ELSE
            LASTI = INAM(I)
            LASTJ = IDAT(J)
            IF (INCI.NE.0)  I = I + 1
            IF (INCJ.NE.0)  J = J + 1
          ENDIF
        END DO
CC       STEP OVER ANY FURTHER TYPESETTING MARKS IN INAM.
C   30   IF (I.LE.IE) THEN
C          IF (IGNOR(INAM(I)).EQ.0) GOTO 40
C          I = I + 1
C          GOTO 30
C        ENDIF
   40   IF (I.GT.IE.AND.J.GT.JE) THEN
          JSG = JSG + IDAT(JSG)
          ISG = ISG + INAM(ISG)
        ELSE
          MISMATCH = 1
        ENDIF
        GOTO 20
 
C     CHECK IF NAMES COMPLETELY MATCHED
  100 IF (MISMATCH.EQ.0)  THEN
        IF (ISG.LT.IGN .OR.JSG.LT.JGN)  MISMATCH = 1
      ENDIF
 
  120 IF (MISMATCH.EQ.0)  THEN
 
        IF (ITXNAM(ITINDX).LT.0)  THEN
C         ITEM NAME PREVIOUSLY MATCHED.
          IF (IFIRST.GT.0)  THEN
            CALL MESSA (143, 1, 0)
            CALL WNAME(INAM, LNAM, IDUM, 1, 1, -1, 1, 0, 1)
            IF (LUNL.NE.LUNE)
     *        CALL WNAME(INAM, LNAM, IDUM, 1, 1, -1, 1, 0, 2)
            IFIRST = 0
          ENDIF
        ELSE
C         STORE POINTER TO TAXON IMAGES DATA.
          CALL RDDAI (KREC2, 1, LUNS, LRECS, KREC1)
          IF (ITXREC(JI).EQ.0)  THEN
            ITXREC(JI) = KREC2
          ELSE IF (IDUP.EQ.0)  THEN
            CALL MESSA2 (IERRNO, 136, 1, 0)
            CALL WNAME(IDAT, LEN, IDUM, 1, 1, -1, 1, 0, 1)
            IF (LUNL.NE.LUNE)
     *        CALL WNAME(IDAT, LEN, IDUM, 1, 1, -1, 1, 0, 2)
          ELSE
C           THER IS SOME INFORMATION ALREADY STORED. ADD TO THIS.
            IREC = ITXREC(JI)
            CALL RDDAI (ICHARS, NC, LUNSD, LRECSD, IREC)
            CALL RDDAI (JCHARS, NC, LUNSD, LRECSD, KREC2)
            DO I = 1, NC
              IF (JCHARS(I).NE.0)  ICHARS(I) = 1
            END DO
            IREC = IREC - 1
            CALL WRDAI (ICHARS, NC, LUNSD, LRECSD, IREC)
          ENDIF
C         MARK AS MATCHED.
          ITXNAM(ITINDX) = -KREC
 
C         EXIT IF WE KNOW THERE CAN BE NO MORE MATCHES
C          IF (IDUP.EQ.0)  GOTO 210
C         05-FEB-99. 'ADD CHARACTERS' AND 'EMPHASIZE CHARACTERS'
C           USED TO ALLOW DUPLICATE NAMES RECORDS ON THE SCRATCH FILE.
C           AS OF THIS DATE, THE RECORDS ARE MERGED WHEN THE DIRECTIVE IS READ,
C           SO IT IS NO LONGER NECESSARY TO CATER FOR THIS.
          GOTO 210
        ENDIF
      ENDIF
 
  500 CONTINUE
 
C  200 DO I = 1, NUMNAM
C        IF (ITXNAM(I).GT.0)  GOTO 210
C      END DO
C      IFINIS = 1
 
  210 RETURN
      END
      SUBROUTINE COPHTML (IDAT1, IB1, LB1, IDAT2, IB2, LB2)
 
C  REVISED 3-AUG-98.
C  TRANSLATES TEXT IN AN INPUT BUFFER FROM RTF TO HTML AND COPIES TO AN
C  OUTPUT BUFFER.
 
      DIMENSION IDAT1(LB1),IDAT2(LB2)
      CHARACTER*256 REPLSTR
 
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
 
      II = IB1
      IE = IB1 + LB1 - 1
      DO WHILE (II.LE.IE)
        IF (IDAT1(II).EQ.KDBSLSH)  THEN
          CALL RTF2HTML (IDAT1, IE, II, REPLSTR, LSTR)
          IF (IB2+LSTR.GT.LB2)  GOTO 100
          DO JJ = 1, LSTR
            IDAT2(IB2) = ICHAR(REPLSTR(JJ:JJ))
            IB2 = IB2 + 1
          ENDDO
        ELSE
          IF (IB2.GT.LB2)  GOTO 100
          IDAT2(IB2) = IDAT1(II)
          IB2 = IB2 + 1
        ENDIF
        II = II + 1
      ENDDO
      GOTO 200

  100 CALL MESSB (35, LB2, 1, -1, 0)
 
  200 RETURN
      END
      SUBROUTINE GETCMT (ITEXT, LTEXT, IB, IE)                              ITEM
 
C  REVISED 19-AUG-98.
C  RETURNS NEXT COMMENT IN THE TEXT.
 
C  TEXT RECEIVES THE TEXT.
C  LTEXT RECEIVES THE LENGTH OF TEXT.
C  IB RECEIVES THE CURRENT POSITION IN TEXT AND RETURNS THE START
C   POSITION OF THE COMMENT. IF THERE IS NO COMMENT, IB IS UNCHANGED.
C  IE RETURNS THE FIRST POSITION AFTER THE COMMENT.
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH

      DIMENSION ITEXT(LTEXT)
 
      IE = IB - 1
      INCMT = 0
 
C     FIND FIRST NON-BLANK.
    5 IF (IB.GT.LTEXT)  GOTO 100
      IF (ITEXT(IB).NE.KBLANK)  THEN
        IF (ITEXT(IB).NE.KDLBRA)  GOTO 100
        GOTO 10
      ELSE
        IB = IB + 1
      ENDIF
      GOTO 5
 

   10 IE = IB + 1
      INCMT = INCMT + 1
 
      DO WHILE (IE.LE.LTEXT)
        IF (INCMT.EQ.0)  GOTO 100
        IF (ITEXT(IE).EQ.KDLBRA)  INCMT = INCMT + 1
        IF (ITEXT(IE).EQ.KDRBRA)  INCMT = INCMT - 1
        IE = IE + 1
      ENDDO

  100 RETURN
      END
      SUBROUTINE GETDEP (ICDEP, LIDAT, IC, IS, KDEP, NC, KNT)               ITEM
 
C  REVISED 19-MAR-92.
C  RETURNS THE SET OF CHARACTERS CONTROLLED BY A GIVEN CHARACTER-STATE
C  COMBINATION.
 
C  ICDEP RECEIVES THE CHARACTER DEPENDENCIES.
C  LIDAT RECEIVES THE LENGTH OF ICDEP.
C  IC RECEIVES THE CONTROLLING CHARACTER NUMBER.
C  IS RECEIVES THE STATE NUMBER.
C  KDEP RETURNS THE SET OF CONTROLLED CHARACTERS.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
 
      DIMENSION ICDEP(LIDAT),KDEP(NC)
 
      IV = KNT - 1
      ICDPTR = ICDEP(IC)
      IF (ICDPTR.EQ.0)  GOTO 100
      ICST = ICDEP(ICDPTR+IS-1)
      IF (ICST.EQ.0)  GOTO 100
      NR = ICDEP(ICST)
      DO 50 IR = 1, NR
        I = ICST+2*IR-1
        IB = ICDEP(I)
        IE = ICDEP(I+1)
        DO 20 KC = IB, IE
          IF (KDEP(KC).EQ.IV)  KDEP(KC) = KNT
   20     CONTINUE
   50   CONTINUE
 
  100 RETURN
      END
      SUBROUTINE GETDPU (ICDEP, LIDAT, IC, IS, KDEP, NC)                    ITEM
 
C  REVISED 20-MAR-92.
C  RETURNS THE SET OF CHARACTERS CONTROLLED BY A GIVEN CHARACTER-STATE
C  COMBINATION.
 
C  ICDEP RECEIVES THE CHARACTER DEPENDENCIES.
C  LIDAT RECEIVES THE LENGTH OF ICDEP.
C  IC RECEIVES THE CONTROLLING CHARACTER NUMBER.
C  IS RECEIVES THE STATE NUMBER.
C  KDEP RETURNS THE SET OF CONTROLLED CHARACTERS.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
 
      DIMENSION ICDEP(LIDAT),KDEP(NC)
 
      ICDPTR = ICDEP(IC)
      IF (ICDPTR.EQ.0)  GOTO 100
      ICST = ICDEP(ICDPTR+IS-1)
      IF (ICST.EQ.0)  GOTO 100
      NR = ICDEP(ICST)
      DO 50 IR = 1, NR
        I = ICST+2*IR-1
        IB = ICDEP(I)
        IE = ICDEP(I+1)
        DO 20 KC = IB, IE
          KDEP(KC) = 1
   20   CONTINUE
   50   CONTINUE
 
  100 RETURN
      END
      SUBROUTINE IFDEP (IC, NSTAT, ITYPC, NC, IDAT, ICDEP, LIDAT,           ITEM
     * ISTAT, MS, ICODED)
 
C  REVISED 20-DEC-98.
C  CALLED BY CHKMAN (CHECK MANDATORY CHARACTERS).
C  DETERMINES WHETHER A GIVEN CHARACTER IS CODED VIA DEPENDENCY.
 
C  IC RECEIVES THE CHARACTER NUMBER.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  IDAT RECEIVES THE ITEM.
C  ICDEP RECEIVES THE CHARACTER DEPENDENCIES.
C  LIDAT RECEIVES THE LENGTH OF IDAT.
C  ISTAT RECEIVES WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C  ICODED RETURNS WHETHER THE CHARACTER IS CODED.
 
      DIMENSION NSTAT(NC),ITYPC(NC),IDAT(LIDAT),ICDEP(LIDAT),ISTAT(MS),
     * ITSF(3)
 
      JAPPST = 0
      DO 100 KC = 1, NC
        IF (ICDEP(KC).EQ.0)  GOTO 100
        IF (IDAT(KC).EQ.0)  GOTO 100
        ISPTR = ICDEP(KC)
        CALL FINDST (IDAT, KC, LIDAT, ITYPC, NSTAT, NC,
     *   ISTAT, MS, ITSF)
        NS = NSTAT(KC)
        IF (ITSF(3).NE.0)  CALL SETIA (ISTAT, NS, 1)
C       If KC is a controlling character
C       IAPPST = whether there is a state of KC which allows IC to be applicable.
        IAPPST = 0
        DO 40 IS = 1, NS
          IF (ISTAT(IS).EQ.0)  GOTO 40
          IF (ICDEP(ISPTR+IS-1).EQ.0) THEN
            IAPPST = 1
            GOTO 40
          ENDIF
          IRPTR = ICDEP(ISPTR+IS-1)
          NR = ICDEP(IRPTR)
          DO 30 IR = 1, NR
            IB = ICDEP(IRPTR+2*IR-1)
            IE = ICDEP(IRPTR+2*IR)
            DO 20 II = IB, IE
              IF (IC.EQ.II)  THEN
                ICODED = 1
                GOTO 40
              ENDIF
   20       CONTINUE
   30     CONTINUE
   40   CONTINUE
        IF (ICODED.NE.0) THEN
          IF (IAPPST.NE.0)  THEN
            JAPPST = 1
          ELSE
C           All states of KC make IC inapplicable.
            GOTO 200
          ENDIF
        ENDIF
  100 CONTINUE
C     IC can be coded.
      IF (JAPPST.NE.0)  ICODED = 0
 
  200 RETURN
      END
      SUBROUTINE INTSEC (IA, IB, N, IFIRST, NONZ)                           ITEM
 
C  REVISED 15-JAN-90.
C  PERFORMS THE LOGICAL INTERSECTION OF TWO ARRAYS.
 
C  IA RECEIVES THE FIRST ARRAY AND RETURNS THE RESULT.
C  IB RECEIVES THE SECOND ARRAY.
C  N RECEIVES THE NUMBER OF ELEMENTS TO BE COMPARED.
C  IFIRST RECEIVES AND RETURNS A FLAG.
 
      DIMENSION IA(N),IB(N)
 
      IF (IFIRST.EQ.1)  THEN
        CALL COPIA (IB, IA, N)
        IFIRST = 0
        NONZ = 1
      ELSE
        NONZ = 0
        DO 10 I = 1, N
          IF (IA(I).EQ.0)  GOTO 10
          IF (IB(I).EQ.0)  THEN
            IA(I) = 0
          ELSE
            NONZ = 1
          ENDIF
   10     CONTINUE
      ENDIF
 
      RETURN
      END
      SUBROUTINE MERGI (IDAM, IDAV, IDAT, LIDAT, MASTAD, NC,                ITEM
     * IVARIT, IDIFF)
C
C* REVISED 26-JUL-89.
C* COPIES CURRENT ITEM, MERGING MAIN AND VARIANT IF REQUIRED.
C
C  IDAM RECEIVES THE MAIN ITEM.
C  IDAV RECEIVES THE VARIANT ITEM (IF IVARIT.NE.0).
C  IDAT RETURNS THE COPIED ITEM.
C  LIDAT RECEIVES THE LENGTH OF IDAM, IDAV, AND IDAT. ITS VALUE MUST
C    BE IDENTICAL WITH THE VALUE IN DIM XXX.
C  MASTAD RETURNS WHICH DATA HAS BEEN COPIED FROM MASTER ITEM.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  IVARIT RECEIVES 1 IF THE CURRENT ITEM IS A VARIANT, ELSE 0.
C  IDIFF RECEIVES 1 IF THE VARIANT ITEM IS TO BE COPIED UNCHANGED,
C    0 IF MISSING ATTRIBUTES ARE TO BE FILLED IN FROM THE MAIN ITEM.
C
      DIMENSION IDAM(LIDAT),IDAV(LIDAT),IDAT(LIDAT),MASTAD(NC)
 
C     CLEAR FLAG ARRAY.
      DO 10 IC = 1, NC
        MASTAD(IC) = 0
   10   CONTINUE
 
      IF (IVARIT.NE.0)  GO TO 100
C
C--   COPY MAIN ITEM.
      CALL COPIA (IDAM, IDAT, NC+IDAM(NC+1))
      GO TO 1000
C
C--   VARIANT ITEM.
  100 IF (IDIFF.EQ.0)  GO TO 200
C
C-    COPY.
      CALL COPIA (IDAV, IDAT, NC+IDAV(NC+1))
      GO TO 1000
C
C-    MERGE WITH MAIN ITEM.
C     COPY NAME.
  200 CALL COPIA (IDAV(NC+2), IDAT(NC+2), IDAV(NC+2))
      JIDAT = NC + 1 + IDAV(NC+2)
C
      DO 300 IC = 1, NC
        IF (IDAV(IC).NE.0)  GO TO 250
C
C       COPY ATTRIBUTE FROM MAIN ITEM.
        IF (IDAM(IC).GT.0)  GO TO 220
        IDAT(IC) = IDAM(IC)
        GO TO 300
  220   JG = IDAM(IC)
        IF (JIDAT+IDAM(JG).GT.LIDAT)  GOTO 1100
        IDAT(IC) = JIDAT + 1
        CALL COPIA (IDAM(JG), IDAT(JIDAT+1), IDAM(JG))
        JIDAT = JIDAT + IDAM(JG)
        MASTAD(IC) = 1
        GO TO 300
C
C       COPY ATTRIBUTE FROM VARIANT ITEM.
  250   IF (IDAV(IC).GT.0)  GO TO 270
        IDAT(IC) = IDAV(IC)
        GO TO 300
  270   JG = IDAV(IC)
        IF  (JIDAT+IDAV(JG).GT.LIDAT)  GOTO 1100
        IDAT(IC) = JIDAT + 1
        CALL COPIA (IDAV(JG), IDAT(JIDAT+1), IDAV(JG))
        JIDAT = JIDAT + IDAV(JG)
  300   CONTINUE
C
      IDAT(NC+1) = JIDAT - NC
C--
 1000 RETURN
 
 1100 CALL MESSB (35, LIDAT, 1, -1, 0)
 
      END
      SUBROUTINE NEXWRD (ITEXT, LTEXT, IB, IE)                              ITEM
 
C  REVISED 3-AUG-98.
C  RETURNS NEXT WORD IN THE TEXT.
 
C  TEXT RECEIVES THE TEXT.
C  LTEXT RECEIVES THE LENGTH OF TEXT.
C  IB RECEIVES THE CURRENT POSITION IN TEXT AND RETURNS THE START
C   POSITION OF THE WORD.
C  IE RETURNS THE FIRST POSITION AFTER THE WORD.
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH

      DIMENSION ITEXT(LTEXT)
 
C     FIND NEXT NON-BLANK.
      INCMT = 0
    5 IF (IB.GT.LTEXT)  GOTO 100
      IF (ITEXT(IB).NE.KBLANK)  THEN
        IF (ITEXT(IB).EQ.KDLBRA)  THEN
          INCMT = INCMT + 1
        ELSEIF (ITEXT(IB).EQ.KDRBRA)  THEN
          INCMT = INCMT - 1
        ELSE IF (INCMT.EQ.0)  THEN
          GOTO 10
        ENDIF
      ENDIF
      IB = IB + 1
      GOTO 5
 

   10 IE = IB + 1
 
      DO WHILE (IE.LE.LTEXT)
        IF (ITEXT(IE).EQ.KBLANK)  GOTO 100
        IE = IE + 1
      ENDDO

  100 RETURN
      END
      SUBROUTINE RDITEM (ITYPC, NSTAT, IMPL1, IMPL2, IMPFLG,                ITEM
     * ITMADD, MANDC, LSTDEP, SCALF, MM1C, MM2C, NC, ICDEP, MM1S, MM2S,
     * MS, ITXIMG, ITXREC, IADNAM, IADREC, IEMNAM, IEMREC, ITHD,
     * ITHREC, ITFILE, ITFREC, IXHD, IXHREC, ITLNK, ILKREC, IDAM, IDAV,
     * IDAT, ITYPMK, LIDAT, JIDAT, JI, JT, IVARIT, MI, NIERR, INAME)
 
C  REVISED 10-NOV-99.
C  READS AN ITEM NAME AND DESCRIPTION.
 
C  27-FEB-89. SCALE REAL CHARACTERS.
C  8/9/87. CHECK FOR MANDATORY CHARACTERS.
C  24/11/86. SET AND FLAG IMPLICIT VALUES IN MASTER ITEM.
C            FLAG ADDITIONS TO VARIANT ITEM FROM MASTER.
C  13/10/86. VARIANT ITEMS NOW DEFINED ONLY BY #+ (NOT BY SAME NAME).
 
C  AN ITEM BEGINS WITH BLANK-NUMERO (KDNUM), AND IS TERMINATED BY
C    THE START OF THE NEXT ITEM OR CONTROL PHRASE.
C
C  ITYPC RECEIVES THE TYPES OF THE CHARACTERS. 1 - UNORDERED
C    MULTISTATE. 2 - ORDERED MULTISTATE. 3 - NUMERIC INTEGER.
C    4 - NUMERIC REAL. -1 - EXCLUSIVE UNORDERED MULTISTATE.
C    -2 - EXCLUSIVE ORDERED MULTISTATE.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  IMPL1 RECEIVES TYPE-1 IMPLICIT VALUES.
C  IMPL2 RECEIVES TYPE-2 IMPLICIT VALUES.
C  IMPFLG RETURNS WHERE IMPLICIT VALUES HAVE BEEN SET IN THE
C   MASTER ITEM.
C  ITMADD RETURNS WHERE DATA HAS BEEN COPIED TO A VARIANT ITEM.
C  MANDC RECEIVES WHETHER CHARACTERS ARE MANDATORY.
C  LSTDEP RETURNS CHARACTERS WHICH ARE IMPLICITLY CODED N/A.
C  SCALF RECEIVES SCALING FACTORS FOR REAL NUMERIC CHARACTERS.
C  MM1C RECEIVES WORKING SPACE OF LENGTH NC.
C  MM2C RECEIVES WORKING SPACE OF LENGTH NC.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  ICDEP RECEIVES THE CHARACTER DEPENDENCY DATA.
C  MM1S RECEIVES WORKING SPACE OF LENGTH MS.
C  MM2S RECEIVES WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C  ITXIMG RECEIVES RECORD POINTERS TO TAXON NAMES ON LUNS.
C  ITXREC RETURNS `TAXON IMAGE' DATA RECORD POINTERS FOR SUCCESSFULLY MATCHED NAMES.
C  IADNAM RECEIVES RECORD POINTERS TO TAXON NAMES ON LUNS.
C  IADREC RETURNS `ADD CHARACTERS' DATA RECORD POINTERS FOR SUCCESSFULLY MATCHED NAMES.
C  IEMNAM RECEIVES RECORD POINTERS TO TAXON NAMES ON LUNS.
C  IEMREC RETURNS `EMPHASIZE CHARACTERS' DATA RECORD POINTERS FOR SUCCESSFULLY MATCHED NAMES.
C  ITHD RECEIVES RECORD POINTERS TO TAXON NAMES ON LUNS.
C  ITHREC RETURNS `ITEM HEADINGS' DATA RECORD POINTERS FOR SUCCESSFULLY MATCHED NAMES.
C  ITFILE RECEIVES RECORD POINTERS TO TAXON NAMES ON LUNS.
C  ITFREC RETURNS `ITEM OUTPUT FILES' DATA RECORD POINTERS FOR SUCCESSFULLY MATCHED NAMES.
C  IXHD RECEIVES RECORD POINTERS TO TAXON NAMES ON LUNS.
C  IXHREC RETURNS `INDEX HEADINGS' DATA RECORD POINTERS FOR SUCCESSFULLY MATCHED NAMES.
C  ITLNK RECEIVES RECORD POINTERS TO TAXON NAMES ON LUNS.
C  ILKREC RETURNS `TAXON LINKS' DATA RECORD POINTERS FOR SUCCESSFULLY MATCHED NAMES.
C  IDAM RECEIVES THE ITEM IF IT IS A MASTER ITEM.
C  IDAV RECEIVES THE ITEM IF IT IS A VARIANT.
C  IDAT RECEIVES WORKING SPACE OF LENGTH LIDAT.
C  ITYPMK RECEIVES THE TYPESETTING MARKS.
C  LIDAT RECEIVES THE LENGTH OF IDAM,IDAV AND ICDEP.
C  JI RECEIVES 0 AT THE FIRST CALL, AND RETURNS THE ITEM NUMBER.
C  JT RECEIVES 0 AT THE FIRST CALL, AND RETURNS THE TAXON NUMBER.
C  IVARIT RETURNS 0 IF THE ITEM IS A MASTER, 1 IF IT IS A VARIANT.
C  MI RECEIVES THE MAXIMUM NUMBER OF ITEMS.
C  NIERR RETURNS THE NUMBER OF ERRORS IN THE ITEM.
C  INAME RETURNS 1 IF THE ITEM NAME IS VALID, 0 IF IT IS NOT, OR
C    -1 IF THE FIRST NON-BLANK SYMBOL IS NOT NUMERO.
C
C  METHOD OF STORING ITEM DESCRIPTION (IDAT = IDAM OR IDAV).
C
C  IDAT(NC+1) CONTAINS THE LENGTH OF THE ITEM BEYOND THE FIRST
C    NC ELEMENTS.
C    THE ITEM DESCRIPTION IS DIVIDED INTO GROUPS OF CONTIGUOUS ELEMENTS.
C    THE GROUP STARTING AT IDAT(NC+2) CONTAINS THE
C    ITEM NAME. IDAT(IC) IS THE POSITION IN IDAT OF THE START OF THE
C    GROUP CONTAINING ATTRIBUTE IC. IDAT(IC) IS SET TO 0 IF ATTRIBUTE IC
C    IS NOT PRESENT, AND TO -1 IF THERE IS AN ERROR IN THE ATTRIBUTE.
C    EACH GROUP IS DIVIDED INTO SUBGROUPS. THE FIRST ELEMENT OF THE
C    GROUP CONTAINS THE LENGTH OF THE GROUP, AND THE SECOND ELEMENT IS
C    THE START OF THE FIRST SUBGROUP. THE FIRST ELEMENT OF EACH SUBGROUP
C    CONTAINS THE LENGTH OF THE SUBGROUP, AND THE SECOND ELEMENT
C    CONTAINS A FLAG INDICATING THE TYPE OF THE SUBGROUP.
C    THE MEANINGS OF THE FLAGS ARE AS FOLLOWS.
C    1 - PART OF THE ITEM NAME, OR AN ORDINARY VALUE OR RANGE OF
C    VALUES (-).
C    2 - RANGE OF VALUES (&).
C    3 - INFINITE RANGE (~).
C    6 - VARIABLE.
C    7 - UNKNOWN.
C    8 - NOT APPLICABLE.
C    0 - TEXT COMMENT.
C    LESS THAN 0 - NOT USED. AVAILABLE FOR EXTENSIONS, SUCH AS CODED
C    OR NUMERIC COMMENTS.
C
C  ON ENTRY, JBUF MUST BE POSITIONED AT THE START OF AN ITEM OR CONTROL
C    PHRASE (NUMERO OR STAR), OR BE SEPARATED FROM IT ONLY BY BLANKS.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED AND NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE START OF THE NEXT ITEM OR
C    CONTROL PHRASE.
C
C  LOCAL VARIABLES.
C  IC = CHARACTER NUMBER.
C  NCERRS = VALUE OF NCERR AT START OF ITEM DESCRIPTION.
C
      DIMENSION ITYPC(NC),NSTAT(NC),IMPL1(NC),IMPL2(NC),IMPFLG(NC),
     * LSTDEP(NC),SCALF(NC),MM1C(NC),MM2C(NC),ITMADD(NC),MANDC(NC),
     * MM1S(MS),MM2S(MS),ICDEP(LIDAT),ITXIMG(MI),ITXREC(MI),
     * IADNAM(MI),IADREC(MI),IEMNAM(MI),IEMREC(MI),ITHD(MI),ITHREC(MI),
     * ITFILE(MI),ITFREC(MI),IXHD(MI),IXHREC(MI),ITLNK(MI),ILKREC(MI),
     * IDAM(LIDAT), IDAV(LIDAT),IDAT(LIDAT),ITYPMK(LIDAT)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /INPXXX/ IBUF(121),JBUF,JBDAT,JEDAT,IDERR,NCERR,NSERR,NWERR
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /MISXXX/ IMPVAL,IPACH,IPCHN,IPUNC,IRAB,IKEYCH,ICMPRS,
     * ITUNC,ITINAP,ITIMPL,IUNVAR,LNKC,IDEPC,LICDEP,IPSUMM,ICHSEQ,
     * ITMSEQ,INSRVA,IFATT,ITINTR,ICMAND,IUNRNG,IOMTOR,NEWFLS,IRSEMI,
     * IOMSTC,IADDCH,IEMPCH,IVARUN,ISCALC,ICNOTE,ICIMGE,ITIMGE,MTIMGE,
     * NTIMGE,IOMNSC,IOMCMT,IOMLOW,IERRPC,IERRAB,ICHNSE,NUMST0,IUMEAN,
     * NADNAM,NEMNAM,NODELO,IOMUSP,ICKYIMG,ITKYIMG,ISUPIMG,ICTIMGE,
     * ICTNAME,IHTML,IRTF,MTHEAD,NTHEAD,ITMHDGS,LCDNAM,MTFILE,NTFILE,
     * ITMFILS,MXHEAD,NXHEAD,IDXHDGS,INSIMGFN,ICOFILE,IUCC,IOUNC,ITLINK,
     * MTLINK,NTLINK,NAUTOCC,IOUTSUBJ
      COMMON /SCRCXX/ LRECSC
      COMMON /TRNXXX/ IPCHAR,IPITEM,IPNAME,ITRAN
 
      SAVE ITINDX1,ITINDX2,ITINDX3,ITINDX4,ITINDX5,ITINDX6,ITINDX7
 
C     ITEM NUMBER OF THE MOST RECENT MASTER ITEM
C     SAVE JIM
      EXTERNAL SCALE
 
C--   INITIALIZE. READ MINOR CONTROL PHRASES.
      DO 20 IC = 1, NC
   20   IDAV(IC) = 0
      IC = 0
      NATT = 0
      CALL SKNONB
      NCERRS = NCERR
   30 IF (IBUF(JBUF).EQ.KDNUM)  GO TO 100
      IF (IBUF(JBUF).EQ.KDSTAR)  THEN
        INAME = -1
        GO TO 1000
      ELSE
        CALL MESSA (6, 3, JBUF-1)
        CALL SKDELW (1)
        GOTO 30
      ENDIF
C
C--   READ ITEM NAME.
  100 JI = JI + 1
      IF (JI.GT.MI)  GOTO 1000
      JIDAT = NC + 1
      JBUF = JBUF + 1
      IVARIT = 0
      IF (IBUF(JBUF).EQ.KDPLUS) THEN
C       FIRST ITEM CANNOT BE A VARIANT ITEM.
        IF (JI.EQ.1)  CALL MESSA(158, -4, JBUF)
        IVARIT = 1
        JBUF = JBUF + 1
      ENDIF
      CALL SENTNC (IDAV, LIDAT, 2, JIDAT, INAME)
      IF (INAME.NE.1)  GO TO 900
      CALL SAVTNAME (IDAV(NC+2), JIDAT)
      IMPLNAM = IMPNAM(IDAV(NC+2), JIDAT)
      IF (IMPLNAM.NE.0)  GOTO 150
 
      IF (JI.EQ.1)  THEN
        ITINDX1 = 0
        ITINDX2 = 0
        ITINDX3 = 0
        ITINDX4 = 0
        ITINDX5 = 0
        ITINDX6 = 0
        ITINDX7 = 0
      ENDIF
 
C     Remove typesetting marks from name. Modified name is saved in IDAT.
C     This is used for name matching only.
      CALL REMTPS (IDAV(NC+2), JIDAT, IDAT, LIDAT, 0)
      NAMLEN = IDAT(1)
 
C     Compare name with those specified in `TAXON IMAGES' directive.
      IF ((ITRAN.EQ.4.OR.ITRAN.EQ.9).AND.MTIMGE.GT.0)
     *  CALL CMPNAM (IDAT, LIDAT, JI, ITXIMG, MTIMGE, ITXREC, MI,
     *    MM1C, MM2C, NC, IDAT(NAMLEN+1), LIDAT-NAMLEN, LUNS7, 32,
     *    LUNS6, 32, 0, 140,
     *    ITINDX1)
C     Compare name with those specified in `ADD CHARACTERS' directive.
      IF (ITRAN.EQ.4.AND.NADNAM.GT.0)
     *  CALL CMPNAM (IDAT, LIDAT, JI, IADNAM, NADNAM, IADREC, MI,
     *    MM1C, MM2C, NC, IDAT(NAMLEN+1), LIDAT-NAMLEN, LUNS7, 32,
     *    LUNS4, LRECSC, 1, 0,
     *    ITINDX2)
C     Compare name with those specified in `EMPHASIZE CHARACTERS' directive.
      IF (ITRAN.EQ.4.AND.NEMNAM.GT.0)
     *  CALL CMPNAM (IDAT, LIDAT, JI, IEMNAM, NEMNAM, IEMREC, MI,
     *    MM1C, MM2C, NC, IDAT(NAMLEN+1), LIDAT-NAMLEN, LUNS7, 32,
     *    LUNS5, LRECSC, 1, 0,
     *    ITINDX3)
C     Compare name with those specified in `ITEM HEADINGS' directive.
      IF (ITRAN.EQ.4.AND.MTHEAD.GT.0)
     *  CALL CMPNAM (IDAT, LIDAT, JI, ITHD, MTHEAD, ITHREC, MI,
     *    MM1C, MM2C, NC, IDAT(NAMLEN+1), LIDAT-NAMLEN, LUNS7, 32,
     *    LUNS5, LRECSC, 0, 155,
     *    ITINDX4)
C     Compare name with those specified in `ITEM OUTPUT FILES' directive.
      IF ((ITRAN.EQ.4.OR.ITRAN.EQ.9).AND.MTFILE.GT.0)
     *  CALL CMPNAM (IDAT, LIDAT, JI, ITFILE, MTFILE, ITFREC, MI,
     *    MM1C, MM2C, NC, IDAT(NAMLEN+1), LIDAT-NAMLEN, LUNS7, 32,
     *    LUNS5, LRECSC, 0, 160,
     *    ITINDX5)
C     Compare name with those specified in `INDEX HEADINGS' directive.
      IF (ITRAN.EQ.4.AND.MXHEAD.GT.0)
     *  CALL CMPNAM (IDAT, LIDAT, JI, IXHD, MXHEAD, IXHREC, MI,
     *    MM1C, MM2C, NC, IDAT(NAMLEN+1), LIDAT-NAMLEN, LUNS7, 32,
     *    LUNS5, LRECSC, 0, 162,
     *    ITINDX6)
C     Compare name with those specified in `TAXON LINKS' directive.
      IF ((ITRAN.EQ.4.OR.ITRAN.EQ.9).AND.MTLINK.GT.0)
     *  CALL CMPNAM (IDAT, LIDAT, JI, ITLNK, MTLINK, ILKREC, MI,
     *    MM1C, MM2C, NC, IDAT(NAMLEN+1), LIDAT-NAMLEN, LUNS7, 32,
     *    LUNS6, 32, 0, 144,
     *    ITINDX7)
 
C     OUTPUT PROGESS REPORT.
  150 CALL PROGRS (1, JI, JI, MI, IDAV(NC+2), JIDAT-NC-1)
c  150 continue

      IF (IVARIT.NE.0)  GOTO 300
 
C-    IF ITEM IS A MASTER, TRANSFER NAME TO IDAM.
C     IF (JI.GT.1) THEN
C       IVARIT = IDSENT(IDAM(NC+2),IDAV(NC+2),LIDAT)
C       IF (IVARIT.NE.0)  GO TO 300
C     ENDIF
      JT = JT + 1
      CALL COPIA (IDAV, IDAM, JIDAT)
 
C--   READ ATTRIBUTES OF MASTER ITEM.
  250 CALL RDATT (ITYPC, NSTAT, NC, IDAM, LIDAT, JIDAT, 0, IC1, IC2)
        IF (IBUF(JBUF).NE.KBLANK)  GO TO 260
        NATT = NATT + 1
        GO TO 250
  260 IDAM(NC+1) = JIDAT - NC
      IF (NATT.EQ.0)  CALL MESSA (32, 4, JBUF-1)
      IF (IMPLNAM.NE.0)  GOTO 265
C     SET IMPLICIT VALUES.
      IF (IMPVAL.NE.0)  CALL SETIMP (IDAM, LIDAT, IMPL1, IMPL2,
     *  IMPFLG, NC)
      IF (ISCALC.NE.0)  CALL SCALE (IDAM, LIDAT, ITYPC, SCALF, NC)
C     CHECK DEPENDENCIES.
      ISETDP = 0
      IF (IDEPC.NE.0)  CALL CHKDEP (JI, ICDEP, NSTAT, ITYPC,
     * IMPFLG, LSTDEP, MM1C, MM2C, NC, MM1S, MM2S, MS, IDAM, LIDAT)
  265 CALL COPIA (IDAM, IDAT, NC+IDAM(NC+1))
      IF (IMPLNAM.NE.0)  GOTO 270
 
C     CHARACTER FOR TAXON IMAGES should be empty.
      IF (ICTIMGE.GE.1.AND.ICTIMGE.LE.NC)  THEN
        IF (IDAT(ICTIMGE).NE.0)  CALL MESSA(157, -3, 0)
      ENDIF

C     INSERT TAXON IMAGE LINKS FOR HTML OUTPUT.
      IF (ITIMGE.NE.0.AND.(IRTF.NE.0.OR.IHTML.NE.0).AND.
     *    ICTIMGE.GE.1.AND.ICTIMGE.LE.NC)  THEN
        IF (ITXREC(JI).NE.0) THEN
          LV = LIDAT/2
          CALL ADDILNK (ICTIMGE, NC, IDAT, ITYPMK, LIDAT, IDAV,
     *     IDAV(LV+1), LV, ITXREC(JI), INSIMGFN, IRTF, IHTML)
        ENDIF
      ENDIF
 
C     CHECK MANDATORY CHARACTERS.
      IF (ICMAND.NE.0)  CALL CHKMAN (JI, MANDC, NSTAT, ITYPC, NC,
     * IDAT, LIDAT, IDEPC, ICDEP, MM1S, MS)
  270 JIM = JI
      GO TO 1000
C
C--   READ ATTRIBUTES OF VARIANT ITEM.
  300 CALL RDATT (ITYPC, NSTAT, NC, IDAV, LIDAT, JIDAT, 0, IC1, IC2)
        IF (IBUF(JBUF).NE.KBLANK)  GO TO 310
        NATT = NATT + 1
        GO TO 300
  310 IDAV(NC+1) = JIDAT - NC
      IF (NATT.EQ.0)  CALL MESSA (32, 4, JBUF-1)
      IF (ITRAN.EQ.4.AND.IEMPCH.NE.0.AND.IEMREC(JI).NE.0)
     *  CALL ADDEMPC (IDAM, IDAV, ICDEP, LIDAT, IEMREC(JI), MM1C,
     *  NSTAT, ITYPC, NC, MM1S, MM2S, MS)
      IF (ISCALC.NE.0)  CALL SCALE (IDAV, LIDAT, ITYPC, SCALF, NC)
      CALL MERGI (IDAM, IDAV, IDAT, LIDAT, ITMADD, NC, IVARIT, 0)
C     CHECK DEPENDENCIES.
      IF (IDEPC.GT.0)  CALL CHKDEP (JI, ICDEP, NSTAT, ITYPC,
     * ITMADD, LSTDEP, MM1C, MM2C, NC, MM1S, MM2S, MS, IDAT, LIDAT)
C     INSERT TAXON IMAGE LINKS FOR HTML OUTPUT.
      IF (ITIMGE.NE.0.AND.(IRTF.NE.0.OR.IHTML.NE.0).AND.
     *    ICTIMGE.GE.1.AND.ICTIMGE.LE.NC)  THEN
        IF (IDAT(ICTIMGE).EQ.0.AND.ITXREC(JI).NE.0) THEN
          LV = LIDAT/2
          CALL ADDILNK (ICTIMGE, NC, IDAT, ITYPMK, LIDAT, IDAV,
     *     IDAV(LV+1), LV, ITXREC(JI), INSIMGFN, IRTF, IHTML)
        ENDIF
      ENDIF
C     CHECK MANDATORY CHARACTERS.
      IF (ICMAND.NE.0)  CALL CHKMAN (JI, MANDC, NSTAT, ITYPC, NC,
     * IDAT, LIDAT, IDEPC, ICDEP, MM1S, MS)
      GOTO 1000
C
  900 IF (INAME.EQ.-1)  CALL MESSA (98, -3, JBUF)
      INAME = 0
C--
 1000 NIERR = NCERR - NCERRS
 
      RETURN
      END
      SUBROUTINE SAVTNAME(ISEN, LSEN)
 
C  REVISED 16-JUL-98.
C  SAVES THE TAXON NAME FOR USE IN ERROR MESSAGES AND SUBSTITUTIONS.
 
C  ISEN RECEIVES THE NAME AS A SENTENCE. (SEE SUBR. SENTNC)
C  LSEN RECEIVES THE LENGTH OF ISEN.
 
      DIMENSION ISEN(LSEN)
 
      COMMON /BLKXXX/ KBLANK
      COMMON /TNAMEX/ TNAME,LTNAME
        CHARACTER*256 TNAME
 
      PARAMETER (MAXTNAME=256)
 
      IB = 0
      JSG = 2
      DO WHILE (JSG.LE.ISEN(1))
        IF (JSG.GT.2)  THEN
          IF (IB+1.GT.MAXTNAME)  GOTO 100
          IB = IB + 1
          TNAME(IB:IB) = CHAR(KBLANK)
        ENDIF
        K = JSG + 2
        L = ISEN(JSG) - 2
        NCOPY = MIN0(L, MAXTNAME-IB)
        IF (NCOPY.LE.0)  GOTO 100
        CALL COPIAS (ISEN(K), TNAME(IB+1:), NCOPY)
        IB = IB + NCOPY
        JSG = JSG + ISEN(JSG)
      ENDDO
 
  100 LTNAME = IB
      RETURN
      END
      SUBROUTINE SCALE (ITM, LIDAT, ITYPC, SCALF, NC)                       ITEM
 
C  REVISED 27-FEB-89.
C  APPLIES SCALING FACTOR TO REAL NUMERIC CHARACTERS.
 
C  ITM RECEIVES THE ITEM.
C  LIDAT RECEIVES THE LENGTH OF ITM.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  SCALF RECEIVES THE SCALING FACTORS FOR REAL NUMERIC CHARACTERS.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
 
      DIMENSION ITM(LIDAT),ITYPC(NC),SCALF(NC)
 
      COMMON /ITSXXX/ ITSS
 
      DO 50 IC = 1, NC
        IF (IABS(ITYPC(IC)).NE.4)  GOTO 50
        IF (ITM(IC).LE.0)  GOTO 50
        JG = ITM(IC)
        JGN = JG + ITM(JG)
        JSG = JG + 1
 
   20   ITS = ITM(JSG+1)
          IF (ITS.EQ.0.OR.ITS.GT.ITSS)  GOTO 40
          JB = JSG + 2
          JE = JSG+ITM(JSG) - 1
          DO 30 J = JB, JE
            X = RELIN (ITM(J))
            X = X * SCALF(IC)
            CALL RELOUT (X, ITM(J))
   30     CONTINUE
 
   40   JSG = JSG + ITM(JSG)
        IF (JSG.LT.JGN)  GOTO 20
 
   50 CONTINUE
 
      RETURN
      END
      SUBROUTINE SETIMP (ITM, LIDAT, IMPL1, IMPL2, IMPFLG, NC)              ITEM
C
C* REVISED 26-JUL-89.
C* SETS IMPLICIT VALUES IN AN ITEM.
C
C  ITM RECEIVES AND RETURNS THE ITEM.
C  LIDAT RECEIVES THE LENGTH OF ITM.
C  IMPL1 RECEIVES THE FIRST SET OF IMPLICIT VALUES.
C  IMPL2 RECEIVES THE SECOND SET OF IMPLICIT VALUES.
C  IMPFLG RETURNS WHERE IMPLICIT VALUES HAVE BEEN SET IN THE ITEM.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C
      DIMENSION ITM(LIDAT),IMPL1(NC),IMPL2(NC),IMPFLG(NC)
 
C     CLEAR FLAG ARRAY.
      DO 10 IC = 1, NC
        IMPFLG(IC) = 0
   10   CONTINUE
 
C     CURRENT LENGTH OF ITEM.
      JITM = NC + ITM(NC+1)
C
      DO 500 IC = 1, NC
        IF (ITM(IC).LT.0)  GO TO 500
        JGI = JITM + 1
        IF (ITM(IC).GT.0)  GO TO 100
C
C--     ATTRIBUTE COMPLETELY MISSING.
        IF (IMPL1(IC).EQ.0)  GO TO 500
        ITM(IC) = JGI
        IF (IMPL1(IC).LT.0)  GO TO 50
        IF (JGI+3.GT.LIDAT)  GOTO 1100
        ITM(JGI) = 4
        ITM(JGI+1) = 3
        ITM(JGI+2) = 1
        ITM(JGI+3) = IMPL1(IC)
        JITM = JGI + 3
        IMPFLG(IC) = 1
        GO TO 500
C
C       VARIABLE, UNKNOWN OR NOT APPLICABLE.
   50   IF (JGI+2.GT.LIDAT)  GOTO 1100
        ITS = IMPL1(IC) + 9
        ITM(JGI) = 3
        ITM(JGI+1) = 2
        ITM(JGI+2) = ITS
        JITM = JGI + 2
        IMPFLG(IC) = 1
        GO TO 500
C
C--     AT LEAST CHARACTER NUMBER PRESENT.
  100   IF (IMPL2(IC).EQ.0)  GO TO 500
        JG = ITM(IC)
        L = ITM(JG)
        IF (L.GT.1)  GO TO 120
C
C-      NO COMMENTS OR VALUES PRESENT.
        ITM(JGI) = 1
        JITM = JGI
        GO TO 200
C
C-      SOME COMMENTS OR VALUES PRESENT.
  120   IF (L.NE.ITM(JG+1)+1.OR.ITM(JG+2).GT.0)  GO TO 500
        IF (JITM+L.GT.LIDAT)  GOTO 1100
        CALL COPIA (ITM(JG), ITM(JGI), L)
        JITM = JITM + L
C
C-      VALUE MISSING. INSERT SECOND IMPLICIT VALUE.
  200   ITM(IC) = JGI
        IF (IMPL2(IC).LT.0)  GO TO 210
        ITM(JGI) = L+3
        IF (JGI+3.GT.LIDAT)  GOTO 1100
        ITM(JITM+1) = 3
        ITM(JITM+2) = 1
        ITM(JITM+3) = IMPL2(IC)
        JITM = JITM + 3
        IMPFLG(IC) = 2
        GO TO 500
C
C       VARIABLE, UNKNOWN OR NOT APPLICABLE.
  210   IF (JGI+2.GT.LIDAT)  GOTO 1100
        ITS = IMPL2(IC) + 9
        ITM(JGI) = L + 2
        ITM(JITM + 1) = 2
        ITM(JITM + 2) = ITS
        JITM = JITM + 2
        IMPFLG(IC) = 2
C--
  500   CONTINUE
C--
      ITM(NC+1) = JITM - NC
      RETURN
 
 1100 CALL MESSB (35, LIDAT, 1, -1, 0)
 
      END
      FUNCTION  WD2BUF (NW, IBUF, LBUF, JBUF)                              ITEM
 
C * REVISED 13-AUG-98.
C* OUTPUTS A WORD SELECTED FROM A VOCABULARY TO A BUFFER.
 
C  NW RECEIVES THE NUMBER OF THE WORD IN THE VOCABULARY.
C  IBUF RECEIVES AND RETURNS THE BUFFER.
C  LBUF RECEIVES THE LENGTH OF IBUF.
C  JBUF RECEIVES THE INSERTION POINT IN BUFFER AND RETURNS THE NEXT AVAILABLE
C   POSITION IN THE BUFFER.
C
      COMMON /VWDXXX/ VWORD(18)
        CHARACTER*40 VWORD
      COMMON /VLWXXX/ NVWD,MAXVWD,LVWD(18),IBPUNC,IEPUNC,
     * KVSTOP,KVCOM1,KVCOM2,KVSEMI,KVDEC
 
      DIMENSION IBUF(LBUF)
C
      WD2BUF = 1
 
      IF (NW.LE.0.OR.NW.GT.NVWD)  CALL BUG (9, NW)
      L = LVWD(NW)
      IF (L.LE.0.OR.L.GT.MAXVWD)  CALL BUG (10, NW)
      IF (JBUF+L.GT.LBUF) GOTO 20
      DO 10 IL = 1, L
        IBUF(JBUF) = ICHAR (VWORD(NW)(IL:IL))
        JBUF = JBUF + 1
   10   CONTINUE
      GOTO 30
 
   20 WD2BUF = 0
 
   30 RETURN
      END
