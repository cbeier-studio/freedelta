      SUBROUTINE ACCSUM (ISUMM, ITM, ISBND, LLANG, IDAT, LIDAT, NSTAT,      TRAN
     * KSTAT,
     * ITYPC, IMC, NORNG, NC, IUNRNG, IOMNSC, ISTAT, MS, IMI, JI)
 
C* REVISED 31-MAR-98.
C* ACCUMULATES SUMMARY STATISTICS.
 
C  ISUMM RECEIVES AND RETURNS THE SUMMARY STATISTICS.
C  ITM RECEIVES AN ITEM.
C  ISBND RECEIVES THE KEY STATE BOUNDARIES.
C  LLANG RECEIVES THE LIST OF VALID LANGUAGES.
C  IDAT RECEIVES WORKING SPACE OF LENGTH LIDAT.
C  LIDAT RECEIVES THE LENGTH OF ITM, ISBND.
C  NSTAT RECEIVES THE NUMBER OF STATES.
C  KSTAT RECEIVES THE NUMBER OF KEY STATES.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  IMC RECEIVES THE CHARACTER MASK.
C  NORNG RECEIVES WHERE TO USE NORMAL CHARACTER RANGES.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  IUNRNG RECEIVES WHETHER TO USE NORMAL CHARACTER RANGES.
C  IOMNSC RECEIVES TO IGNORE NESTED COMMENTS.
C  ISTAT RECEIVES WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C  IMI RECEIVES THE ITEM MASK.
C  JI RECEIVES THE ITEM NUMBER.
 
      DIMENSION ISUMM(LIDAT),ITM(LIDAT),ISBND(LIDAT),LLANG(LIDAT),
     * IDAT(LIDAT),
     * NSTAT(NC),KSTAT(NC),ITYPC(NC),IMC(NC),NORNG(NC),
     * ISTAT(MS),IMI(JI),ITSF(3)
 
      COMMON /ITSXXX/ ITSS
      COMMON /LANGXX/ IUSELNG1,IUSELNG2,NLANG
 
      IF (IMI(JI).EQ.0)  GOTO 1100
 
      DO 1000 IC = 1, NC
        IF (IMC(IC).EQ.0)  GOTO 1000
        JISUM = ISUMM(IC)
        IF (ITM(IC).NE.0)  GOTO 20
C         UNCODED.
          ISUMM(JISUM) = ISUMM(JISUM) + 1
          GOTO 1000
   20   JTYPC = IABS(ITYPC(IC))
        IF (JTYPC.EQ.5)  THEN
C         Need to check for empty comments. These are defined to be uncoded.
          JG = ITM(IC)
          JGN = JG + ITM(JG)
          JSG = JG + 1
          KIDAT = 0
   21     IF (JSG.GE.JGN)  GOTO 22
            ITS = ITM(JSG+1)
            IF (ITS.EQ.0)  THEN
              LEN = ITM(JG)
              ICOMM = 1
              IF (IOMNSC.NE.0)  ICOMM = 3
              CALL SENSIM (ITM(JG), LEN, IDAT(KIDAT), LEN, 0, L,
     *         ICOMM, 0)
              IF (NLANG.GT.0.AND.IUSELNG1.GT.0) THEN
                CALL LANGCMT (LLANG, LIDAT, IUSELNG1, IUSELNG2,
     *            NLANG, IDAT(KIDAT), L, NEWL)
                L = NEWL
              ENDIF
              IF (L.EQ.0) THEN
                IUNK = 1
              ELSE
                IUNK = 0
              ENDIF
            ELSEIF (ITS.EQ.7)  THEN
C             UNKNOWN.
              IUNK = 1
            ENDIF
            JSG = JSG + ITM(JSG)
            GOTO 21
   22     IF (IUNK.NE.0)  ISUMM(JISUM) = ISUMM(JISUM) + 1
          GOTO 1000
        ENDIF
        IKSTAT = 0
        IF (JTYPC.GE.3)  GOTO 500
 
C--     MULTISTATE.
        CALL FINDST (ITM, IC, LIDAT, ITYPC, NSTAT, NC,
     *   ISTAT, MS, ITSF)
        NS = NSTAT(IC)
        JVSUM = JISUM + 3
 
   25   JB = JVSUM + 1
        IF (ITSF(1).EQ.0)  GOTO 50
          DO 30 IS = 1, NS
            ISTAT(IS) = 1
   30       CONTINUE
   50   ICODED = 0
        DO 100 IS = 1, NS
          ISUMM(JB) = ISUMM(JB) + ISTAT(IS)
          ICODED = ICODED + ISTAT(IS)
          JB = JB + 1
  100     CONTINUE
 
        JCODED = ICODED
        DO 120 I = 1, 3
          JCODED = JCODED + ITSF(I)
  120     CONTINUE
 
C       VARIABLE.
        IF (ICODED.GT.1)  ISUMM(JVSUM) = ISUMM(JVSUM) + 1
        IF (IKSTAT.NE.0)  GOTO 1000
 
C       INAPPLICABLE.
        IF (ITSF(3).NE.0) THEN
C         DON'T COUNT "sometimes inapplicable" HERE
          IF (ICODED.EQ.0) ISUMM(JISUM+1) = ISUMM(JISUM+1) + 1

C       UNCODED OR UNKNOWN.
        ELSEIF (JCODED.EQ.0.OR.ITSF(2).NE.0) THEN
          ISUMM(JISUM) = ISUMM(JISUM) + 1
 
        ENDIF
 
C       NO. CODED.
        IF (ICODED.GE.1)
     *    ISUMM(JISUM+2) = ISUMM(JISUM+2) + 1
 
C-      KEY STATES.
        IF (ISBND(IC).EQ.0)  GOTO 1000
          IKSTAT = 1
          JVSUM = JISUM + 4 + NSTAT(IC)
          NS = KSTAT(IC)
          CALL FNDKST (ITM, ISBND, IC, LIDAT, ITYPC, KSTAT, NORNG, NC,
     *     IUNRNG, ISTAT, MS, ITSF, JI, 0.0, 0.0)
          GOTO 25
 
 
C--     NUMERIC.
  500   JG = ITM(IC)
        JGN = JG + ITM(JG)
        JSG = JG + 1
        V = 0.
        NUMV = 0
        ITMIN = ISUMM(JISUM+3)
        ITMAX = ISUMM(JISUM+4)
        VMIN = RELIN(ISUMM(JISUM+5))
        VMAX = RELIN(ISUMM(JISUM+6))
 
  510   IF (JSG.GE.JGN)  GOTO 600
          ITS = ITM(JSG+1)
          IF (ITS.LE.0)  GOTO 560
          IF (ITS.GT.ITSS)  GOTO 550
          JB = JSG+2
          JE = JSG + ITM(JSG) - 1
 
          NV = JE - JB + 1
 
C         MAXIMUM AND MINIMUM.
C         USE NORMAL RANGE?
          IF (NV.GT.3.AND.IUNRNG.NE.0.AND.NORNG(IC).NE.0)  THEN
            JB = JB + 1
            JE = JE - 1
          ENDIF
          IF (JTYPC.EQ.3)  THEN
            X1 = FLOAT(ITM(JB))
            X2 = FLOAT(ITM(JE))
          ELSE IF (JTYPC.EQ.4)  THEN
            X1 = RELIN(ITM(JB))
            X2 = RELIN(ITM(JE))
          ENDIF
          IF (X1.LT.VMIN) THEN
            VMIN = X1
            ITMIN = JI
          ENDIF
          IF (X2.GT.VMAX)  THEN
            VMAX = X2
            ITMAX = JI
          ENDIF
 
C         FOR MEAN AND STANDARD DEVIATION,
C         USE MIDVALUE OF RANGE OR AVERAGE OF TWO INNERMOST VALUES.
          NV2 = NV/2
          JB = JB + NV2 - 1
          JE = JB + 1
          IF (NV-NV2*2.NE.0)  JB = JB + 1
 
          DO 530 J = JB, JE
            IF (JTYPC.EQ.3)  THEN
              X = FLOAT(ITM(J))
            ELSE IF (JTYPC.EQ.4)  THEN
              X = RELIN(ITM(J))
            ENDIF
            V = V + X
            NUMV = NUMV + 1
  530       CONTINUE
 
          GOTO 560
 
  550     ITS = ITS - ITSS
          DO 555 I = 2, 3
            IF (ITS.EQ.I)  ISUMM(JISUM+I-2) = ISUMM(JISUM+I-2) + 1
  555       CONTINUE
 
  560     JSG = JSG + ITM(JSG)
          GOTO 510
 
  600   IF (NUMV.LE.0)  GOTO 650
        V = V/FLOAT(NUMV)
        ISUMM(JISUM+2) = ISUMM(JISUM+2) + 1
        ISUMM(JISUM+3) = ITMIN
        ISUMM(JISUM+4) = ITMAX
        JISUM = JISUM + 5
        CALL RELOUT (VMIN, ISUMM(JISUM))
        JISUM = JISUM + 1
        CALL RELOUT (VMAX, ISUMM(JISUM))
        JISUM = JISUM + 1
        X = RELIN(ISUMM(JISUM))
        X = X + V
        CALL RELOUT (X, ISUMM(JISUM))
        JISUM = JISUM + 1
        X = RELIN(ISUMM(JISUM))
        X = X + V*V
        CALL RELOUT (X, ISUMM(JISUM))
        JISUM = JISUM + 1
 
C       KEY STATES.
  650   IF (ISBND(IC).EQ.0)  GOTO 1000
          IKSTAT = 1
          JVSUM = JISUM
          NS = KSTAT(IC)
          CALL FNDKST (ITM, ISBND, IC, LIDAT, ITYPC, KSTAT, NORNG, NC,
     *     IUNRNG, ISTAT, MS, ITSF, JI, 0.0, 0.0)
          GOTO 25
 
 1000   CONTINUE
 
 1100 RETURN
      END
      SUBROUTINE FNDKST (IDAT, ISBND, IC, LIDAT, ITYPC, KSTAT, NORNG,       TRAN
     * NC, IUNRNG, ISTAT, MS, ITSF, JI, PCTERR, ABSERR)
 
C* REVISED 07-OCT-98.
C* FINDS WHICH KEY STATES ARE PRESENT IN AN ATTRIBUTE.
 
C  IDAT RECEIVES THE ITEM.
C  ISBND RECEIVES THE NEW KEY STATES.
C  IC RECEIVES THE CHARACTER NUMBER.
C  LIDAT RECEIVES THE LENGTH OF IDAT AND ISBND.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  KSTAT RECEIVES THE NUMBERS OF NEW STATES.
C  NORNG RECEIVES WHERE TO USE NORMAL CHARACTER RANGES.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  IUNRNG RECEIVES WHETHER TO USE NORMAL CHARACTER RANGES.
C  ISTAT RETURNS FLAGS INDICATING WHICH STATES ARE PRESENT.
C  MS RECEIVES THE LENGTH OF ISTAT.
C  ITSF RETURNS FLAGS INDICATING WHICH OF THE PSEUDOVALUE FLAGS ARE
C    PRESENT.
C  JI RECEIVES THE ITEM NUMBER.
C  PCTERR RECEIVES THE PERCENT ERROR FOR THE CHARACTER.
C  ABSERR RECEIVES THE ABSOLUTE ERROR FOR THE CHARACTER.
 
      DIMENSION IDAT(LIDAT),ISBND(LIDAT),ITYPC(NC),KSTAT(NC),NORNG(NC),
     * ISTAT(MS),ITSF(3),IVAL(2)
 
      COMMON /ITSXXX/ ITSS
      COMMON /TNAMEX/ TNAME,LTNAME
        CHARACTER*256 TNAME
 
      NS = KSTAT(IC)
 
C     REMOVED 1-JUN-94. SUCH CHARACTERS SHOULD BE MASKED OUT BY S/R CHKDK.
C     IF (NS.LE.1)  GOTO 1000
 
      IF (NS.LE.0)  GOTO 1000
      DO 20 IS = 1, NS
   20   ISTAT(IS) = 0
      DO 22 I = 1, 3
   22   ITSF(I) = 0
      IF (IDAT(IC).LE.0)  GOTO 1000
      JG = IDAT(IC)
      JSG = JG + 1
      JGN = JG + IDAT(JG)
      JTYPC = IABS(ITYPC(IC))
 
C---  SCAN GROUPS OF ATTRIBUTE.
   50 IF (JSG.GE.JGN)  GOTO 1000
        ITS = IDAT(JSG+1)
        IF (ITS.LE.0)  GOTO 500
        NODATA = 0
 
C       RECORD PRESENCE OF PSEUDOVALUE.
        IF (ITS.LE.ITSS)  GOTO 100
        I = ITS - ITSS
        ITSF(I) = 1
        GOTO 500
 
  100   JB = JSG + 2
        JE = JSG + IDAT(JSG) - 1
        IF (ITS.EQ.1)  THEN
          NV = JE - JB + 1
C         USE NORMAL RANGE?
          IF (NV.GT.3.AND.IUNRNG.NE.0.AND.NORNG(IC).NE.0)  THEN
            JB = JB + 1
            JE = JE - 1
          ENDIF
        ENDIF
        IF (ISBND(IC).GT.0)  GOTO 200
 
C--     ORIGINAL STATES.
        IF (JTYPC.EQ.2 .AND.ITS.EQ.1)  GOTO 140
C       UNORDERED MULTISTATE, OR ORDERED MULTISTATE WITH 'AND'.
        DO 122 J = JB, JE
          IS = IDAT(J)
  122     ISTAT(IS) = 1
        GOTO 500
C       ORDERED MULTISTATE WITH 'TO'.
  140   IB = IDAT(JB)
        IE = IDAT(JE)
        DO 142 IS = IB, IE
  142     ISTAT(IS) = 1
        GOTO 500
 
C--     NEW STATES.
  200   IS = 0
        NG = ISBND(IC)
        NSG = NG + 1
        NGN = NG + ISBND(NG)
        KFND1 = 0
        KFND2 = 0
        KNTV = 0
        NKS = 0
 
C       SCAN GROUPS OF NEW STATES.
  300   IF (NSG.GE.NGN)  GOTO 490
          IS = IS + 1
          ITS = ISBND(NSG+1)
          NB = NSG + 2
          NE = NSG + ISBND(NSG) - 1
          GOTO (320,340,340,380), JTYPC
C         UNORDERED MULTISTATE.
  320     DO 324 J = JB, JE
            DO 322 N = NB, NE
              IF (IDAT(J).EQ.ISBND(N))  GOTO 323
  322       CONTINUE
            GOTO 324
  323       ISTAT(IS) = 1
            NKS = NKS + 1
  324     CONTINUE
          IF (NKS.EQ.JE-JB+1)  THEN
            KFND1 = 1
            KFND2 = 1
          ENDIF
          GOTO 400
C         ORDERED MULTISTATE AND INTEGER NUMERIC.
  340     I1 = IDAT(JB)
          I2 = IDAT(JE)
          IR1 = ISBND(NB)
          IR2 = ISBND(NE)
          IF (ITS.EQ.3)  THEN
C           OPEN-ENDED RANGE.
            IF ((I1.LE.IR2.OR.IS.EQ.NS).AND.
     *       (IR1.LE.I2.OR.IS.EQ.1))  ISTAT(IS) = 1
            IF (IS.EQ.1)  THEN
              IF (I1.LE.IR2)  KFND1 = 1
              IF (I2.LE.IR2)  KFND2 = 1
            ENDIF
            IF (IS.EQ.NS)  THEN
              IF (I1.GE.IR1)  KFND1 = 1
              IF (I2.GE.IR1)  KFND2 = 1
            ENDIF
          ELSE
            IF ((I1.LE.IR2).AND.(IR1.LE.I2))  ISTAT(IS) = 1
            IF (I1.GE.IR1.AND.I1.LE.IR2)  KFND1 = 1
            IF (I2.GE.IR1.AND.I2.LE.IR2)  KFND2 = 1
          ENDIF
          GOTO 400
C         REAL NUMERIC.
  380     IF (IS.GT.1)  GOTO 390
          X1 = RELIN(IDAT(JB))
          X2 = RELIN(IDAT(JE))
          KNTV = KNTV + 1
          IF (JB.EQ.JE.AND.KNTV.EQ.1.AND.
     *        (PCTERR.NE.0.0.OR.ABSERR.NE.0.0))  THEN
            KSG = JSG + IDAT(JSG)
            DO WHILE (KSG.LT.JGN)
              IF (IDAT(KSG+1).NE.0)  GOTO 390
              KSG = KSG + IDAT(KSG)
            END DO
C           SINGLE VALUE CODED, SO APPLY ERROR FACTORS.
            IF (PCTERR.NE.0.)  THEN
              P1 = 1. + PCTERR/100.
              P2 = INT(1./(P1)*100.)/100.
              VAL = X1
              V1 = VAL * P1
              V2 = VAL * P2
              X1 = MIN(V1,V2)
              X2 = MAX(V1,V2)
            ENDIF
            IF (ABSERR.NE.0.)  THEN
              X1 = X1 - ABSERR
              X2 = X2 + ABSERR
            ENDIF
          ENDIF
  390     R1 = RELIN(ISBND(NB))
          R2 = RELIN(ISBND(NE))
          IF (ITS.EQ.3) THEN
C           OPEN-ENDED RANGE.
            IF ((X1.LE.R2.OR.IS.EQ.NS) .AND.
     *          (R1.LE.X2.OR.IS.EQ.1))  ISTAT(IS) = 1
            IF (IS.EQ.1)  THEN
              IF (X1.LE.R2)  KFND1 = 1
              IF (X2.LE.R2)  KFND2 = 1
            ENDIF
            IF (IS.EQ.NS)  THEN
              IF (X1.GE.R1)  KFND1 = 1
              IF (X2.GE.R1)  KFND2 = 1
            ENDIF
          ELSE
            IF (X1.LE.R2.AND.R1.LE.X2)  ISTAT(IS) = 1
            IF (X1.GE.R1.AND.X1.LE.R2)  KFND1 = 1
            IF (X2.GE.R1.AND.X2.LE.R2)  KFND2 = 1
          ENDIF
  400     NSG = NSG + ISBND(NSG)
          GOTO 300
C-
  490   IF (KFND1.EQ.0.OR.KFND2.EQ.0)  THEN
          IVAL(1) = IC
C          IVAL(2) = JI
          CALL MESSC (111, IVAL, 1, 2, 0, TNAME, LTNAME, 1)
        ENDIF
 
  500   JSG = JSG + IDAT(JSG)
        GOTO 50
C--
 1000 RETURN
      END
      SUBROUTINE NAMEP (ITM, LIDAT, ITYPMK, NC, JIM, IRAB, LUNTYP)          TRAN
 
C* REVISED 13-MAY-91.
C* OUTPUTS TAXON NAME.
 
C  ITM RECEIVES THE ITEM.
C  LIDAT RECEIVES THE LENGTH OF ITM.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  JIM RECEIVES THE ITEM NUMBER TO BE OUTPUT.
C  IRAB RECEIVES WHETHER COMMENTS ARE TO OUTPUT WITHOUT ANGLE BRACKETS.
C  LUNTYP RECEIVES THE TYPE OF LOGICAL UNIT.
 
      DIMENSION ITM(LIDAT),ITYPMK(LIDAT)
 
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
 
      PSEQ = 0.
      CALL ENDLN (LUNTYP)
      INDEN(LUNTYP) = 8
      CALL INDENT (0, LUNTYP)
      IF (ITPSET.GT.0)  CALL JSTTPS (23, ITYPMK, LIDAT, NTYPMK, LUNTYP)
      CALL JSTI (JIM, -1, LUNTYP)
      CALL JSTS (KSTOP, 0, LUNTYP)
      CALL WSENT (ITM(NC+2), LIDAT, 1+IRAB, 0, 0, 0, 1, ITYPMK, LIDAT,
     * LUNTYP)
      RETURN
      END
      SUBROUTINE PRTUNC (IDAT, IMC, ITYPC, LSTDEP, ICDES, LCDES,            TRAN
     * ICODED, ITYPMK, IA1S, ICSTR, IFIRST)
 
C  REVISED 25-OCT-00.
C  PRINTS A LIST OF UNCODED CHARACTERS.
 
C  JI RECEIVES THE ITEM NUMBER
C  IDAT RECEIVES THE ITEM.
C  IMC RECEIVES THE CHARACTER MASK.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  LSTDEP RECEIVES CHARACTERS WHICH HAVE HAD DEPENDENCIES ADDED.
C   (LSTDEP(IC)<0 INDICATES VARIABLE CONTROLLING CHARACTER.)
C  ICODED RECEIVES WORKING SPACE OF LENGTH NC.
C  IA1S RECEIVES WORKING SPACE OF LENGTH MS.
C  ITYPMK RECEIVES TYPESETTING MARKS.
C  ICSTR. IF THE CHARACTER DESCRIPTIONS ARE STORED IN MAIN MEMORY
C    (SEE SUBR. STOREC), ICSTR RECEIVES THESE DESCRIPTIONS.
C    IF NOT, ICSTR IS USED AS A BUFFER TO HOLD EACH CHARACTER
C    DESCRIPTION AS IT IS FETCHED BY A CALL TO FETCHC.
C    THE CODE IN THIS SUBR. (NATTI) IS INDEPENDENT OF THE METHOD OF
C    STORAGE OF THE DESCRIPTIONS.
C  IFIRST RECEIVES WHETHER THIS IS THE FIRST CALL TO THIS ROUTINE.
 
      COMMON /DIMXXX/ NC,MI,MS,LIDAT,LCSTR
      COMMON /CAPXXX/ KCAPMK,IOMCAP
      COMMON /INIXXX/ JI,JT,JIM,IVARIT,MASTIN,MISTOP
      COMMON /ITSXXX/ ITSS
      COMMON /JSTXXX/ IOUT(132,5),LOUT,ICAP,
     * JIOUT(5),IENDWD(5),INDEN(5),LWIDTH(5),PSEQ,SEQINC,NSQDIG
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /MISXXX/ IMPVAL,IPACH,IPCHN,IPUNC,IRAB,IKEYCH,ICMPRS,
     * ITUNC,ITINAP,ITIMPL,IUNVAR,LNKC,IDEPC,LICDEP,IPSUMM,ICHSEQ,
     * ITMSEQ,INSRVA,IFATT,ITINTR,ICMAND,IUNRNG,IOMTOR,NEWFLS,IRSEMI,
     * IOMSTC,IADDCH,IEMPCH,IVARUN,ISCALC,ICNOTE,ICIMGE,ITIMGE,MTIMGE,
     * NTIMGE,IOMNSC,IOMCMT,IOMLOW,IERRPC,IERRAB,ICHNSE,NUMST0,IUMEAN,
     * NADNAM,NEMNAM,NODELO,IOMUSP,ICKYIMG,ITKYIMG,ISUPIMG,ICTIMGE,
     * ICTNAME,IHTML,IRTF,MTHEAD,NTHEAD,ITMHDGS,LCDNAM,MTFILE,NTFILE,
     * ITMFILS,MXHEAD,NXHEAD,IDXHDGS,INSIMGFN,ICOFILE,IUCC,IOUNC,ITLINK,
     * MTLINK,NTLINK,NAUTOCC,IOUTSUBJ
      COMMON /SYMXXX/ KPOINT,KDASH,KSTAR,KVERT,KEQUAL,KCOMMA,KSEMIC,
     * KCOLON,KSTOP,KSOL,KLPAR,KRPAR,KDOLLA,KQUEST,KEXCL,KAT,KLBRACE,
     * KRBRACE
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
      COMMON /TRNXXX/ IPCHAR,IPITEM,IPNAME,ITRAN
 
      DIMENSION IDAT(LIDAT),IMC(NC),ITYPC(NC),LSTDEP(NC),ICDES(NC),
     * LCDES(NC),ICODED(NC),ITYPMK(LIDAT),IA1S(MS),ICSTR(LCSTR)
 
C-    FIND WHICH CHARACTERS ARE CODED.
      IUNC = 0
      DO 100 IC = 1, NC
        ICODED(IC) = 0
        NA = 0
        IF (IDAT(IC).LT.0)  GO TO 80
        IF (IDAT(IC).EQ.0)  GO TO 70
        JG = IDAT(IC)
        JSG = JG + 1
        L = IDAT(JG)
        IF (L.LE.1)  GO TO 80
   30   IF (JSG.GE.JG+IDAT(JG))  GO TO 80
          ITS = IDAT(JSG+1)
          IF (ITS.LT.0)  GO TO 50
          IF (ITYPC(IC).EQ.5)  GO TO 35
          IF (ITS.GT.0)  GO TO 40
            GO TO 50
   35     IF (ITS.EQ.0.OR.ITS.EQ.8)  GO TO 60
            GO TO 50
   40     IF (ITS-ITSS.EQ.3)  THEN
            NA = 1
            GOTO 50
          ENDIF
          IF (ITS-ITSS.NE.2)  GO TO 60
   50     JSG = JSG + IDAT(JSG)
          GO TO 30
   60   ICODED(IC) = 1
        GO TO 100
   70   IF (IVARIT.NE.0 .AND. MASTIN.NE.0)  ICODED(IC) = 1
   80   IF (ICODED(IC).EQ.0.AND.NA.NE.0.AND.LSTDEP(IC).GE.0)
     *   ICODED(IC) = 1
        IF (IMC(IC).NE.0 .AND. ICODED(IC).EQ.0)  IUNC = 1
  100   CONTINUE
C
      IF (IUNC.EQ.0)  GO TO 1000
 
      IF (ITPSET.LE.0)  THEN
        CALL BLKLIN (1, 1, 3)
      ELSE
        CALL ENDLN (3)
        CALL JSTTPS (24, ITYPMK, LIDAT, NTYPMK, 3)
      ENDIF
 
      IF (ITRAN.NE.4)  THEN
C       IF NOT NATURAL LANGUAGE TRANSLATION, OUTPUT TAXON NAME.
        IF (IVARIT.NE.0 .AND. MASTIN.NE.0) THEN
          ICAP = 1
          CALL JSTWD (7, -1, ITYPMK, LIDAT, 3)
        ENDIF
        JTYPMK = 14
        IF (IFIRST.EQ.0.AND.ITYPMK(51).NE.0)  JTYPMK = 51
        CALL WNAME (IDAT(NC+2), LIDAT, ITYPMK, LIDAT, 1+IRAB, ITPSET,
     *   -1, JTYPMK, 3)
        CALL ENDLN (3)
      ENDIF
 
C     START NEW PARAGRAPH.
      IF (ITPSET.GT.0)  THEN
        CALL JSTTPS (16, ITYPMK, LIDAT, NTYPMK, 3)
      ELSE
        IF (ICHNSE.NE.0)  THEN
C         NO INTERPARAGRAPH SPACING. INDENTATION = 4.
          I = 4
        ELSE
          I = 6
        ENDIF
        CALL INDENT (I, 3)
      ENDIF
 
      ICAP = 1
      CALL JSTWD (8, -1, ITYPMK, LIDAT, 3)
      CALL JSTS (KCOLON, 0, 3)
      IF (ITUNC.NE.0)  GO TO 200
C
C-    PRINT NUMBERS OF UNCODED ATTRIBUTES.
      IC = 1
C
C     FIND START AND END OF NEXT GROUP OF UNCODED ATTRIBUTES.
  130 CONTINUE
  140   IF (IMC(IC).NE.0 .AND. ICODED(IC).EQ.0)  GO TO 150
          IF (IC.GE.NC)  GO TO 1000
          IC = IC + 1
          GO TO 140
  150   IB = IC
        IE = IC
  160   IF (ICODED(IC).NE.0)  GO TO 170
          IF (IMC(IC).NE.0)  IE = IC
          IF (IC.GE.NC)  GO TO 170
          IC = IC + 1
          GO TO 160
C
C       PRINT NUMBERS.
  170   CALL JSTI (IB, -1, 3)
        IF (IE.LE.IB)  GO TO 180
        IF (ITPSET.GT.0)  CALL JSTTPS (1, ITYPMK, LIDAT, NTYPMK, 3)
        IF (ITPSET.LE.0)  CALL JSTS (KDASH, -1, 3)
        CALL JSTI (IE, -1, 3)
  180   CALL ENDWD (3)
C
        IF (IC.GE.NC)  GO TO 1000
        GO TO 130
C
C-    TRANSLATE FEATURES OF UNCODED ATTRIBUTES.
  200 IOMCAP = 1
      DO 220 IC = 1, NC
        IF (IMC(IC).EQ.0.OR.ICODED(IC).NE.0)  GO TO 220
        CALL JSTS (KLPAR, -1, 3)
        CALL JSTI (IC, -1, 3)
        CALL JSTS (KRPAR, 0, 3)
        CALL FETCHC (ICSTR, LCSTR, ICDES, LCDES, NC, IC, IAC, IA1S, MS)
        ICAP = 1
        CALL WSENT (ICSTR(IAC), LCSTR, 1, 0, 0, 0, -1, ITYPMK, LIDAT, 3)
        IF (IOUT(JIOUT(3),3).NE.KSTOP)  CALL JSTS (KSTOP, 0, 3)
  220   CONTINUE
      IOMCAP = 0
C--
 1000 CALL ENDLN (3)
      IF (ITPSET.LE.0.AND.LUNO.EQ.LUNL)  CALL BLKLIN (2, 0, 3)
 
      ICAP = 0
      RETURN
      END
      SUBROUTINE SETDEP (ITM, LIDAT, ICDEP, NSTAT, ITYPC, LSTDEP,           TRAN
     * ICHDEP, IPROCLST, NC, ICSTAT, ISTAT, MS, NEWITM)
 
C* REVISED 24-JUN-99.
C* SETS CHARACTER DEPENDENCIES IN AN ITEM.
 
C  23/2/98. UNCODED DEPENDENT CHARACTERS SHOULD BE LEFT UNALTERED
C    IF ANY OF THE CONTROLLING STATES ALLOWS THE CHARACTER TO BE APPLICABLE.
C  21/9/88. IF CONTROLLING CHARACTER IS VARIABLE OR INAPPLICABLE,
C    UNCODED DEPENDENT CHARACTERS SHOULD BE CODED INTERNALLY AS U/-.
C  18/8/87. IF CONTROLLING CHARACTER IS VARIABLE OR INAPPLICABLE,
C    ALL CHARACTERS DEPENDENT ON ANY STATE ARE ALSO INAPPLICABLE.
 
C  ITM RECEIVES THE ITEM.
C  LIDAT RECEIVES THE LENGTH OF ITM.
C  ICDEP RECEIVES THE CHARACTER DEPENDENCIES.(SEE RDCDEP FOR FORMAT).
C  NSTAT RECEIVES THE NUMBER OF STATES.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  LSTDEP RETURNS CHARACTERS HAVE HAD DEPENDENCIES ADDED (USED IN
C   PRTUNC).
C  ICHDEP RECEIVES WORKING SPACE OF LENGTH NC.
C  IPROCLST RECEIVES AND RETURNS THE LIST OF CHARACTERS TO BE PROCESSED.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  ICSTAT RECEIVES WORKING SPACE OF LENGTH MS.
C  ISTAT RECEIVES WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C  NEWITM RECEIVES WHETHER TO UPDATE THE ITEM, 0=NO, 1=YES.
 
      DIMENSION NSTAT(NC),ITYPC(NC),LSTDEP(NC),IPROCLST(NC),ITM(LIDAT),
     * ICDEP(LIDAT),ICHDEP(NC),ICSTAT(MS),ISTAT(MS),ITSF(3)
 
C     Flag all characters for processing.
      CALL SETIA (IPROCLST, NC, 1)
      CALL SETIA (LSTDEP, NC, 0)
 
   10 CALL SETDEP1 (ITM, LIDAT, ICDEP, NSTAT, ITYPC, LSTDEP,
     * ICHDEP, IPROCLST, NC, ICSTAT, ISTAT, MS, NEWITM)
      IF (NONZER(IPROCLST, NC).NE.0)  GOTO 10

      RETURN
      END
      SUBROUTINE SETDEP1 (ITM, LIDAT, ICDEP, NSTAT, ITYPC, LSTDEP,          TRAN
     * ICHDEP, IPROCLST, NC, ICSTAT, ISTAT, MS, NEWITM)
 
C* REVISED 24-JUN-99.
C* SETS CHARACTER DEPENDENCIES IN AN ITEM.
 
C  23/2/98. UNCODED DEPENDENT CHARACTERS SHOULD BE LEFT UNALTERED
C    IF ANY OF THE CONTROLLING STATES ALLOWS THE CHARACTER TO BE APPLICABLE.
C  21/9/88. IF CONTROLLING CHARACTER IS VARIABLE OR INAPPLICABLE,
C    UNCODED DEPENDENT CHARACTERS SHOULD BE CODED INTERNALLY AS U/-.
C  18/8/87. IF CONTROLLING CHARACTER IS VARIABLE OR INAPPLICABLE,
C    ALL CHARACTERS DEPENDENT ON ANY STATE ARE ALSO INAPPLICABLE.
 
C  ITM RECEIVES THE ITEM.
C  LIDAT RECEIVES THE LENGTH OF ITM.
C  ICDEP RECEIVES THE CHARACTER DEPENDENCIES.(SEE RDCDEP FOR FORMAT).
C  NSTAT RECEIVES THE NUMBER OF STATES.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  LSTDEP RETURNS CHARACTERS HAVE HAD DEPENDENCIES ADDED (USED IN
C   PRTUNC).
C  ICHDEP RECEIVES WORKING SPACE OF LENGTH NC.
C  IPROCLST RECEIVES AND RETURNS THE LIST OF CHARACTERS TO BE PROCESSED.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  ICSTAT RECEIVES WORKING SPACE OF LENGTH MS.
C  ISTAT RECEIVES WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C  NEWITM RECEIVES WHETHER TO UPDATE THE ITEM, 0=NO, 1=YES.
 
      COMMON /ITSXXX/ ITSS
 
      DIMENSION NSTAT(NC),ITYPC(NC),LSTDEP(NC),IPROCLST(NC),ITM(LIDAT),
     * ICDEP(LIDAT),ICHDEP(NC),ICSTAT(MS),ISTAT(MS),ITSF(3)
 
C     CURRENT LENGTH OF ITM.
      JITM = NC + ITM(NC+1)
 
      DO 1000 IC = 1, NC
        IF (IPROCLST(IC).EQ.0)  GOTO 1000
        IPROCLST(IC) = 0
        IF (ICDEP(IC).EQ.0)  GOTO 1000
        IF (ITM(IC).EQ.0)  GOTO 1000
          ICDPTR = ICDEP(IC)
          CALL FINDST (ITM, IC, LIDAT, ITYPC, NSTAT, NC,
     *      ISTAT, MS, ITSF)
          NS = NSTAT(IC)
C         CONTROLLING CHARACTER VARIABLE OR INAPPLICABLE -
C          SET ALL POSSIBLE DEPENDENCIES.
          ISET = 1
          IF (ITSF(1).NE.0)  ISET = -1
          NONZ = NONZER(ISTAT,NS)
          IF (NONZ.EQ.0.AND.(ITSF(1).NE.0.OR.ITSF(3).NE.0))
     *      CALL SETIA (ISTAT, NS, 1)
          CALL COPIA (ICDEP(ICDPTR), ICSTAT, NS)
 
          DO 500 IS = 1, NS
            IF (ICSTAT(IS).EQ.0)  GOTO 500
            IF (ISTAT(IS).EQ.0)  GOTO 500
            ICNTRL = ICSTAT(IS)
            NR = ICDEP(ICNTRL)
 
C           CONTROLLING STATE PRESENT, SET DEPENDENCIES.
            DO 250 IR = 1, NR
              IB = ICDEP(ICNTRL+2*IR-1)
              IE = ICDEP(ICNTRL+2*IR)
              DO 200 KC = IB, IE
                JGI = JITM + 1
                IF (ITM(KC).EQ.0)  GOTO 100
 
C               CHECK IF CODED AS U.
                JG = ITM(KC)
                L = ITM(JG)
                JGN = JG + L
                JSG = JG + 1
   10           IF (JSG.GE.JGN)  GOTO 175
                IF (ITM(JSG+1).EQ.ITSS+2) GOTO 100
                JSG = JSG + ITM(JSG)
                GOTO 10

  100           L = 1
                JITM = JGI
 
C               DEPENDENT CHARACTER UNCODED.
C               IF CONTROLLING CHARACTER IS STRAIGHT INAPPLICABLE, MAKE THIS 
C               CHARACTER INAPPLICABLE.
                IF (NONZ.EQ.0.AND.ITSF(3).NE.0)  GOTO 185
 
C               CHECK IF ALL CODED STATES CONTROL THIS CHARACTER.
                ICHDEP(KC) = 0
                KNT = 0
                DO 110 JS = 1, NS
                  IF (ISTAT(JS).NE.0) THEN
                    KNT = KNT + 1
                    CALL GETDEP (ICDEP, LIDAT, IC, JS, ICHDEP, NC, KNT)
                    IF (ICHDEP(KC).NE.KNT)  GOTO 170
                  ENDIF
  110           CONTINUE
                IF (ICHDEP(KC).EQ.KNT)  GOTO 185
 
C               IF NOT, LEAVE UNALTERED. (23-FEB-98. Changed from U/-)
  170           GOTO 200
C                IF (NEWITM.NE.0)  THEN
C                  L = 3
C                  IF (JITM+2.GT.LIDAT)  GOTO 1100
C                  ITM(JITM+1) = 2
C                  ITM(JITM+2) = ITSS + 2
C                  JITM = JITM + 2
C                ENDIF
C                GOTO 185
 
C               CHECK IF ALREADY CODED AS N/A.
  175           JG = ITM(KC)
                L = ITM(JG)
                JGN = JG + L
                JSG = JG + 1
  180           IF (JSG.GE.JGN)  GOTO 182
                IF (ITM(JSG+1).EQ.ITSS+3) GOTO 200
                  JSG = JSG + ITM(JSG)
                  GOTO 180
 
  182           IF (NEWITM.NE.0)  THEN
                  IF (JITM+L.GT.LIDAT)  GOTO 1100
                  CALL COPIA (ITM(JG), ITM(JGI), L)
                  JITM = JITM + L
                ENDIF
 
  185           IF (NEWITM.NE.0)  THEN
                  ITM(KC) = JGI
                  ITM(JGI) = L + 2
                  IF (JITM+2.GT.LIDAT)  GOTO 1100
                  ITM(JITM+1) = 2
                  ITM(JITM+2) = ITSS + 3
                  JITM = JITM + 2
C                 If KC is before IC, it will not be processed again this time.
C                 Flag for reprocessing if it is a controlling character.
                ENDIF
                IF (LSTDEP(KC).LE.0)  LSTDEP(KC) = ISET
                IF (KC.LT.IC.AND.ICDEP(KC).NE.0)  IPROCLST(KC) = 1
  200           CONTINUE
 
  250          CONTINUE
 
C            TO AVOID DUPLICATION, CLEAR STATES WHICH CONTROL SAME CHARACTERS.
             DO 300 JS = 1, NS
               IF (ICSTAT(JS).EQ.ICNTRL)  ICSTAT(JS) = 0
  300          CONTINUE
 
  500        CONTINUE
 
 1000     CONTINUE
 
      IF (NEWITM.NE.0)  ITM(NC+1) = JITM - NC
      RETURN
 
 1100 CALL MESSB (35, LIDAT, 1, -1, 0)
 
      END
      SUBROUTINE TRANCH (ITYPC, IMC, NSTAT, KSTAT, NEWOR, SCALF, IALTC,     TRAN
     * ICDES, LCDES, MM1C, MM2C, NC, MM1S, MS, ICHHD, ISBND,
     * IVCON, ICNOT, NOTGRP, IFMT, ITYPMK, ICIMG, ICIMGP, ICDNAM, IFNT,
     * ITSHD, IDAT, LIDAT, ICSTR, LCSTR)
 
C* REVISED 1-SEP-99.
C* TRANSLATES OR PRINTS CHARACTER DESCRIPTIONS.
 
C  SEE MAIN PROGRAM FOR MEANINGS OF PARAMETERS.
 
      DIMENSION ITYPC(NC),IMC(NC),NSTAT(NC),KSTAT(NC),NEWOR(NC),
     * SCALF(NC),IALTC(NC),ICDES(NC),LCDES(NC),MM1C(NC),MM2C(NC),
     * MM1S(MS),ICHHD(LIDAT),ISBND(LIDAT),IVCON(LIDAT),
     * ICNOT(NC),NOTGRP(NC),IFMT(LIDAT),ICIMG(NC),ICIMGP(NC),
     * ICDNAM(LCDNAM),IFNT(LIDAT),ITSHD(LIDAT),IDAT(LIDAT),ICSTR(LCSTR)
 
      COMMON /CAPXXX/ KCAPMK,IOMCAP
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
      COMMON /MISXXX/ IMPVAL,IPACH,IPCHN,IPUNC,IRAB,IKEYCH,ICMPRS,
     * ITUNC,ITINAP,ITIMPL,IUNVAR,LNKC,IDEPC,LICDEP,IPSUMM,ICHSEQ,
     * ITMSEQ,INSRVA,IFATT,ITINTR,ICMAND,IUNRNG,IOMTOR,NEWFLS,IRSEMI,
     * IOMSTC,IADDCH,IEMPCH,IVARUN,ISCALC,ICNOTE,ICIMGE,ITIMGE,MTIMGE,
     * NTIMGE,IOMNSC,IOMCMT,IOMLOW,IERRPC,IERRAB,ICHNSE,NUMST0,IUMEAN,
     * NADNAM,NEMNAM,NODELO,IOMUSP,ICKYIMG,ITKYIMG,ISUPIMG,ICTIMGE,
     * ICTNAME,IHTML,IRTF,MTHEAD,NTHEAD,ITMHDGS,LCDNAM,MTFILE,NTFILE,
     * ITMFILS,MXHEAD,NXHEAD,IDXHDGS,INSIMGFN,ICOFILE,IUCC,IOUNC,ITLINK,
     * MTLINK,NTLINK,NAUTOCC,IOUTSUBJ
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
      COMMON /TRNXXX/ IPCHAR,IPITEM,IPNAME,ITRAN
 
      IF (ITRAN.LE.0)  GOTO 2000
 
C--   TRANSLATE CHARACTER DESCRIPTIONS.
      GOTO (100,2000,300,2000,500,600,700,800,900,2000,2000), ITRAN          =*
 
C     KEY FORMAT.
  100 CALL CHECKO (LUNDA, 'KEY OUTPUT')
      IOMCAP = 1
      CALL KEYTC (ITYPC, NSTAT, KSTAT, IALTC, ICDES, LCDES, MM1C, NC,
     * IKEYCH, MM1S, MS, ISBND, IDAT, LIDAT, ICSTR, LCSTR)
      IOMCAP = 0
      GOTO 2000
 
C     DELTA FORMAT.
  300 CALL CHECKO (LUNP, 'OUTPUT')
      IOMCAP = 0
      CALL DELTC (ITYPC, IMC, NSTAT, KSTAT, NEWOR, ICDES, LCDES, SCALF,
     * IALTC, ICNOT, NOTGRP, NC, IKEYCH, 0, ICHSEQ, MM1S, MS, ISBND,
     * ICHHD, IFMT, ITYPMK, IDAT, LIDAT, ICSTR, LCSTR, 0, IOMSTC,
     * ISCALC, 0, 0, 1, NUMST0, 4, ITRAN, 0, 0)
      IF  (NONZER(IMC,NC).NE.NC)  CALL MESSA (112, 2, 0)
      IF  (ITPSET.LT.0)  CALL MESSA (113, 2, 0)
      GOTO 2000
 
C     ALICE FORMAT.
  500 CALL CHECKO (LUNP, 'OUTPUT')
      IOMCAP = 1
      CALL ALICTC (ITYPC, NSTAT, KSTAT, IMC, IALTC, ICDES, LCDES, NC,
     * IKEYCH, MM1S, MS, ISBND, LIDAT, ICSTR, LCSTR)
      IOMCAP = 0
      GOTO 2000

C     NEXUS FORMAT.
  600 IOMCAP = 1
      CALL NEXTC (ITYPC, NSTAT, KSTAT, IMC, IALTC, ICDES, LCDES, NC,
     * IKEYCH, MM1S, MS, ISBND, LIDAT, ICSTR, LCSTR)
      IOMCAP = 0
      GOTO 2000
 
C     EXIR FORMAT.
  700 CALL CHECKO (LUNP, 'OUTPUT')
      IOMCAP = 1
      CALL EXITC (ITYPC, IMC, NSTAT, ICDES, LCDES, NC, MM1S, MS,
     * IVCON, ITYPMK, LIDAT, ICSTR, LCSTR)
      IOMCAP = 0
      GOTO 2000
 
C     PAYNE FORMAT.
  800 IOMCAP = 1
      CALL PAYTC (ITYPC, NSTAT, KSTAT, IALTC, ICDES, LCDES, NC,
     * IKEYCH, MM1S, MS, ISBND, ITYPMK, LIDAT, ICSTR, LCSTR)
      IOMCAP = 0
      GOTO 2000
 
C     INTKEY FORMAT.
  900 CALL CHECKO (LUNDA, 'INTKEY OUTPUT')
      IOMCAP = 1
      CALL INTTC (ITYPC, NSTAT, KSTAT, IMC, IALTC, ICDES, LCDES, ICNOT,
     * NOTGRP, ICIMG, ICIMGP, MM1C, MM2C, NC,
     * ICNOTE, ICIMGE, IKEYCH, ISUPIMG, ICKYIMG, ITKYIMG, IOMNSC,
     * ICDNAM, LCDNAM, IFNT,
     * MM1S, MS, ISBND, IFMT, ITSHD, IDAT, LIDAT, ICSTR, LCSTR)
      IOMCAP = 0
 
C--   PRINT CHARACTER DESCRIPTIONS.
C--   (NOTE. JPACH AND JRECH MUST BE CONSISTENT WITH SUBR. TRANIT.)           =/
 2000 IF (IPCHAR.EQ.0)  GOTO 4000
 
C-    SET PARAMETER VALUES FOR PRINTING.
      IF (ITRAN.EQ.0)  GOTO 2100
      IKEYST = 0
      GOTO (2100,2500,2300,2100,2500,2500,2500,2200,2500,2200,2500),
     * ITRAN                                                                  =*
 
C     0.CHECK, 1.KEY FORMAT, 4.NATURAL LANGUAGE.
 2100 JPACH = IPACH
      JRECH = 0
      IPOLD = 0
      IF (ITRAN.EQ.1)  IKEYST = 1  
      GOTO 3000
 
C     8.PAYNE AND 10.DIST.
 2200 JPACH = 0
      JRECH = 1
      IPOLD = 0
      IF (ITRAN.EQ.8)  IKEYST = 1
      GOTO 3000
 
C     3.DELTA FORMAT.
 2300 JPACH = 0
      JRECH = 1
      IPOLD = 0
      GOTO 3000
 
C     2.HENNIG, 5.ALICE, 6.NEXUS, 7.EXIR, 9.INTKEY AND
C     11.PAUP FORMAT.
 2500 JPACH = 0
      JRECH = 1
      IPOLD = 1
      IF (ITRAN.EQ.2.OR.ITRAN.EQ.6.OR.ITRAN.EQ.11)  IKEYST = 1
 
C-    PRINT DESCRIPTIONS.
C 3000 IF (ISBIN.EQ.0)  THEN
C        CALL CHECKO (LUNO, 'PRINT')
C        LUNTYP = 3
C      ELSE
C        CALL CHECKO (LUNBO, 'WP PRINT')
C        LUNTYP = 6
C      ENDIF
 3000 CALL CHECKO (LUNO, 'PRINT')
C     OUTPUT TYPSET MARK (FROM MARKTPS) AT BEGINNING OF FILE.
      IF (ITPSET.GT.0.AND.IFBEGIN.EQ.0) THEN
        CALL JSTTPS (28, ITYPMK, LIDAT, NTYPMK, 3)
        IFBEGIN = 1
        IFEND = 0
      ENDIF
      LUNTYP = 3
      IOMCAP = 1
      IHTMBKT = 0
C     In HTML output, replace angle brackets with HTML equivalents.
      IF (IHTML.NE.0) IHTMBKT = 1
      CALL DELTC (ITYPC, IMC, NSTAT, KSTAT, NEWOR, ICDES, LCDES,
     * SCALF, IALTC, ICNOT, NOTGRP, NC, IKEYCH, IKEYST, ICHSEQ, MM1S,
     * MS, ISBND, ICHHD, IFMT, ITYPMK, IDAT, LIDAT, ICSTR, LCSTR,
     * IPOLD, IOMSTC, ISCALC, ICNOTE, JPACH, JRECH, NUMST0, LUNTYP,
     * ITRAN, IOMNSC, IHTMBKT)
C     ADD TERMINATING TYPSETTING MARKS TO PRINT FILE.
      IF (ITPSET.GT.0.AND.IFBEGIN.NE.0.AND.IFEND.EQ.0) THEN
        CALL JSTTPS (40, ITYPMK, LIDAT, NTYPMK, LUNTYP)
        CALL JSTTPS (29, ITYPMK, LIDAT, NTYPMK, LUNTYP)
        CALL ENDLN (LUNTYP)
        IFEND = 1
      ENDIF

C--
 4000 RETURN
      END
      SUBROUTINE TRANIT (W, IW, LW, ITM, IDAM, IDAT,                        TRAN
C    * MM1I, WW2I,
     * ITYPC, IMC, WTC, NSTAT, KSTAT, NORNG, IOMORC,
C    * WW1C, MM1C, MM2C,
     * NDEC, ICDES, LCDES, IPARA, IEMPF, LINKC, IMPFLG, ITMADD,
     * ISRTS, INTRL, IREPS, IOMPD, IALTC, IOMFC, IOMLO,
C    * MM1S, MM2S,
     * ITSHD, ISUMM,
     * ISBND, IVCON, ICDEP, LSTDEP, ICSTR, IMI, WTI, IFILS,
     * IADDT, IADDC, IEMPT, IEMPC, ICPTW, ICPTB, PCERR, ABERR,
     * MINC, MAXC, NUMRNG, ITIMG, ITIMGP, NAFLG,
     * LFLG, ITPTR, LNAME, NBND, RBND, ITXPT, ITYPMK)
 
C* REVISED 28-JUN-00.
C* TRANSLATES OR PRINTS ITEM.
 
C  17/10/88. ADD 'NEWITM' TO PARAMETER LIST FOR SETDEP.
C  19/9/88. ALTER PARAMETER LIST FOR SETDEP.
C  18/7/88. DIAGNOSTIC DESCRIPTIONS.
C  7/4/88. REPLACE SEMICOLON BY COMMA DIRECTIVE IMPLEMENTED.
C  2/2/88. PRINT UNCODED CHARACTERS DIRECTIVE IMPLEMENTED.
C  31/12/87. OMIT "OR" FOR CHARACTERS DIRECTIVE IMPLEMENTED.
C  22/12/87. USE NORMAL RANGE DIRECTIVE IMPLEMENTED.
C  15/12/87. TRANSLATION INTO INTKEY FORMAT - REVISED FORMAT OF
C   OUTPUT FILES.
C  12/3/87. TRANSLATION INTO PAUP FORMAT.
C  22/1/87. TRANSLATION FOR DISTANCE MATRIX.
C  24/11/86. NEW HANDLING OF ITEMS WITH REGARD TO IMPLICIT VALUES AND
C    DEPENDENCIES.
 
C  SEE MAIN PROGRAM FOR MEANINGS OF PARAMETERS.
 
C  NOTE ON WORKING ARRAYS.
 
      COMMON /ADRXXX/ IITYPC,IIMC,IIMI,IWTC,IWTI,INSTAT,IKSTAT,
     * INEWOR,INDEC,IICDES,ILCDES,IITMAD,IWW1C,IWW2C,IWW1I,IWW2I,
     * IWW1S,IWW2S,IIDAT,IIDAM,IIDAV,IIPARA,IIEMPF,ILINKC,IICHHD,
     * IITSHD,IISBND,IIVCON,IICDEP,ILSTDE,INEWFL,IIMPL1,IIMPL2,
     * IIMPFL,IISUMM,IICPTW,IICPTB,IITPTR,ILNAME,IINTRL,IMANDC,IRBND,
     * INBND,IITXPT,INORNG,IIOMOR,IIFILS,IIREPS,IIADDT,IIADDC,IIEMPT,
     * IIEMPC,IMINC,IMAXC,INUMRN,INAFLG,ISCALF,IISRTS,IICNOT,IICNGP,
     * IITYMK,IIFMT,IIOMPD,IIOMLO,IICIMG,IICIGP,IITIMG,IITREC,IPCERR,
     * IABERR,IIOMFC,IIALTC,IIADNM,IIADDL,IIEMNM,IIEMPL,IIOUSP,IICSYN,
     * IILANG,IICSTR,IITHD,IITHREC,IICDNAM,IITFIL,IITFREC,IIXHD,IIXHREC,
     * IIFNT,IIUSECC,IIFOFSET,IITLNK,IILREC,IITLNK2,IINAUTOCC,IIOSUBJ,
     * ILAST
      COMMON /DIMXXX/ NC,MI,MS,LIDAT,LCSTR
      COMMON /INIXXX/ JI,JT,JIM,IVARIT,MASTIN,MISTOP
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
      COMMON /MISXXX/ IMPVAL,IPACH,IPCHN,IPUNC,IRAB,IKEYCH,ICMPRS,
     * ITUNC,ITINAP,ITIMPL,IUNVAR,LNKC,IDEPC,LICDEP,IPSUMM,ICHSEQ,
     * ITMSEQ,INSRVA,IFATT,ITINTR,ICMAND,IUNRNG,IOMTOR,NEWFLS,IRSEMI,
     * IOMSTC,IADDCH,IEMPCH,IVARUN,ISCALC,ICNOTE,ICIMGE,ITIMGE,MTIMGE,
     * NTIMGE,IOMNSC,IOMCMT,IOMLOW,IERRPC,IERRAB,ICHNSE,NUMST0,IUMEAN,
     * NADNAM,NEMNAM,NODELO,IOMUSP,ICKYIMG,ITKYIMG,ISUPIMG,ICTIMGE,
     * ICTNAME,IHTML,IRTF,MTHEAD,NTHEAD,ITMHDGS,LCDNAM,MTFILE,NTFILE,
     * ITMFILS,MXHEAD,NXHEAD,IDXHDGS,INSIMGFN,ICOFILE,IUCC,IOUNC,ITLINK,
     * MTLINK,NTLINK,NAUTOCC,IOUTSUBJ
      COMMON /TPSXXX/ ITPSET,NTYPMK,IFBEGIN,IFEND
      COMMON /TRNXXX/ IPCHAR,IPITEM,IPNAME,ITRAN
 
      DIMENSION W(LW),IW(LW),ITM(LIDAT),IDAM(LIDAT),IDAT(LIDAT),
C    * MM1I(MI),WW2I(MI),
     * ITYPC(NC),
     * IMC(NC),WTC(NC),NSTAT(NC),KSTAT(NC),NORNG(NC),IOMORC(NC),
C    * WW1C(NC),MM1C(NC),MM2C(NC),
     * NDEC(NC),ICDES(NC),LCDES(NC),IPARA(NC),IEMPF(NC),
     * LINKC(NC),IMPFLG(NC),ITMADD(NC),ISRTS(NC),INTRL(NC),IREPS(NC),
     * IOMPD(NC),IALTC(NC),IOMLO(NC),
C    * MM1S(MS),MM2S(MS),
     * ITSHD(LIDAT),ISUMM(LIDAT), ISBND(LIDAT),IVCON(LIDAT),
     * ICDEP(LIDAT),LSTDEP(NC),ICSTR(LCSTR),IMI(MI),
     * WTI(MI),IFILS(MI),IADDT(MI),IADDC(NC),IEMPT(MI),IEMPC(NC),
     * ICPTW(NC),ICPTB(NC),PCERR(NC),ABERR(NC),MINC(NC),MAXC(NC),
     * NUMRNG(NC),ITIMG(MI),ITIMGP(MI),
     * ITPTR(MI),LNAME(MI),NBND(NC),RBND(MI*2),ITXPT(MI+1),ITYPMK(LIDAT)
 
      SAVE IFIRSTUNC
 
      IF (JI.EQ.1) IFIRSTUNC = 1
 
      IF (IVARIT.LT.0)  GOTO 90
      IF (IMI(JI).EQ.0)  GOTO 90
 
C--   PRINT TAXON NAME.
   40 IF (IPNAME.EQ.0.OR.IPITEM.NE.0)  GOTO 50
      CALL CHECKO (LUNO, 'PRINT')
C     OUTPUT TYPSET MARK (FROM MARKTPS) AT BEGINNING OF FILE.
      IF (ITPSET.GT.0.AND.IFBEGIN.EQ.0) THEN
        CALL JSTTPS (28, ITYPMK, LIDAT, NTYPMK, 3)
        IFBEGIN = 1
        IFEND = 0
      ENDIF
      I = JIM
      CALL NAMEP (ITM, LIDAT, ITYPMK, NC, I, IRAB, 3)
      GOTO 90
 
C--   PRINT ITEM DESCRIPTIONS.
C--   (NOTE. JPACH AND JRECH MUST BE CONSISTENT WITH SUBR. TRANCH.)           =/
   50 IF (IPITEM.EQ.0)  GOTO 90
      CALL CHECKO (LUNO, 'PRINT')
C     OUTPUT TYPSET MARK (FROM MARKTPS) AT BEGINNING OF FILE.
      IF (ITPSET.GT.0.AND.IFBEGIN.EQ.0) THEN
        CALL JSTTPS (28, ITYPMK, LIDAT, NTYPMK, 3)
        IFBEGIN = 1
        IFEND = 0
      ENDIF
      IF (ITRAN.EQ.0.OR.ITRAN.EQ.1.OR.ITRAN.EQ.4.OR.ITRAN.EQ.8.OR.
     *    ITRAN.EQ.10) THEN
C       CHECK, KEY FORMAT, NATURAL LANGUAGE, PAYNE AND DIST FORMAT.
        JPACH = IPACH
        JRECH = 0
      ELSE
C       OTHERS.
        JPACH = 0
        JRECH = 1
      ENDIF
 
      CALL DELTI (ITM, IDAM, IDAT, LIDAT,
     * ITYPC, IMC, NDEC, IMPFLG, ITMADD, ISRTS, IW(IWW1C), IW(IWW2C),
     * NC, ITYPMK, IMI, JI, 0, IVARIT, MASTIN, ITRAN, 1, JPACH, JRECH,
     * ITIMPL, ICMPRS, ITMSEQ, INSRVA, IOMSTC, IOUNC, 3, NSTAT, IDEPC,
     * ICDEP, IW(IWW1S), IW(IWW2S), MS)
 
C--   TRANSLATE.
   90 IF (ITRAN.EQ.0)  GOTO 2000
      IF (IVARIT.LT.0)  GOTO 95
 
      IMPLNAM = IMPNAM (ITM(NC+2), LIDAT)
C     An Implicit_Attributes item is only output for DELTA and
C     natural-language formats.
      IF (IMPLNAM.NE.0)  THEN
        IF (ITRAN.NE.3.AND.ITRAN.NE.4)  GOTO 2000
        GOTO 95
      ENDIF
 
C--   FILL IN DEPENDENCIES.
      ISETDP = 0
      IF (IDEPC.EQ.0.OR.ITRAN.EQ.1.OR.ITRAN.EQ.3)  GOTO 95
      IF (IVARIT.NE.0.AND.ITRAN.EQ.4.AND.MASTIN.NE.0)  GOTO 95
      CALL SETDEP (ITM, LIDAT, ICDEP, NSTAT, ITYPC, LSTDEP,
     * IW(IWW1C), IW(IWW2C), NC, IW(IWW1S), IW(IWW2S), MS, 1)
      ISETDP = 1

   95 GOTO (100,200,300,400,500,600,700,800,900,1000,1100), ITRAN        =*
 
C     KEY FORMAT.
  100 CALL CHECKO (LUNDA, 'KEY OUTPUT')
      CALL KEYTI (ITM, IDAT, LIDAT, IW(IWW1I), W(IWW2I), MI,
     * ITYPC, IMC, NSTAT, KSTAT, NORNG, PCERR, ABERR, WTC, W(IWW1C), NC,
     * IW(IWW1S), MS, ICDEP, LICDEP, ISBND, IMI, WTI, JI, IUNRNG,
     * IERRPC, IERRAB, IVARIT, ICTNAME)
      GOTO 2000
 
C     HENNIG FORMAT.
  200 CALL HENNTI (ITM, ISBND, LIDAT, ITYPC, IMC, NSTAT, KSTAT, WTC,
     * IW(IWW1C), NC, IW(IWW1S), MS, IMI, JI, IVARIT)
      GOTO 2000

C     DELTA FORMAT.
  300 CALL CHECKO (LUNP, 'OUTPUT')
      CALL DELTI (ITM, IDAM, IDAT, LIDAT,
     * ITYPC, IMC, NDEC, IMPFLG, ITMADD, ISRTS, IW(IWW1C), IW(IWW2C),
     * NC, ITYPMK,
     * IMI, JI, JIM, IVARIT, MASTIN, ITRAN, 0, 0, 1,
     * ITIMPL, ICMPRS, ITMSEQ, INSRVA, IOMSTC, IOUNC, 4, NSTAT, IDEPC,
     * ICDEP, IW(IWW1S), IW(IWW2S), MS)
      GOTO 2000
 
C     NATURAL LANGUAGE.
  400 CALL CHECKO (LUNO, 'PRINT')
      CALL NATTI (ITM, IDAM, IDAT, ITYPC, IMC, NSTAT, NDEC,
     * ICDES, LCDES, IPARA, IEMPF, LINKC, IOMORC, IREPS, IOMPD,
     * IALTC, IOMFC, IOMLO, IW(IIOUSP),
     * IW(IWW1S), IMI, IFILS, ITSHD, ICSTR, IMPFLG, ITMADD, IADDT,
     * IADDC, IEMPT, IEMPC, ITYPMK, IW(IILANG), IW(IITHREC),
     * IW(IITFREC), IW(IIXHREC), IW(IIFOFSET), 3)
C     * IADDC, IEMPT, IEMPC, ITYPMK, LUNTYP)
      GOTO 2000
 
C     ALICE FORMAT.
  500 CALL ALICTI (ITM, IMI, MI, JI, JIM,
     * ITYPC, NSTAT, KSTAT, IMC, IALTC, IW(IWW1C), NC, ICDES, LCDES,
     * IW(IWW1S), IW(IWW2S), MS, ISBND, LIDAT, ICSTR, LCSTR, IC)
      GOTO 2000
 
C     NEXUS FORMAT.
  600 CALL NEXTI (ITM, ISBND, LIDAT, ITYPC, IMC, KSTAT,
     * IW(IWW1C), NC, IW(IWW1S), MS, IMI, JI)
      GOTO 2000
 
C     EXIR FORMAT.
  700 CALL CHECKO (LUNP, 'OUTPUT')
      CALL EXITI (ITM, ITYPMK, LIDAT, ITYPC, NSTAT, IMC, NORNG, NC,
     * IW(IWW1S), MS, IVCON, IMI, JI, IUNRNG)
      GOTO 2000
 
C     PAYNE FORMAT.
  800 CALL PAYTI (ITM, LIDAT, ITYPC, KSTAT, NORNG, NC, IUNRNG,
     * IW(IWW1S), MS, ISBND, IMI, JI)
      GOTO 2000
 
C     INTKEY FORMAT.
  900 CALL CHECKO (LUNDA, 'INTKEY OUTPUT')
      CALL INTTI (ITM, IDAT, LIDAT, ITPTR, LNAME, IW(IWW1I), MI,
     * ITYPC, IMC, NSTAT, KSTAT, NORNG, WTC, ICPTW, ICPTB, INTRL,
     * PCERR, ABERR,
     * MINC, MAXC, IW(IICSYN), IOMORC, NUMRNG, IW(IIUSECC),
     * IW(IINAUTOCC), IW(IIOMPD), IW(IIPARA),
     * W(IWW1C), IW(IWW1C), IW(IWW2C),
     * ITIMG, IW(IILREC), ITIMGP, IW(IWW1I), IW(IWW2I),
     * NBND, NC, RBND, ITXPT, IW(IWW1S), MS, ICDEP, LICDEP,
     * ISBND, IMI, JI, JIM, NAFLG, LFLG, ITINTR, IUNRNG, IVARIT,
     * ITIMGE, ITLINK, IERRPC, IERRAB, NODELO, ICHNSE, IOMNSC, IOMTOR,
     * IUCC, NAUTOCC, IOUTSUBJ, IW(IILANG),
     * IW(IITFREC), IW(IITLNK2), IW(IIOSUBJ))
      GOTO 2000
 
C     DIST FORMAT.
 1000 CALL CHECKO (LUNDA, 'DIST OUTPUT')
      CALL DISTI (ITM, IDAT, LIDAT, ITPTR, LNAME, MI, ITYPC, IMC,
     * KSTAT, WTC, PCERR, ABERR, ICPTW, ICPTB, IW(IWW1C), NC,
     * IW(IWW1S), MS, ISBND, IMI, JI, IERRPC, IERRAB, IVARIT, ICTNAME)
      GOTO 2000
 
C     PAUP FORMAT.
 1100 CALL PAUPTI (ITM, ISBND, LIDAT, ITYPC, IMC, NSTAT, KSTAT,
     * IW(IWW1C), NC, IW(IWW1S), MS, IMI, JI)
      GOTO 2000
 
C--   PRINT UNCODED CHARACTERS.
 2000 IF (IMI(JI).EQ.0.OR.(IPUNC.EQ.0.AND.ITUNC.EQ.0))  GOTO 3000
      CALL CHECKO (LUNO, 'PRINT')
C     SET DEPENDENT VALUES IF NOT ALREADY SET.
      IF (IDEPC.EQ.0.OR.ISETDP.NE.0)  GOTO 2100
      CALL SETDEP (ITM, LIDAT, ICDEP, NSTAT, ITYPC, LSTDEP,
     * IW(IWW1C), IW(IWW2C), NC, IW(IWW1S), IW(IWW2S), MS, 1)
 2100 CALL PRTUNC (ITM, IMC, ITYPC, LSTDEP, ICDES, LCDES, IW(IWW2C),
     * ITYPMK, IW(IWW1S), ICSTR, IFIRSTUNC)
      IFIRSTUNC = 0
 
 
C--   COLLECT SUMMARY STATISTICS.
 3000 IF (IPSUMM.EQ.0)  GOTO 4000
      CALL CHECKO (LUNO, 'PRINT')
C     SET DEPENDENT VALUES IF NOT ALREADY SET.
      IF (IDEPC.EQ.0.OR.ISETDP.NE.0)  GOTO 3100
      CALL SETDEP (ITM, LIDAT, ICDEP, NSTAT, ITYPC, LSTDEP,
     * IW(IWW1C), IW(IWW2C), NC, IW(IWW1S), IW(IWW2S), MS, 1)
C     ACCUMULATE STATISTICS.
 3100 CALL ACCSUM (ISUMM, ITM, ISBND, IW(IILANG), IDAT, LIDAT, NSTAT,
     * KSTAT,
     * ITYPC, IMC, NORNG, NC, IUNRNG, IOMNSC, IW(IWW1S), MS, IMI, JI)
 
 4000 RETURN
      END
