      SUBROUTINE ENDREC (ITYPE, ISTART, MAXDAT)                             TINT
 
C  REVISED 7-NOV-94.
C  FINISHES CURRENT OUTPUT RECORD.
 
C  ITYPE RECEIVES THE TYPE OF RECORD.
C  ISTART RECEIVES THE NUMBER OF FIRST OUTPUT RECORD FOR THIS CHARACTER.
C  MAXDAT RECEIVES AND RETURNS THE MAXIMUM DATA LENGTH.
 
      COMMON /DAOXXX/ IWOUT,IBOUT,IOUT(32)
      COMMON /LUNDAX/ LRECDA,IRECDA
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /TXOXXX/ OUTTXT
        CHARACTER*128 OUTTXT
      COMMON /WRDSIZ/ NBITS,NCHRWD
 
      LDAT = (IRECDA - ISTART + 1) * LRECDA
 
      IF (IWOUT.GT.0)  THEN
 
        IF (ITYPE.LE.4)  THEN
          CALL WRDAI (IOUT, IWOUT, LUNDA, LRECDA, IRECDA)
          LDAT = LDAT + IWOUT
        ELSE IF (ITYPE.EQ.5)  THEN
          CALL WRTXT (OUTTXT(1:IWOUT), LUNDA, LRECDA, IRECDA)
          LDAT = LDAT + (IWOUT+NCHRWD-1)/NCHRWD
        ENDIF
 
      ENDIF
 
      CALL SETIA (IOUT, LRECDA, 0)
      IBOUT = NBITS
      IWOUT = 0
 
      MAXDAT = MAX0 (LDAT, MAXDAT)
      RETURN
      END
      SUBROUTINE INTTI (ITM, IDAT, LIDAT, ITPTR, LNAME, ITMPTR, MI,         TINT
     * ITYPC, IMC, NSTAT, KSTAT, NORNG, WTC, ICPTW, ICPTB, INTRL,
     * PCERR, ABERR,
     * MINC, MAXC, ICSYN, IOMORC, NUMRNG, IUSECC, INAUTOCC, IOMPD,
     * IPARA, WORKC, IWORK1, IWORK2,
     * ITIMG, ITLNK, ITIMGP, JWORK1, JWORK2,
     * NBND,
     * NC, RBND, ITXPT, ISTAT, MS, ICDEP, LICDEP, ISBND, IMI, JI, JIM,
     * NAFLG, LFLG,  ITINTR, IUNRNG, IVARIT, ITIMGE, ITLINK, IERRPC,
     * IERRAB, NODELO, ICHNSE, IOMNSC, IOMTOR, IUCC, NAUTOCC, IOUTSUBJ,
     * LLANG, ITFILE, ITLNK2, IOSUBJ)
 
C  REVISED 28-JUN-00.
C  CONVERTS AN ITEM TO INTKEY FORMAT.
 
C  ITM RECEIVES THE ITEM.
C  IDAT RECEIVES WORKING SPACE OF LENGTH LIDAT.
C  LIDAT RECEIVES THE DIMENSION OF ITM, IDAT AND ISBND.
C  ITPTR RETURNS THE RECORD NUMBERS AT WHICH THE TAXA START IN THE
C   OUTPUT FILE.
C  LNAME RETURNS THE LENGTHS OF THE TAXON NAMES.
C  ITMPTR RECEIVES WORKING SPACE OF LENGTH MI.
C  MI RECEIVES THE MAXIMUM NUMBER OF ITEMS.
C  ITYPC RECEIVES THE CHARACTER TYPES.
C  IMC RECEIVES THE CHARACTER MASK.
C  KSTAT RECEIVES THE NUMBERS OF KEY STATES.
C  NORNG RECEIVES WHERE TO USE NORMAL CHARACTER RANGES.
C  WTC RECEIVES THE CHARACTER WEIGHTS.
C  ICPTW RETURNS THE POSITIONS OF THE STARTING WORDS OF THE
C    CHARACTERS IN THE OUTPUT BUFFER.
C  ICPTB RETURNS THE BIT OFFSETS (WITHIN WORD) OF THE CHARACTERS IN THE
C    OUTPUT BUFFER. I.E. BIT NUMBER FOR STATE I OF CHARACTER IC
C    IS ICPTB(IC)+I.
C  INTRL RECEIVES WHICH INTEGER CHARACTERS ARE TO BE TREATED AS REAL.
C  PCERR RECEIVES PERCENTAGE ERROR VALUES FOR REAL NUMERIC CHARACTERS.
C  ABERR RECEIVES ABSOLUTE ERROR VALUES FOR REAL NUMERIC CHARACTERS.
C  MINC RETURNS THE MINIMUM RECORDED VALUE OF INTEGER CHARACTERS.
C  MAXC RETURNS THE MAXIMUM RECORDED VALUE OF INTEGER CHARACTERS.
C  ICSYN RECEIVES THE CHARACTERS FOR SYNONYMY.
C  IOMORC RECEIVES THE LIST OF CHARACTERS TO WHICH OMIT "OR" APPLIES.
C  NUMRNG RETURNS THE MAXIMUM NUMBER OF RANGES OF AN INTEGER CHARACTER.
C  IUSECC RECEIVES THE LIST OF CHARACTERS SPECIFIED IN THE
C   "USE CONTROL CHARACTER FIRST" DIRECTIVE.
C  INAUTOCC RECEIVES THE LIST OF CHARACTERS SPECIFIED IN THE
C   "NONAUTOMATIC CONTROL CHARACTERS" DIRECTIVE.
C  IOMPD RECEIVES THE LIST OF CHARACTERS TO WHICH OMIT PERIOD APPLIES.
C  IPARA RECEIVES THE LIST OF CHARACTERS WHICH COMMENCE NEW PARAGRAPHS.
C  ITIMG RECEIVES POINTERS TO TEXT CONTAINING NAMES OF TAXON IMAGE FILES.
C  ITLNK RECEIVES POINTERS TO TEXT CONTAINING NAMES OF TAXON LINK FILES.
C  ITIMGP RECEIVES WORKING SPACE OF LENGTH MI.
C  JWORK1 RECEIVES WORKING SPACE OF LENGTH MI.
C  JWORK2 RECEIVES WORKING SPACE OF LENGTH MI.
C  WORKC RECEIVES REAL WORKING SPACE OF LENGTH NC.
C   (NB: WORKC AND IWORK1 OCCUPY SAME SPACE.)
C  IWORK1 RECEIVES INTEGER WORKING SPACE OF LENGTH NC.
C   (NB: WORKC AND IWORK1 OCCUPY SAME SPACE.)
C  IWORK2 RECEIVES INTEGER WORKING SPACE OF LENGTH NC.
C  NBND RETURNS THE RECORD ADDRESSES OF NUMBER CLASS BOUNDARY POINTS
C   FOR EACH NUMERIC CHARACTER.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  RBND RECEIVES WORKING SPACE OF LENGTH MI*2. USED TO ACCUMULATE
C   CLASS BOUNDARY POINTS.
C  ITXPT RECEIVES WORKING SPACE OF LENGTH MI+1. USED TO SAVE POINTERS
C   TO TEXT CHARACTERS.
C  ISTAT IS WORKING SPACE OF LENGTH MS.
C  MS RECEIVES THE MAXIMUM NUMBER OF STATES.
C  ICDEP RECEIVES THE CHARACTER DEPENDENCIES.
C  LICDEP RECEIVES THE LENGTH OF ICDEP.
C  ISBND RECEIVES THE KEY-STATE BOUNDARIES (SEE SUBR. SBOUND).
C  IMI RECEIVES THE ITEM MASK.
C  JI RECEIVES THE ITEM NUMBER.
C  JIM RECEIVES THE MASKED-IN ITEM NUMBER.
C  NAFLG RECEIVES WORKING SPACE TO STORE BIT FLAGS FOR INAPPLICABLE
C   CHARACTERS.
C  LFLG RECEIVES THE LENGTH OF NAFLG.
C  ITINTR RECEIVES WHETHER SOME INTEGER CHARACTERS ARE TO BE TREATED
C    AS REAL.
C  IUNRNG RECEIVES WHETHER TO USE NORMAL CHARACTER RANGES.
C  IVARIT RECEIVES 1 IF THE CURRENT ITEM IS A VARIANT, 0 IF MAIN,
C    -1 IF END OF ITEM DESCRIPTIONS.
C  ITIMGE RECEIVES WHETHER TAXON IMAGES ARE AVAILABLE.
C  ITLINK RECEIVES WHETHER TAXON LINKS ARE AVAILABLE.
C  ICIMGE RECEIVES A FLAG INDICATING WHETHER THERE CHARACTER IMAGE FILENAMES
C   TO PROCESS.
C  IERRPC RECEIVES WHETHER PERCENTAGE ERROR VALUES HAVE BEEN SET.
C  IERRAB RECEIVES WHETHER ABSOLUTE ERROR VALUES HAVE BEEN SET.
C  NODELO RECEIVES WHETHER DELTA OUTPUT IS PERMITTED FROM INTKEY. 0=YES, 1=NO.
C  ICHNSE RECEIVES WHETHER THE CHINESE CHARACTER SET IS USED.
C  IOMNSC RECEIVES TO OMIT INNER COMMENTS FROM TEXT CHARACTERS.
C  IOMTOR RECEIVES WHETHER OMIT "OR" HAS BEEN SPECIFIED.
C  IUCC RECEIVES WHETHER "USE CONTROLLING CHARACTER FIRST" HAS BEEN SPECIFIED.
C  NAUTOCC RECEIVES WHETHER "NONAUTOMATIC CONTROLLING CHARACTERS" HAS BEEN SPECIFIED.
C  IOUTSUBJ RECEIVES WHETHER "SUBJECT FOR OUTPUT FILES" HAS BEEN SPECIFIED.
C  LLANG RECEIVES THE LIST OF VALID LANGUAGES.
C  ITFILE RECEIVES THE "ITEM OUTPUT FILES" POINTERS.
C  ITLNK2 RECEIVES SPACE TO STORE THE SECONDARY TAXON LINKS INFORMATION.
C  IOSUBJ RECEIVES THE "SUBJECT FOR OUTPUT FILES".
 
C  THE DATA IS PROCESSED IN TWO PHASES.
C  IN PHASE ONE, THE DELTA INPUT IS READ AND OUTPUT TO A DIRECT-ACCESS
C  SCRATCH FILE. THE RECORD ADDRESS OF EACH ITEM ON THE SCRATCH FILE IS
C  RECORDED. THE DATA FORMAT IS THE SAME AS THAT USED FOR INPUT TO THE
C  DIST PROGRAM.
C  PHASE TWO INVOLVES INVERSION OF THE DATA MATRIX. FOR EACH CHARACTER,
C  THE RELEVANT DATA IS EXTRACTED FROM THE ITEMS ON THE SCRATCH FILE AND
C  OUTPUT TO A SECOND DIRECT-ACCESS FILE. POINTERS TO THE START OF EACH
C  CHARACTER ARE SAVED AND OUTPUT.
 
C  NOTE: ALGORITHM FOR PROCESSING INTEGER CHARACTERS IN TRANSLATION
C   TO INTKEY FORMAT.
C  PHASE1.
C  AS INTEGER VALUES ARE READ, THEY ARE STORED IN A FIXED LENGTH
C  ARRAY IN ASCENDING ORDER OF MAGNITUDE. iF THE ARRAY BECOMES FULL,
C  THE VALUE OF GREATEST MAGNITUDE IS DISCARDED AND THE NEW VALUE
C  INSERTED. THE NUMBER OF VALUES RETAINED AND THE NUMBER OF VALUES
C  DISCARDED ARE NOTED. (SEE SUBR. STOINT)
C  PHASE2.
C  IF THE RANGE OF A CHARACTER EXCEEDS NSLIM2, THEN SAVED VALUES ARE
C  PROGRESSIVELY DISCARDED UNTIL THE RANGE <= NSLIM2 OR THE NUMBER
C  DISCARDED IS GREATER THAN THE NUMBER RETAINED, IN WHICH CASE, THE
C  CHARACTER IS REPRESENTED AS REAL. (SEE SUBR. PROCI)
C  A WARNING IS ISSUED IF THE RANGE OF A CHARACTER EXCEEDS NSLIM1.
C  SPECIAL CASE: IF THE RANGE EXCEEDS NSLIM1 AND NO ITEM HAS MORE THAN
C  ONE RANGE FOR THE CHARACTER IN QUESTION, THE CHARACTER IS REPRESENTED
C  AS REAL.
 
      DIMENSION ITM(LIDAT),IDAT(LIDAT),ITPTR(MI),LNAME(MI),ITMPTR(MI),
     * ITYPC(NC),IMC(NC),NSTAT(NC),KSTAT(NC),NORNG(NC),WTC(NC),
     * ICPTW(NC),ICPTB(NC),INTRL(NC),PCERR(NC),ABERR(NC),MINC(NC),
     * MAXC(NC),ICSYN(NC),IOMORC(NC),NUMRNG(NC),IUSECC(NC),INAUTOCC(NC),
     * IOMPD(NC),IPARA(NC),
     * WORKC(NC),IWORK1(NC),IWORK2(NC),
     * ITIMG(MI),ITLNK(MI),ITIMGP(MI),JWORK1(MI),JWORK2(MI),
     * ITFILE(MI),ITLNK2(MI),IOSUBJ(LIDAT),
     * NBND(NC),RBND(MI*2),ITXPT(MI+1),ISTAT(MS),ICDEP(LIDAT),
     * ISBND(LIDAT),IMI(JI),NAFLG(LFLG),JVAL(2)
 
C     VERSION NUMBER OF OUTPUT FILE FORMAT. THIS SHOULD BE INCREMENTED
C     WHENEVER THE FILE FORMAT IS ALTERED.
      PARAMETER (IVFMT1=5, IVFMT2=2)                                                   =*
 
      PARAMETER (NPAR=64, UNK=-1., XNA=-2., VARBLE=-3.)
      PARAMETER (MAXINT=2**29, MININT=-MAXINT, NLIM1=64, NLIM2=200)
      PARAMETER (MAXREC4=50)
 
      DIMENSION RBF(2),ITSF(3),IPARAM(NPAR),INTGRS(NLIM2+2)
      CHARACTER FSPEC*60
      SAVE LITM,NMULC,NRNC,NINTC,NTXTC
 
      COMMON /DAOXXX/ IWOUT,IBOUT,IOUT(32)
C      COMMON /HEDXXX/ LHEAD,IHEAD(200)
      COMMON /ITSXXX/ ITSS
      COMMON /LANGXX/ IUSELNG1,IUSELNG2,NLANG
      COMMON /LUNDAX/ LRECDA,IRECDA
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
C      COMMON /REGXXX/ IREGHD(200),LREGHD,IREGSHD(200),LREGSHD,
C     * IREGVD(20),LREGVD
      COMMON /SCR4XX/ LRECS4,IRECS4
      COMMON /SCR5XX/ LRECS5,IRECS5
      COMMON /SCR6XX/ LRECS6,IRECS6
      COMMON /SCRNMX/ SCRNAM(7)
        CHARACTER*8 SCRNAM
      COMMON /SCRXXX/ LUNTS1,LUNTS2,LUNTS3,LUNTS4,LUNTS5,LUNTS6,LUNTS7
      COMMON /WRDSIZ/ NBITS,NCHRWD
 
      INDX(I) = (I-1)*LRECS4 + 1
 
      NPARAM = NPAR
      NSLIM1 = NLIM1
      NSLIM2 = NLIM2
 
      IF (IVARIT.LT.0)  GOTO 1000
 
C     SKIP MASKED-OUT ITEM.
      IF (IMI(JI).EQ.0)  GOTO 2500
 
C     SET POINTERS TO CHARACTERS AND OPEN DIRECT ACCESS SCRATCH FILES.
      IF (JIM.EQ.1)  THEN
 
        IWRD = 1
        IBIT = 0
 
C       RESERVE SPACE FOR MULTISTATE CHARACTERS.
        NMULC = 0
        NTXTC = 0
        DO 10 IC = 1, NC
          IF (IMC(IC).EQ.0)  GOTO 10
          ICPTB(IC) = 0
          JTYPC = ABS(ITYPC(IC))
          IF (JTYPC.EQ.5)  NTXTC = NTXTC + 1
          IF (JTYPC.GE.3) GOTO 10
          NMULC = NMULC + 1
          NS = KSTAT(IC)
          ICPTW(IC) = IWRD
          ICPTB(IC) = IBIT
          IBIT = IBIT + NS + 1
          I = IBIT/NBITS
          IWRD = IWRD + I
          IBIT = IBIT - I*NBITS
   10   CONTINUE
        IF (IBIT.NE.0) IWRD = IWRD + 1
 
C       RESERVE SPACE FOR REAL NUMERIC CHARACTERS.
        NINTC = 0
        NRNC = 0
        DO 20 IC = 1, NC
          IF (IMC(IC).EQ.0)  GOTO 20
          JTYPC = ABS(ITYPC(IC))
          IF (JTYPC.LE.2 .OR. JTYPC.GE.5) GOTO 20
          IF (JTYPC.EQ.3)  THEN
            NINTC = NINTC + 1
            IF (ITINTR.EQ.0)  GOTO 20
            IF (INTRL(IC).EQ.0)  GOTO 20
            NINTC = NINTC - 1
          ENDIF
          NRNC = NRNC + 1
          ICPTW(IC) = IWRD
          IWRD = IWRD + 3
   20   CONTINUE
 
        IF (NINTC.GT.0)  THEN
          CALL SETIA (MINC, NC, MAXINT)
          CALL SETIA (MAXC, NC, MININT)
          CALL SETIA (NUMRNG, NC, 0)
        ENDIF
 
        LITM = IWRD - 1
        LITM1 = LITM
        IF (LITM1.EQ.0)  LITM1 = NINTC * 2
        IF (LITM1.EQ.0)  LITM1 = MI + 1
        IF (LITM1.GT.LIDAT) GOTO 5000
 
C       OPEN SCRATCH FILE 4 TO STORE INTERMEDIATE DATA.
        LRECS4 = LIDAT/MI
        IF (LRECS4.LE.0)  CALL MESSA (102, -1, 0)
        LRECS4 = MIN0 (LRECS4,LITM1)
C       ** LIMIT LRECS4 TO MAXREC4. THE VALUE OF MAXREC4 MUST BE EQUAL
C       ** TO THE LENGTH OF THE LOCAL BUFFER IN S/R RDSCRI
        LRECS4 = MIN0 (LRECS4,MAXREC4)
        CALL GETAU (LUN)
        FSPEC = SCRNAM(4)
        CALL SETLUN (FSPEC, LUN, LUNTS4)
        CALL UOPEN (LUN, LUNUSE(LUN), FSPEC, LRECS4, IERR)
        IF (IERR.NE.0)  CALL MESSB (20, 4, 1, -1, 0)
 
C       OPEN SCRATCH FILE 5 TO STORE INTEGER DATA POINTS.
        IF (NINTC.GT.0)  THEN
          LRECS5 = NSLIM2 + 2
          CALL GETAU (LUN)
          FSPEC = SCRNAM(5)
          CALL SETLUN (FSPEC, LUN, LUNTS5)
          CALL UOPEN (LUN, LUNUSE(LUN), FSPEC, LRECS5, IERR)
          IF (IERR.NE.0)  CALL MESSB (20, 5, 1, -1, 0)
        ENDIF
 
C       SET RECORD POINTER FOR SCRATCH FILE 4.
        IRECS4 = 0
 
        IRECDA = 1
 
CC       OUTPUT HEADING.
CC       IF DATASET IS REGISTERED, OUTPUT REGISTRATION HEADING.
C        IF (IREGHD(1).GT.1) THEN
C          CALL SENSIM (IREGHD(2), LREGHD, IDAT(2), LIDAT-1, 1, L, 0, 0)
C        ELSE
C          CALL SENSIM (IHEAD(2), LHEAD, IDAT(2), LIDAT-1, 1, L, 0, 0)
C        ENDIF
C        IDAT(1) = L
C        CALL WRCSTR (IDAT, L+1, 1, LUNDA, LRECDA, IRECDA)
 
C       WRITE HEADING CONSISTING OF 1 BLANK FOR COMPATIBILITY WITH OLDER
C       VERSIONS OF INTKEY WHICH EXPECT THE HEADING TO BE IN THE ITEMS FILE.
        L = 1
        IDAT(1) = L
        IDAT(2) = 32
        CALL WRCSTR (IDAT, L+1, 1, LUNDA, LRECDA, IRECDA)
 
C       SUBJECT FOR OUTPUT FILES?
        IF (IOUTSUBJ.GT.0) CALL SETIA (ITLNK2, MI, 0)
 
      ENDIF
 
C     POINTER TO START OF ITEM.
      ITPTR(JIM) = IRECS4 + 1
 
C     REWIND SCRATCH 5.
      IRECS5 = 0
 
C---  WRITE ATTRIBUTE VALUES TO ARRAY IDAT.
 
      IF (LITM.GT.0)  CALL SETIA (IDAT, LITM, 0)
C     THIS LOOP DEALS WITH MULTISTATES AND REAL NUMERICS.
C     THESE CHARACTER TYPES HAVE FIXED LENGTH.
 
      DO 500 IC = 1, NC
        IF (IMC(IC).EQ.0)  GO TO 500
        JTYPC = IABS(ITYPC(IC))
        IF (JTYPC.EQ.5)  GOTO 500
        NS = KSTAT(IC)
        IF (JTYPC.EQ.3)  THEN
          IF (ITINTR.EQ.0)  GOTO 500
          IF (INTRL(IC).EQ.0)  GOTO 500
        ENDIF
        IWRD = ICPTW(IC)
        IF (JTYPC.EQ.3.OR.JTYPC.EQ.4) THEN
          RBF(1) = FLOAT(MAXINT)
          RBF(2) = -RBF(1)
          CALL RELOUT (1., IDAT(IWRD))
          CALL RELOUT (0., IDAT(IWRD+1))
        ENDIF
 
        IF (ITM(IC).LE.0)  GO TO 500
 
        JG = ITM(IC)
        JGN = JG + ITM(JG)
        JSG = JG + 1
        IF (JTYPC.EQ.3.OR.JTYPC.EQ.4)  GOTO 200
        IBIT = ICPTB(IC)
 
C-      SIMPLE, NON-NUMERIC ATTRIBUTE (CODED SEPARATELY FOR EFFICIENCY).
        IF (ISBND(IC).NE.0 .OR. ITM(JG).NE.4 .OR.
     *   ITM(JSG+1).NE.1)  GO TO 100
        CALL SETBIT (IBIT+ITM(JSG+2), IDAT(IWRD), NBITS)
        GO TO 500
 
C-      COMPOUND OR PSEUDO ATTRIBUTE.
  100   CALL FNDKST (ITM, ISBND, IC, LIDAT, ITYPC, KSTAT, NORNG, NC,
     *   IUNRNG, ISTAT, MS, ITSF, JI, 0.0, 0.0)
C       ENCODE ATTRIBUTE.
        I = 0
        DO 120 IS = 1, NS
          I = I + ISTAT(IS)
          IF (ISTAT(IS).GT.0)  CALL SETBIT (IBIT+IS, IDAT(IWRD), NBITS)
  120   CONTINUE
 
C       VARIABLE MULTISTATE.
        IF (ITSF(1).NE.0)  THEN
          DO 130 IS = 1, NS
            CALL SETBIT (IBIT+IS, IDAT(IWRD), NBITS)
  130     CONTINUE
        ENDIF
 
C       NOT APPLICABLE.
        IF (ITSF(3).NE.0)  CALL SETBIT (IBIT+NS+1, IDAT(IWRD), NBITS)
 
        GO TO 500
 
C-      NUMERIC VALUES.
  200   ICODED = 0
        KNTV = 0
        CALL SETIA (ITSF, 3, 0)
  215   JB = JSG + 2
        JE = JSG + ITM(JSG) - 1
        ITS = ITM(JSG+1)
        IF (ITS.EQ.0)  GOTO 300
        IF (ITS.GT.ITSS) GOTO 290
 
C       USE NORMAL RANGE?
        IF (ITS.EQ.1)  THEN
          NV = JE - JB + 1
          IF (NV.GT.3.AND.IUNRNG.NE.0.AND.NORNG(IC).NE.0)  THEN
            JB = JB + 1
            JE = JE - 1
          ENDIF
        ENDIF
        IF (JTYPC.EQ.4)  GOTO 250
 
C       INTEGER NUMERIC.
        ICODED = 1
        DO 220 J = JB, JE
          IVAL = ITM(J)
          VAL = FLOAT(IVAL)
          RBF(1) = MIN (VAL, RBF(1))
          RBF(2) = MAX (VAL, RBF(2))
  220     CONTINUE
          GOTO 300
 
C       REAL NUMERIC.
  250   IB = JB
  260   VAL = RELIN(ITM(IB))
          ICODED = 1
          RBF(1) = MIN (VAL, RBF(1))
          RBF(2) = MAX (VAL, RBF(2))
          KNTV = KNTV + 1
          IB = IB + 1
          IF (IB.LE.JE)  GOTO 260
          GOTO 300
 
C       VARIABLE, UNKNOWN, OR NOT APPLICABLE.
  290   ITSF(ITS-ITSS) = 1
 
  300   JSG = JSG + ITM(JSG)
        IF (JSG.LT.JGN)  GOTO 215
        IF (ICODED.GT.0)  THEN
          IF (JTYPC.EQ.4.AND.KNTV.EQ.1)  THEN
            IF (IERRPC.NE.0)  THEN
              P1 = 1. + PCERR(IC)/100.
              P2 = INT(1./(P1)*100.)/100.
              V1 = RBF(1) * P1
              V2 = RBF(1) * P2
              RBF(1) = MIN(V1,V2)
              RBF(2) = MAX(V1,V2)
            ENDIF
            IF (IERRAB.NE.0)  THEN
              RBF(1) = RBF(1) - ABERR(IC)
              RBF(2) = RBF(2) + ABERR(IC)
            ENDIF
          ENDIF
          IF (JTYPC.EQ.3.OR.JTYPC.EQ.4) THEN
            CALL RELOUT (RBF(1), IDAT(IWRD))
            CALL RELOUT (RBF(2), IDAT(IWRD+1))
          ENDIF
        ENDIF
        IF ((JTYPC.EQ.3.OR.JTYPC.EQ.4).AND.ITSF(3).NE.0) THEN
          CALL SETBIT (1, IDAT(IWRD+2), NBITS)
        ENDIF
        GOTO 500
 
  500   CONTINUE
 
C     OUTPUT ORDINARY INTEGER NUMERICS IN A SEPARATE LOOP.
C     THESE ARE OF VARIABLE LENGTH.
      JWRD = LITM + 1
      IF (NINTC.EQ.0)  GOTO 650
      IWRD = JWRD + 1
      ICM = 0
      KNT = 0
      DO 600 IC = 1, NC
        IF (IMC(IC).EQ.0)  GOTO 600
        ICM = ICM + 1
        JTYPC = IABS(ITYPC(IC))
        IF (JTYPC.NE.3) GOTO 600
        IF (ITINTR.NE.0.AND.INTRL(IC).NE.0)  GOTO 600
        KNT = KNT + 1
        IF (JIM.EQ.1)  THEN
          NKEPT = 0
          NLOST = 0
          CALL SETIA (INTGRS, NSLIM2+2, 0)
        ELSEIF (JIM.GT.1)  THEN
          IREC = KNT
          CALL RDDAI (INTGRS, LRECS5, LUNS5, LRECS5, IREC)
          NKEPT = INTGRS(1)
          NLOST = INTGRS(2)
        ENDIF
        CALL SETIA (ITSF, 3, 0)
        ICODED = 0
        NR = 0
        IF (ITM(IC).LE.0)  THEN
          NR = 1
          IDAT(IWRD) = 1.
          IDAT(IWRD+1) = 0.
          IWRD = IWRD + 2
          GOTO 570
        ENDIF
        JG = ITM(IC)
        JGN = JG + ITM(JG)
        MINV = MAXINT
        MAXV = MININT
        JSG = JG + 1
  515   JB = JSG + 2
        JE = JSG + ITM(JSG) - 1
        ITS = ITM(JSG+1)
        IF (ITS.EQ.0)  GOTO 560
        IF (ITS.GT.ITSS) GOTO 550
 
C       USE NORMAL RANGE?
        IF (ITS.EQ.1)  THEN
          NV = JE - JB + 1
          IF (NV.GT.3.AND.IUNRNG.NE.0.AND.NORNG(IC).NE.0)  THEN
            JB = JB + 1
            JE = JE - 1
          ENDIF
        ENDIF
 
        ICODED = 1
        IF (ITS.EQ.1) GOTO 530
C       VALUES CONNECTED BY "AND".
        DO 520 J = JB, JE
          IVAL = ITM(J)
          MINV = MIN (IVAL, MINV)
          MAXV = MAX (IVAL, MAXV)
          IF (IWRD+1.GT.LIDAT)  THEN
            LITM = IWRD + 1
            GOTO 5000
          ENDIF
          NR = NR + 1
          IDAT(IWRD) = IVAL
          IDAT(IWRD+1) = IVAL
          IWRD = IWRD + 2
          CALL STOINT (IVAL, INTGRS(3), NSLIM2, NKEPT, NLOST)
  520   CONTINUE
        GOTO 560
 
C       VALUES CONNECTED BY "TO".
  530   IB = ITM(JB)
        IE = ITM(JE)
        MINV = MIN (IB, MINV)
        MAXV = MAX (IE, MAXV)
        IF (IWRD+1.GT.LIDAT)  THEN
          LITM = IWRD + 1
          GOTO 5000
        ENDIF
        NR = NR + 1
        IDAT(IWRD) = IB
        IDAT(IWRD+1) = IE
        IWRD = IWRD + 2
        CALL STOINT (IB, INTGRS(3), NSLIM2, NKEPT, NLOST)
        IF (IE.GT.IB)  CALL STOINT (IE, INTGRS(3), NSLIM2, NKEPT, NLOST)
        GOTO 560
 
  550   JTS = ITS-ITSS
        IF (JTS.EQ.1)  THEN
C         VARIABLE.
          MINVL = MAXINT
          MAXVL = MAXINT - 1
        ELSEIF (JTS.EQ.2)  THEN
C         UNKNOWN.
          MINVL = MAXINT
          MAXVL = MININT
        ELSEIF (JTS.EQ.3)  THEN
C         INAPPLICABLE.
          MINVL = MININT
          MAXVL = MININT - 1
        ENDIF
        NR = NR + 1
        IDAT(IWRD) = MINVL
        IDAT(IWRD+1) = MAXVL
        IWRD = IWRD + 2
 
  560   JSG = JSG + ITM(JSG)
        IF (JSG.LT.JGN)  GOTO 515
 
  570   IDAT(JWRD) = NR
        IF (NR.GT.NUMRNG(IC))  NUMRNG(IC) = NR
        JWRD = IWRD
        IWRD = JWRD + 1
        IF (ICODED.GT.0)  THEN
          IF (MINV.LT.MINC(ICM))  MINC(ICM) = MINV
          IF (MAXV.GT.MAXC(ICM))  MAXC(ICM) = MAXV
        ENDIF
 
C       SAVE INTGRS ARRAY.
        INTGRS(1) = NKEPT
        INTGRS(2) = NLOST
        IREC = KNT - 1
        CALL WRDAI (INTGRS, LRECS5, LUNS5, LRECS5, IREC)
 
  600 CONTINUE
 
  650 JIDAT = JWRD
      IF (NTXTC.EQ.0)  GOTO 710
C     OUTPUT TEXT CHARACTERS IN A SEPARATE LOOP.
      DO 700 IC = 1, NC
        IF (IMC(IC).EQ.0)  GOTO 700
        JTYPC = IABS(ITYPC(IC))
        IF (JTYPC.NE.5)  GOTO 700
        KIDAT = JIDAT + 1
 
C       CHANGE 2 APR 01. Add following line
        IF (ITM(IC).LE.0)  GOTO 690
 
        JG = ITM(IC)
        JGN = JG + ITM(JG)
        JSG = JG + 1
  660   IF (JSG.GE.JGN)  GOTO 690
          ITS = ITM(JSG+1)
          IF (ITS.EQ.0)  THEN
            LEN = ITM(JG)
            ICOMM = 1
            IF (IOMNSC.NE.0)  ICOMM = 3
            CALL SENSIM (ITM(JG), LEN, IDAT(KIDAT+1), LEN, 0, L,
     *       ICOMM, 0)
            IF (NLANG.GT.0.AND.IUSELNG1.GT.0) THEN
              CALL LANGCMT (LLANG, LIDAT, IUSELNG1, IUSELNG2,
     *          NLANG, IDAT(KIDAT+1), L, NEWL)
              L = NEWL
            ENDIF
            IDAT(KIDAT) = L
            KIDAT = KIDAT + L + 1
          ELSEIF (ITS.EQ.7)  THEN
C           UNKNOWN.
            IDAT(KIDAT) = 1
            IDAT(KIDAT+1) = 0
            KIDAT = KIDAT + 2
          ELSEIF (ITS.EQ.8)  THEN
C           NOT APPLICABLE.
            IDAT(KIDAT) = 1
            IDAT(KIDAT+1) = -1
            KIDAT = KIDAT + 2
          ENDIF
          JSG = JSG + ITM(JSG)
          GOTO 660
  690   IDAT(JIDAT) = KIDAT - JIDAT - 1
        JIDAT = KIDAT
  700   CONTINUE
 
C     EXTRACT ITEM NAME.
  710 CALL SENSIM (ITM(NC+2), LIDAT, IDAT(JIDAT+2), LIDAT-JIDAT,
     * 1, LEN, 1, 0)
      LNAME(JIM) = LEN
      IDAT(JIDAT) = LEN + 1
      IDAT(JIDAT+1) = LEN
 
      JIDAT = JIDAT + LEN  + 1
 
C     OUTPUT ITEM TO SCRATCH FILE.
      CALL WRDAI (IDAT, JIDAT, LUNS4, LRECS4, IRECS4)
 
C     Save output subject and file name.
      IF (IOUTSUBJ.GT.0)
     * CALL WRTAXLNK(JI, JIM, ITM, IDAT, IOSUBJ, LIDAT,
     * ITFILE, ITLNK2, MI)
      GOTO 2500
 
C---  END ITEMS - OUTPUT INVERTED MATRIX AND DATA SPECIFICATION ARRAYS.
 
C     CHECK IF SUFFICIENT ROOM TOINVERT MATRIX.
 1000 L = LRECS4 * JIM
      IF (L.GT.LIDAT)  THEN
        LITM = L
        GOTO 5000
      ENDIF
 
      NCM = NONZER(IMC,NC)
 
C     SET POINTERS AND CLEAR OUTPUT BUFFER.
      IBOUT = NBITS
      IWOUT = 0
      CALL SETIA (IOUT, LRECDA, 0)
 
      IF (NINTC.GT.0.OR.NRNC.GT.0)  CALL SETIA (NBND, NC, 0)
      NUMBND = 0
      MAXKNT = 0
      NFREC = (LFLG + LRECDA -1)/LRECDA
 
C     REVISE CHARACTER TYPES.
      ICM = 0
      DO 1100 IC = 1, NC
        IF (IMC(IC).EQ.0)  GOTO 1100
        ICM = ICM + 1
        JTYPC = IABS(ITYPC(IC))
        IF (JTYPC.EQ.3.AND.ITINTR.NE.0.AND.INTRL(IC).NE.0) JTYPC = -4
        IWORK1(IC) = JTYPC
 1100   CONTINUE
 
C--   PROCESS CHARACTERS IN THE ORDER IN WHICH THEY WERE RECORDED.
      MAXDAT = 0
 
 
C     READ DATA FOR EACH ITEM INTO ALLOCATED BUFFER AREAS.
      DO 1200 IT = 1, JIM
        CALL RDSCRI (IDAT(INDX(IT)), ITPTR(IT))
 1200   CONTINUE
 
      NPROC = 0
C-    MULTISTATES.
      IWRD = 1
      IBIT = 0
      IF (NMULC.EQ.0)  GOTO 1310
      DO 1300 IC = 1, NC
        IF (IMC(IC).EQ.0)  GOTO 1300
        JTYPC = IABS(IWORK1(IC))
        IF (JTYPC.GE.3)  GOTO 1300
        NPROC = NPROC + 1
C       CALL PROGRS(3, NPROC, NCM, IDUM, 1)
        CALL PROGRS(3, IC, NPROC, NCM, IDUM, 1)
        IWORK2(IC) = IRECDA + 1
        NS = KSTAT(IC) + 1
        DO 1250 IT = 1, JIM
          CALL RDMUL (IDAT(INDX(IT)), IWRD, IBIT, NS,
     *     LWRD, LBIT, ITPTR(IT))
 1250     CONTINUE
        IWRD = LWRD
        IBIT = LBIT + 1
C       IBIT = IBIT + NS
C       I = IBIT/NBITS
C       IBIT = IBIT - I*NBITS
        CALL ENDREC (JTYPC, IWORK2(IC), MAXDAT)
 1300   CONTINUE
      IF (IBIT.GT.0)  IWRD  = IWRD + 1
 
C-    REAL NUMERIC CHARACTERS.
 1310 IF (NRNC.EQ.0)  GOTO 1410
      DO 1400 IC = 1, NC
        IF (IMC(IC).EQ.0)  GOTO 1400
        JTYPC = IABS(IWORK1(IC))
        IF (JTYPC.NE.4) GOTO 1400
        NPROC = NPROC + 1
C       CALL PROGRS(3, NPROC, NCM, IDUM, 1)
        CALL PROGRS(3, IC, NPROC, NCM, IDUM, 1)
        IWORK2(IC) = IRECDA + 1
        IRECDA = IRECDA + NFREC
        NSET = 0
        CALL SETIA (NAFLG, LFLG, 0)
        DO 1350 IT = 1, JIM
          CALL RDRL (IT, IDAT(INDX(IT)), IWRD, LWRD, ITPTR(IT), RBF,
     *     NAFLG, LFLG)
C         SAVE VALUES FOR LATER SORTING.
          IF (RBF(1).EQ.UNK.OR.RBF(1).EQ.XNA.OR.RBF(1).EQ.VARBLE)
     *     GOTO 1350
          RBND(NSET+1) = RBF(1)
          RBND(NSET+2) = RBF(2)
          NSET = NSET + 2
 1350     CONTINUE
        CALL ENDREC (JTYPC, IWORK2(IC), MAXDAT)
        ISAVE = IRECDA
        IRECDA = IWORK2(IC) - 1
        CALL WRDAI (NAFLG, LFLG, LUNDA, LRECDA, IRECDA)
        IRECDA = ISAVE
        IWRD = LWRD
        IF (NSET.GT.0)  CALL KYBNDS (RBND, NSET, NUMBND, MAXKNT,
     *   NBND(IC))
 1400   CONTINUE
 
C     POINTERS TO POSITION IN EACH ITEM.
C     (THE FOLLOWING CHARACTER TYPES HAVE VARIABLE LENGTH DATA.)
 1410 DO 1420 IT = 1, JIM
        ITMPTR(IT) = IWRD
 1420   CONTINUE
 
 
C-    INTEGER NUMERIC CHARACTERS.
      IF (NINTC.LE.0)  GOTO 1510
      IRECS5 = 0
      ICM = 0
      DO 1500 IC = 1, NC
        IF (IMC(IC).EQ.0)  GOTO 1500
        ICM = ICM + 1
        JTYPC = IABS(IWORK1(IC))
        IF (JTYPC.NE.3)  GOTO 1500
        IWORK2(IC) = IRECDA + 1
        NPROC = NPROC + 1
C       CALL PROGRS(3, NPROC, NCM, IDUM, 1)
        CALL PROGRS(3, IC, NPROC, NCM, IDUM, 1)
        IRECS5 = IRECS5 + 1
        NS = MAXC(ICM) - MINC(ICM) + 1
        IF (NS.GT.NSLIM1.AND.NUMRNG(IC).LE.1)  THEN
C         CALL MESSB (104, IC, 1, 2, 0)
          JTYPC = -4
        ENDIF
        IF (JTYPC.GT.0.AND.NS.GT.NSLIM2)  THEN
          CALL RDDAI (INTGRS, LRECS5, LUNS5, LRECS5, IRECS5)
          NEWMIN = MAXC(ICM)
          NEWMAX = MINC(ICM)
          CALL PROCI (IC, JTYPC, INTGRS, LRECS5, NSLIM2, NEWMIN, NEWMAX)
          MINC(ICM) = NEWMIN
          MAXC(ICM) = NEWMAX
          NS = MAXC(ICM) - MINC(ICM) + 1
          IF (JTYPC.NE.3)  NINTC = NINTC - 1
        ENDIF
C       IF (JTYPC.GT.0.AND.NS.GT.NSLIM1)  CALL MESSB (105, IC, 1, 2, 0)
        IF (JTYPC.EQ.-4)  IRECDA = IRECDA + NFREC
        IWORK1(IC) = JTYPC
        NSET = 0
        CALL SETIA (NAFLG, LFLG, 0)
        DO 1490 IT = 1, JIM
          CALL RDINTC (IT, IDAT(INDX(IT)), JTYPC, MINC(ICM), MAXC(ICM),
     *     ITMPTR(IT), ITPTR(IT), RBF, NAFLG, LFLG)
          IF (JTYPC.EQ.-4)  THEN
C           SAVE END POINTS FOR LATER SORTING.
            IF (RBF(1).GT.RBF(2))  GOTO 1490
            RBND(NSET+1) = RBF(1)
            RBND(NSET+2) = RBF(2)
            NSET = NSET + 2
          ENDIF
 1490   CONTINUE
        CALL ENDREC (JTYPC, IWORK2(IC), MAXDAT)
        IF (JTYPC.EQ.-4)  THEN
          ISAVE = IRECDA
          IRECDA = IWORK2(IC) - 1
          CALL WRDAI (NAFLG, LFLG, LUNDA, LRECDA, IRECDA)
          IRECDA = ISAVE
        ENDIF
        IF (NSET.GT.0)  CALL KYBNDS (RBND, NSET, NUMBND, MAXKNT,
     *   NBND(IC))
 1500 CONTINUE
 
C-    TEXT CHARACTERS.
C     NUMBER OF RECORDS REQUIRED TO STORE POINTERS TO START OF TEXT.
 1510 MAXTX1 = 0
      MAXTX2 = 0
      IF (NTXTC.EQ.0)  GOTO 1610
      NRECTX = (JIM + 1 + LRECDA - 1)/LRECDA + NFREC
 
      DO 1600 IC = 1, NC
        IF (IMC(IC).EQ.0)  GOTO 1600
        JTYPC = IABS(IWORK1(IC))
        IF (JTYPC.NE.5)  GOTO 1600
        NPROC = NPROC + 1
        CALL PROGRS(3, IC, NPROC, NCM, IDUM, 1)
        IWORK2(IC) = IRECDA + 1
        IRECDA = IRECDA + NRECTX
        IB = 1
        CALL SETIA (NAFLG, LFLG, 0)
        DO 1580 IT = 1, JIM
          CALL RDTXTC (IT, IDAT(INDX(IT)), ITMPTR(IT), ITPTR(IT), LWD,
     *     NAFLG, LFLG)
          ITXPT(IT) = IB
          IB = IB + LWD
 1580     CONTINUE
        CALL ENDREC (JTYPC, IWORK2(IC), IDUM)
C       WRITE OUT START POINTS.
        ITXPT(JIM+1) = IB
C       NOTE -
C       MAXTX1 = MAXIMUM LENGTH REQUIRED TO STORE ALL ITEMS OF A TEXT
C        CHARACTER
C       MAXTX2 = MAXIMUM LENGTH OF A SINGLE TEXT ITEM.
        MAXTX1 = MAX (MAXTX1, IB-1)
        DO 1590 IT = 1, JIM
          LEN = ITXPT(IT+1) - ITXPT(IT)
          MAXTX2 = MAX (MAXTX2, LEN)
 1590   CONTINUE
        ISAVE = IRECDA
        IRECDA = IWORK2(IC) - 1
        CALL WRDAI (NAFLG, LFLG, LUNDA, LRECDA, IRECDA)
        CALL WRDAI (ITXPT, JIM+1, LUNDA, LRECDA, IRECDA)
        IRECDA = ISAVE
 1600   CONTINUE
 
C-    ITEM NAMES.
 1610 IPTNAM = IRECDA + 1
      NRECPT = (JIM + 1 + LRECDA - 1)/LRECDA
      IRECDA = IRECDA + NRECPT
 
      IB = 1
      DO 1650 IT = 1, JIM
        CALL RDTXTC (IT, IDAT(INDX(IT)), ITMPTR(IT), ITPTR(IT), LWD,
     *   NAFLG, LFLG)
        ITXPT(IT) = IB
        IB = IB + LWD
 1650   CONTINUE
      CALL ENDREC (5, IPTNAM, MAXDAT)
      ITXPT(JIM+1) = IB
      ISAVE = IRECDA
      IRECDA = IPTNAM - 1
      CALL WRDAI (ITXPT, JIM+1, LUNDA, LRECDA, IRECDA)
      IRECDA = ISAVE
 
C     OUTPUT DATA SPECIFICATIONS.
      IPSPEC = IRECDA + 1
 
C     CHARACTER TYPES.
      ICM = 0
      DO 1680 IC = 1, NC
        IF (IMC(IC).EQ.0)  GOTO 1680
        ICM = ICM + 1
        IWORK1(ICM) = IWORK1(IC)
 1680 CONTINUE
      CALL WRDAI (IWORK1, NCM, LUNDA, LRECDA, IRECDA)
 
C     WHETEHER TO ALLOW DELTA OUTPUT FROM INTKEY.
C     *** DO THIS NOW BECAUSE ARRAY IWORK1 IS REUSED.
C     (THIS ALLOWS USERS OF A DATASET TO GET A COPY OF THE DATA IN DELTA FORMAT.)
      IF (NODELO.NE.0)  THEN
        ICHK = 0
      ELSE
C       SET ENABLE FLAG.
        ICHK = 0
        DO IC = 1, NCM
          ICHK = ICHK + IWORK1(IC)
        END DO
      ENDIF

C     NUMBERS OF STATES.
      ICM = 0
      DO 1700 IC = 1, NC
        IF (IMC(IC).EQ.0)  GOTO 1700
        ICM = ICM + 1
        JTYPC = IABS(ITYPC(IC))
        IF (JTYPC.LT.3)  THEN
          IWORK1(ICM) = KSTAT(IC)
        ELSE
          IWORK1(ICM) = NSTAT(IC)
        ENDIF
 1700   CONTINUE
      CALL WRDAI (IWORK1, NCM, LUNDA, LRECDA, IRECDA)
 
C     CHARACTER RELIABILITIES.
      ICM = 0
      DO 1710 IC = 1, NC
        IF (IMC(IC).EQ.0)  GOTO 1710
        ICM = ICM + 1
        WORKC(ICM) = 0
        IF (WTC(IC).LE.0)  GOTO 1710
        WORKC(ICM) = MAX(0.,MIN(10.,5.+1.45*ALOG(WTC(IC))))
 1710   CONTINUE
      CALL WRDAR (WORKC, NCM, LUNDA, LRECDA, IRECDA)
 
C     MINIMA AND MAXIMA FOR INTEGER NUMERICS.
      IPMINI = 0
      IF (NINTC.GT.0)  THEN
        IPMINI = IRECDA + 1
        CALL WRDAI (MINC, NCM, LUNDA, LRECDA, IRECDA)
        CALL WRDAI (MAXC, NCM, LUNDA, LRECDA, IRECDA)
      ENDIF
 
C---  OUTPUT DATASET PARAMETERS.
      IPARAM(1) = JIM
      IPARAM(2) = NCM
      IPARAM(3) = MS
      IPARAM(4) = MAXDAT
      IPARAM(5) = LRECDA
      IPARAM(6) = IPTNAM
      IPARAM(7) = IPSPEC
      IPARAM(8) = IPMINI
      IPARAM(18) = NSLIM2
      IPARAM(19) = MAXTX1
      IPARAM(20) = MAXTX2
C     N.B. IVFMT1 MUST ALWAYS REMAIN PARAM(16).                                =*
C          IVFMT2 MUST ALWAYS REMAIN PARAM(21).                                =*
      IPARAM(16) = IVFMT1
      IPARAM(21) = IVFMT2
      IPARAM(25) = ICHK
      IPARAM(26) = ICHNSE
C     ZERO UNUSED PARAMETERS.
C     NOTE: PARAMS 30, 31 AND 32 ARE USED BY INTKEY TO SAVE B-TREE AND NAMES INFO.
      DO 1750 I = 28, NPAR
        IPARAM(I) = 0
 1750 CONTINUE
 
C     CHARACTER DEPENDENCIES.
      IF (LICDEP.GT.0)  THEN
        CALL MSKDEP (ICDEP, ITM, LIDAT, IMC, NSTAT, NC, LDEP)
        IF (LDEP.GT.NCM)  THEN
          IPARAM(9) = LDEP
          IPARAM(10) = IRECDA + 1
          CALL WRDAI (ITM, LDEP, LUNDA, LRECDA, IRECDA)
        ELSE
          IPARAM(9) = 1
        ENDIF
        CALL INVDEP (ICDEP, ITM, LIDAT, IMC, NSTAT, NC, LDEP)
        IF (LDEP.GT.NCM)  THEN
          IPARAM(11) = LDEP
          IPARAM(12) = IRECDA + 1
          CALL WRDAI (ITM, LDEP, LUNDA, LRECDA, IRECDA)
        ELSE
          IPARAM(11) = 1
        ENDIF
      ENDIF
 
C     CHARACTER RECORD ADDRESSES.
      IPARAM(13) = IRECDA + 1
      ICM = 0
      DO 1900 IC = 1, NC
        IF (IMC(IC).EQ.0)  GOTO 1900
        ICM = ICM + 1
        IWORK1(ICM) = IWORK2(IC)
 1900   CONTINUE
      CALL WRDAI (IWORK1, NCM, LUNDA, LRECDA, IRECDA)
 
C     NUMBERS OF CLASS BOUNDARY POINTS.
      IPARAM(14) = NUMBND
      IPARAM(15) = MAXKNT
      IPARAM(17) = IRECDA + 1
      IF (NUMBND.GT.0)  THEN
        ICM = 0
        DO 2000 IC = 1, NC
          IF (IMC(IC).EQ.0)  GOTO 2000
          ICM = ICM + 1
          IWORK1(ICM) = NBND(IC)
 2000     CONTINUE
        CALL WRDAI (IWORK1, NCM, LUNDA, LRECDA, IRECDA)
      ENDIF
 
      IPARAM(22) = 0
C     IMAGE DATA AS DEFINED IN "CHARACTER FOR TAXON IMAGES".
C      IF (ICTIMGE.GT.0)  THEN
C        ICM = 0
C        DO IC = 1, NC
C          IF (IMC(IC).NE.0)  ICM = ICM + 1
C          IF (IC.EQ.ICTIMGE)  GOTO 2010
C        END DO
C 2010   IPARAM(22) = ICM
C      ELSE
C        IPARAM(22) = 0
C      ENDIF
 
C     CHARACTER IMAGES INFORMATION (NOW IN CHARACTERS FILE. 23.5.94)
C     NEED TO SET PARAMETER TO ZERO TO ACCOMODATE OLD DATA SETS WHICH WILL
C     CHECK THIS VALUE.
      IPARAM(23) = 0
C      IF (ICIMGE.EQ.0)  THEN
C        IPARAM(23) = 0
C      ELSE
C        IPARAM(23) = IRECDA + 1
C        IDUM = 0
C        CALL INTHLP (IMC, IWORK1, IWORK2, NC, ICIMG, ICIMGP, IDUM,
C     *   IDAT, LIDAT, IRECGP, 0)
C      ENDIF
 
C     WRITE TAXON IMAGE INFORMATION
      IF (ITIMGE.EQ.0)  THEN
        IPARAM(24) = 0
      ELSE
        IPARAM(24) = IRECDA + 1
        IDUM = 0
        DO IT = 1, MI
          ITIMGP(IT) = IT
        END DO
        CALL INTHLP (IMI, JWORK1, JWORK2, MI, ITIMG, ITIMGP, IDUM,
     *   IDAT, LIDAT, IRECGP, 0)
      ENDIF
 
C     CHARACTERS FOR SYNONYMY.
      IF (NONZER(ICSYN, NC).EQ.0)  THEN
        IPARAM(27) = 0
      ELSE
        IPARAM(27) = IRECDA + 1
        ICM = 0
        DO 2020 IC = 1, NC
          IF (IMC(IC).EQ.0)  GOTO 2020
          ICM = ICM + 1
          IWORK1(ICM) =ICSYN(IC)
 2020     CONTINUE
        CALL WRDAI (IWORK1, NCM, LUNDA, LRECDA, IRECDA)
      ENDIF
 
C     OMIT "OR" FOR CHARACTERS
      IF (IOMTOR.EQ.0)  THEN
        IPARAM(28) = 0
      ELSE
        IPARAM(28) = IRECDA + 1
        ICM = 0
        DO 2030 IC = 1, NC
          IF (IMC(IC).EQ.0)  GOTO 2030
          ICM = ICM + 1
          IWORK1(ICM) =IOMORC(IC)
 2030     CONTINUE
        CALL WRDAI (IWORK1, NCM, LUNDA, LRECDA, IRECDA)
      ENDIF

C     USE CONTROLLING CHARACTER FIRST.
      IF (IUCC.EQ.0)  THEN
        IPARAM(33) = 0
      ELSE
        IPARAM(33) = IRECDA + 1
        ICM = 0
        DO 2040 IC = 1, NC
          IF (IMC(IC).EQ.0)  GOTO 2040
          ICM = ICM + 1
          IWORK1(ICM) =IUSECC(IC)
 2040     CONTINUE
        CALL WRDAI (IWORK1, NCM, LUNDA, LRECDA, IRECDA)
      ENDIF

C     WRITE TAXON LINKS INFORMATION
      IF (ITLINK.EQ.0)  THEN
        IPARAM(34) = 0
      ELSE
        IPARAM(34) = IRECDA + 1
        IDUM = 0
        DO IT = 1, MI
          ITIMGP(IT) = IT
        END DO
        CALL INTHLP (IMI, JWORK1, JWORK2, MI, ITLNK, ITIMGP, IDUM,
     *   IDAT, LIDAT, IRECGP, 0)
      ENDIF

C     OMIT PERIOD FOR CHARACTERS
      IF (NONZER(IOMPD,NC).EQ.0)  THEN
        IPARAM(35) = 0
      ELSE
        IPARAM(35) = IRECDA + 1
        ICM = 0
        DO 2050 IC = 1, NC
          IF (IMC(IC).EQ.0)  GOTO 2050
          ICM = ICM + 1
          IWORK1(ICM) =IOMPD(IC)
 2050     CONTINUE
        CALL WRDAI (IWORK1, NCM, LUNDA, LRECDA, IRECDA)
      ENDIF

C     NEW PARAGRAPHS AT CHARACTERS
      IF (NONZER(IPARA,NC).EQ.0)  THEN
        IPARAM(36) = 0
      ELSE
        IPARAM(36) = IRECDA + 1
        ICM = 0
        DO 2060 IC = 1, NC
          IF (IMC(IC).EQ.0)  GOTO 2060
          ICM = ICM + 1
          IWORK1(ICM) =IPARA(IC)
 2060     CONTINUE
        CALL WRDAI (IWORK1, NCM, LUNDA, LRECDA, IRECDA)
      ENDIF

C     NONAUTOMATIC CONTROLLING CHARACTERS.
      IF (NAUTOCC.EQ.0)  THEN
        IPARAM(37) = 0
      ELSE
        IPARAM(37) = IRECDA + 1
        ICM = 0
        DO 2070 IC = 1, NC
          IF (IMC(IC).EQ.0)  GOTO 2070
          ICM = ICM + 1
          IWORK1(ICM) = INAUTOCC(IC)
 2070     CONTINUE
        CALL WRDAI (IWORK1, NCM, LUNDA, LRECDA, IRECDA)
      ENDIF

C     Write secondary TAXON LINKS information, which is generated automatically
C     from ITEM OUTPUT FILES, CHARACTER FOR OUTPUT FILES and 
C     SUBJECT FOR OUTPUT FILES
      IF (IOUTSUBJ.EQ.0)  THEN
        IPARAM(38) = 0
      ELSE
        IPARAM(38) = IRECDA + 1
        IDUM = 0
        DO IT = 1, MI
          ITIMGP(IT) = IT
        END DO
        CALL INTHLP (IMI, JWORK1, JWORK2, MI, ITLNK2, ITIMGP, IDUM,
     *   IDAT, LIDAT, IRECGP, 0)
      ENDIF

C     WRITE SECOND (CONTINUED) PARAMETERS RECORD, IF REQUIRED, AT END OF FILE.
      IF (NONZER(IPARAM(LRECDA+1), NPARAM-LRECDA).NE.0)  THEN
C       IPARAM(29) POINTS TO SECOND PARAMETERS RECORD.
        IPARAM(29) = IRECDA + 1
        CALL WRDAI (IPARAM(LRECDA+1), NPARAM-LRECDA, LUNDA, LRECDA,
     *   IRECDA)
      ENDIF
 
C     WRITE PARAMETERS RECORD.
      IRECDA = 0
      CALL WRDAI (IPARAM, MIN(NPARAM, LRECDA), LUNDA, LRECDA, IRECDA)
 
C     TERMINATE USE OF DIRECT-ACCESS FILES.
      LUNDA = -1
 
 2500 RETURN
 
 5000 JVAL(1) = LITM
      JVAL(2) = LIDAT
      CALL MESSB (85, JVAL, 2, -1, 0)
 
      END
      SUBROUTINE KYBNDS (RBND, NSET, NUMBND, MAXKNT, KREC)                  TINT
 
C  REVISED 16-NOV-88.
C  PROCESSES KEY STATE BOUNDARIES FOR REAL CHARACTERS.
 
      COMMON /LUNDAX/ LRECDA,IRECDA
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
 
      DIMENSION RBND(NSET)
 
C     SORT END POINTS.
      CALL RSHELL (RBND, NSET, IDUM, 1)
 
C     ELIMINATE DUPLICATE VALUES.
      XLAST = RBND(1)
      KNT = 1
      DO 10 I = 2, NSET
        IF (RBND(I).EQ.XLAST)  GOTO 10
        KNT = KNT + 1
        RBND(KNT) = RBND(I)
        XLAST = RBND(KNT)
   10 CONTINUE
      NUMBND = NUMBND + KNT
      MAXKNT = MAX (KNT,MAXKNT)
 
C     WRITE VALUES TO OUTPUT FILE.
      KREC = IRECDA + 1
      CALL WRDAI (KNT, 1, LUNDA, LRECDA, IRECDA)
      CALL WRDAR (RBND, KNT, LUNDA, LRECDA, IRECDA)
 
      RETURN
      END
      SUBROUTINE RDSCRI (IDAT, JREC)                                        TINT
 
C  REVISED 18-SEP-95.
C  READS NEXT ITEM RECORD FROM SCRATCH FILE INTO MEMORY.
 
C  IDAT RECEIVES SPACE TO STORE THE ITEMS.
C  JREC RECEIVES AND RETURNS THE RECORD ADDRESS ON THE SCRATCH FILE.
 
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /SCR4XX/ LRECS4,IRECS4
 
C     ** THE LENGTH OF IBUF MUST BE EQUAL TO THE VALUE OF MAXREC4
C     ** DEFINED IN S/R INTTI.
C     ** IT APPEARS THAT READING DIRECTLY INTO IDAT (AN ALLOCATED ARRAY)
C     ** CAN CAUSE ERRORS - PERHAPS CROSSING A SEGMENT BOUNDARY IN IDAT -
C     ** BUT USING A LOCAL BUFFER AVOIDS THE PROBLEM.
      DIMENSION IBUF(50)
 
      DIMENSION IDAT(LRECS4)
 
      READ (LUNS4,REC=JREC,ERR=100) (IBUF(I),I=1,LRECS4)
      JREC = JREC + 1
 
      DO I = 1, LRECS4
        IDAT(I) = IBUF(I)
      ENDDO
 
      RETURN
 
  100 CALL MESSA (107, -1, 0)
 
      END
      SUBROUTINE STOINT (IVAL, IA, N, NKEPT, NLOST)                         TINT
 
C  REVISED 5-NOV-88.
C  SAVES INTEGER VALUES IN AN ARRAY.
 
C  IVAL RECEIVES THE VALUE TO BE SAVED.
C  IA RECEIVES AND RETURNS THE ARRAY.
C  N RECEIVES THE LENGTH OF IA.
C  NKEPT RECEIVES AND RETURNS THE NUMBER OF POINTS CURRENTLY IN THE
C   ARRAY.
C  NLOST RECEIVES AND RETURNS THE NUMBER OF POINTS DISCRADED.
 
      DIMENSION IA(N)
 
C     VALUES ARE STORED IN ASCENDING ORDER OF MAGNITUDE.
      DO 100 I = 1, NKEPT
        IF (IVAL.EQ.IA(I))  GOTO 200
        IF (IABS(IVAL).LE.IABS(IA(I)))  THEN
C         IF ARRAY FULL, DISCARD ENTRY OF GREATEST MAGNITUDE.
          IF (NKEPT.GE.N)  THEN
            NLOST = NLOST + 1
            NKEPT = NKEPT - 1
          ENDIF
C         MOVE CURRENT ENTRIES IN ARRAY DOWN ONE POSITION.
          DO 10 J = NKEPT, I, -1
            IA(J+1) = IA(J)
   10     CONTINUE
C         INSERT NEW VALUE.
          IA(I) = IVAL
          NKEPT = NKEPT + 1
          GOTO 200
        ENDIF
  100 CONTINUE
 
C     VALUE GREATER IN MAGNITUDE THAN ANY STORED.
      IF (NKEPT.GE.N)  THEN
C       NO ROOM - NOTE IT AS A DISCARDED VALUE.
        NLOST = NLOST + 1
      ELSE
C       ADD TO ARRAY.
        NKEPT = NKEPT + 1
        IA(NKEPT) = IVAL
      ENDIF
 
  200 RETURN
      END
      SUBROUTINE WRTAXLNK(JI, JIM, IDAT, IWRK, ISUBJECT, LIDAT,
     * ITFILE, ITLNK2, MI)
 
C  REVISED 21-SEP-00.
C  WRITES SECONDARY TAXON LINKS.
 
      COMMON /BLKXXX/ KBLANK
      COMMON /DELXXX/ KDPLUS,KDSTAR,KDNUM,KDSOL,KDLBRA,KDRBRA,
     * KDCOM,KDRANG,KDAMP,KDCOLN,KDSTOP,KDINF,KDLPAR,KDRPAR,KDBSLSH
      COMMON /LUNXXX/ LUNE,LUNL,LUNO,LUNP,LUNS1,LUNBO,LUNBI,LUNI,LUNDA,
     * LUNS2,LUNS3,LUNS4,LUNS5,LUNS6,LUNS7
      COMMON /MISXXX/ IMPVAL,IPACH,IPCHN,IPUNC,IRAB,IKEYCH,ICMPRS,
     * ITUNC,ITINAP,ITIMPL,IUNVAR,LNKC,IDEPC,LICDEP,IPSUMM,ICHSEQ,
     * ITMSEQ,INSRVA,IFATT,ITINTR,ICMAND,IUNRNG,IOMTOR,NEWFLS,IRSEMI,
     * IOMSTC,IADDCH,IEMPCH,IVARUN,ISCALC,ICNOTE,ICIMGE,ITIMGE,MTIMGE,
     * NTIMGE,IOMNSC,IOMCMT,IOMLOW,IERRPC,IERRAB,ICHNSE,NUMST0,IUMEAN,
     * NADNAM,NEMNAM,NODELO,IOMUSP,ICKYIMG,ITKYIMG,ISUPIMG,ICTIMGE,
     * ICTNAME,IHTML,IRTF,MTHEAD,NTHEAD,ITMHDGS,LCDNAM,MTFILE,NTFILE,
     * ITMFILS,MXHEAD,NXHEAD,IDXHDGS,INSIMGFN,ICOFILE,IUCC,IOUNC,ITLINK,
     * MTLINK,NTLINK,NAUTOCC,IOUTSUBJ
      COMMON /DIRYXX/ OUTDIR,LOUTDIR,IMGDIR,LIMGDIR
        CHARACTER*80 OUTDIR,IMGDIR
      COMMON /LUOXXX/ NUN,LPAGE,LPRINT,LTOP,LPRDEF,LPUDEF,
     * LUNCOM(15),LUNPRE(15),LUNUSE(19),LUNREC(19),LUNPAG(19)
      COMMON /SCR6XX/ LRECS6,IRECS6
      COMMON /SCRNMX/ SCRNAM(7)
        CHARACTER*8 SCRNAM
      COMMON /SCRXXX/ LUNTS1,LUNTS2,LUNTS3,LUNTS4,LUNTS5,LUNTS6,LUNTS7
      COMMON /TNAMEX/ TNAME,LTNAME
        CHARACTER*256 TNAME
 
      DIMENSION IDAT(LIDAT),IWRK(LIDAT),ISUBJECT(LIDAT),ITFILE(MI),
     * ITLNK2(MI)
 
      CHARACTER*256 TAXONLNK
      SAVE TAXONLNK, LSTRECS6
 
      IF (JIM.EQ.1) THEN
        TAXONLNK = CHAR(KBLANK)
        IF (LUNS6.LT.0) THEN
C         OPEN SCRATCH FILE 6 TO STORE INTERMEDIATE DATA.
          IRECS6 = 0
          LRECS6 = 32
          CALL GETAU (LUN)
          CALL SETLUN (SCRNAM(6), LUN, LUNTS6)
          CALL UOPEN (LUN, LUNUSE(LUN), SCRNAM(6), LRECS6, IERR)
          IF (IERR.NE.0)  CALL MESSB (20, 6, 1, -1, 0)
        ENDIF
      ENDIF
 
C     Form a TAXON LINKS entry.
      NEWFILE = 0
      IF (ITMFILS.NE.0.AND.ITFILE(JI).NE.0)  THEN
C       Name derived from ITEM OUTPUT FILES.
        KRECS6 = ITFILE(JI)
        CALL RDDAI (L, 1, LUNS6, LRECS6, KRECS6)
        IF (L.LE.LIDAT) THEN
          KRECS6 = KRECS6 + 1
          CALL RDDAI (IWRK, L, LUNS6, LRECS6, KRECS6)
          KSG = 2
          L = IWRK(KSG) - 2
          IF (L.GT.0)  THEN
            NEWFILE = 1
C           Text begins at KSG+2
            IBFNAM = KSG + 2
            LFNAM = L
          ENDIF
        ENDIF
      ELSE IF (ICOFILE.NE.0)  THEN
C       CHARACTER FOR OUTPUT FILES.
        ISCODED = 0
        JG = IDAT(ICOFILE)
        IF (JG.EQ.0) GOTO 10
        JSG = JG + 1
        IB = JSG + 2
        IE = JSG + IDAT(JSG) - 1
        CALL REMNSC (IDAT(IB), IE-IB+1, L)
C       EMPTY?
        IF (L.LE.2) GOTO 10
C       TEST FOR EMPTY TEXT.
        IF (IEMPTYCMT(IDAT(IB), L).NE.0)  GOTO 10
        NEWFILE = 2
        ISCODED = 1
C       COPY INTO IWRK AND IGNORE ANGLE BRACKETS.
C       (USING IWRK SO THAT NEWFILE=1 AND NEWFILE=2 CAN USE THE SAME CODE.)
 
C        CALL COPIA (IDAT(IB+1), IWRK, L-2)
C        IBFNAM = 1
C        LFNAM = L - 2
 
C       Only copy the first word (just in case there is more than one word)
        IBFNAM = 1
        DO I = 1, L-2
          IF (IDAT(IB+I).EQ.KBLANK) THEN
            LFNAM = I - 1
            GOTO 10
          ENDIF
          IWRK(I) = IDAT(IB+I)
        ENDDO
        LFNAM = L - 2
   10   CONTINUE
C   10   IF (ISCODED.EQ.0)
C     *    CALL MESSC (166, IDUM, 1, -3, 0, TNAME(1:LTNAME), LTNAME, 1)
      ENDIF
 
      IF (NEWFILE.NE.0) THEN
C-      FORM NEW FILE NAME.
C         1 = Using ITEM OUTPUT FILES directive
C         2 = Using CHARACTER FOR OUTPUT FILES directive.
C         Check if file name already contains a path
        IPATH = 0
        DO I = 1, LFNAM
          IF (IWRK(IBFNAM+I-1).EQ.KDBSLSH.OR.
     *      IWRK(IBFNAM+I-1).EQ.KDSOL)  THEN
            IPATH = 1
            GOTO 5
          ENDIF
        ENDDO
    5   TAXONLNK = CHAR(KBLANK)
        LF = 0
C       Insert output path if not already present
        IF (IPATH.EQ.0.AND.LOUTDIR.GT.0) THEN
          TAXONLNK = OUTDIR
          LF = LOUTDIR
        ENDIF
        DO I = 1, LFNAM
          J = LF + I
          TAXONLNK(J:J) = CHAR(IWRK(IBFNAM+I-1))
        ENDDO
        LTAXONLNK = LF + LFNAM
        IDOT = 0
        DO J = LTAXONLNK, 1, -1
          IF (TAXONLNK(J:J).EQ.CHAR(KDSOL).OR.
     *      TAXONLNK(J:J).EQ.CHAR(KDBSLSH)) GOTO 6
          IF (TAXONLNK(J:J).EQ.CHAR(KDSTOP)) IDOT = J
        ENDDO
C       Add extension?
    6   IF (IDOT.EQ.0)  THEN
          L = LTAXONLNK
          IF (IHTML.NE.0)  THEN
            TAXONLNK(L+1:) = '.htm'
          ELSE IF (IRTF.NE.0)  THEN
            TAXONLNK(L+1:) = '.rtf'
          ELSE
            TAXONLNK(L+1:) = '.prt'
          ENDIF
          LTAXONLNK = L + 4
        ENDIF
      
C       Append subject.
        IF (IOUTSUBJ.GT.1) THEN
          TAXONLNK(LTAXONLNK+1:) = ' <@subject '
          LTAXONLNK = LTAXONLNK + 11
          JSG = 2
          L = ISUBJECT(JSG) - 2
          IB = JSG + 2
          DO K = 1, L
            TAXONLNK(LTAXONLNK+K:LTAXONLNK+K) = CHAR(ISUBJECT(IB+K-1))
          ENDDO
          LTAXONLNK = LTAXONLNK + L
          TAXONLNK(LTAXONLNK+1:LTAXONLNK+1) = '>'
          LTAXONLNK = LTAXONLNK + 1
        ENDIF
 
C       Put into appropriate form
        KIDAT = LTAXONLNK + 3
        IWRK(1) = KIDAT
        IWRK(2) = KIDAT - 1
        IWRK(3) = 0
        CALL COPSIA (TAXONLNK, IWRK(4), LTAXONLNK)
        
C       Write to scratch 6.
        ITLNK2(JI) = IRECS6 + 1
        LSTRECS6 = IRECS6 + 1
        CALL WRDAI (KIDAT, 1, LUNS6, LRECS6, IRECS6)
        CALL WRDAI (IWRK, KIDAT, LUNS6, LRECS6, IRECS6)
 
      ELSE
C       Same as last item.
        IF (TAXONLNK(1:1).NE.CHAR(KBLANK)) ITLNK2(JI) = LSTRECS6
      ENDIF
      
      RETURN
      END
      SUBROUTINE WRTXT (STR, LUN, LREC, IREC)                               TINT
 
C  REVISED 4/12/87.
C  OUTPUTS TEXT STRING TO DIRECT-ACCESS FILE.
 
C  STR RECEIVES THE STRING.
C  LUN RECEIVES THE OUTPUT UNIT.
C  LREC RECEIVES THE RECORD LENGTH OF LUN.
C  RECEIVES AND RETURNS THE CURRENT RECORD NUMBER ON LUN.
 
      COMMON /WRDSIZ/ NBITS,NCHRWD
 
      CHARACTER*(*) STR
 
      LCREC = LREC * NCHRWD
      L = LEN (STR)
      I = 0
 
   10 IF (L.LE.0)  GOTO 100
        NOUT = MIN0(L,LCREC)
        IREC = IREC + 1
        WRITE (LUN,REC=IREC) STR(I+1:I+NOUT)
        CALL LCOUNT (LUN)
        I = I + NOUT
        L = L - NOUT
        GOTO 10
 
  100 RETURN
      END
