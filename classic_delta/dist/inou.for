      SUBROUTINE CIREAL (VAL, MAXIND, XMIN, XMAX)                           INOU
C
C* REVISED 29/5/86.
C* READS A CHARACTER INDEXED LIST OF REAL VALUES.
C
C  VAL RETURNS THE VALUES READ.
C  MAXIND RECEIVES THE MAXIMUM PERMISSIBLE INDEX.
C  XMIN RECEIVES THE MINIMUM ALLOWED VALUE.
C  XMAX RECEIVES THE MAXIMUM ALLOWED VALUE.
C
C  THE INPUT TAKES THE FORM IC1,V1 IC2,V2 ... AND IS TERMINATED
C    BY A STAR-WORD.
C    IVAL(IC1) IS SET TO IV1, ETC.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR.
C
C
      DIMENSION VAL(MAXIND)
C
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
C
      IC = 0
C
C     READ AND DECODE NEXT WORD.
   30 CALL NEXTWD (JE)
        IF (IEOF.NE.0) GOTO 200
        IF (IBUF(JBUF:JBUF).EQ.STAR) GOTO 200
        CALL GETIND (IB, IE, IC, MAXIND, JE)
        IF (IC.LE.0) GOTO 100
        CALL RDKOD (VALUE, IBUF(JBUF:JE-1), IERR)
        IF (IERR.NE.0) GOTO 50
        IF (VALUE.LT.XMIN .OR. VALUE.GT.XMAX) GOTO 60
        DO 40 JC = IB, IE
          VAL(JC) = VALUE
   40     CONTINUE
        GOTO 100
C
C       ERROR MESSAGES.
   50   CALL ERROR (JBUF, 'INVALID INTEGER.%')
        GOTO 100
   60   CALL ERROR (JBUF, 'ILLEGAL VALUE.%')
C
  100   JBUF = JE
        GOTO 30
C
  200 RETURN
      END
      SUBROUTINE CONPHR (ICONPH, LCPH, NCPH, NSIG, IBUF, JBUF, JL,          INOU
     * ICPH, JE)
 
C* REVISED 24/7/87.
C* DETERMINES THE NUMBER ASSOCIATED WITH A CONTROL PHRASE.
 
C  ICONPH, DIMENSIONED (LCPH,NCPH), RECEIVES THE LIST OF CONTROL
C    PHRASES. ICONPH(1,ICPH) TO ICONPH(LCPH,ICPH) CONTAIN THE ICPH-TH
C    CONTROL PHRASE. EACH WORD OF THE PHRASE IS REPRESENTED BY ITS
C    FIRST NSIG LETTERS (FILLED OUT WITH BLANKS IF THE WORD IS SHORTER
C    THAN NSIG).
C    THUS, A PHRASE MAY CONTAIN AT MOST (LCPH+NSIG-1)/NSIG WORDS.
C    IF THE NUMBER OF WORDS IN THE PHRASE IS LESS THAN THIS, THE
C    REMAINING ELEMENTS OF ICONPH MUST BE FILLED OUT WITH BLANKS.
C    EACH CONTROL PHRASE MUST HAVE A DISTINCT REPRESENTATION ON
C    THE LIST. REPRESENTATIONS DIFFERING ONLY BY HAVING BLANKS
C    INSTEAD OF NON-BLANKS IN SOME ELEMENTS ARE NOT DISTINCT.
C  LCPH RECEIVES THE NUMBER OF ELEMENTS RESERVED IN ICONPH FOR THE
C    REPRESENTATION OF EACH CONTROL PHRASE. IT MUST NOT BE GREATER THAN
C    THE LENGTH OF THE LOCAL ARRAY JCONPH.
C  NCPH RECEIVES THE NUMBER OF CONTROL PHRASES IN ICONPH.
C  NSIG RECEIVES THE NUMBER OF SIGNIFICANT SYMBOLS IN EACH WORD OF
C    THE CONTROL PHRASE.
C  IBUF RECEIVES THE ARRAY TO BE TESTED FOR THE PRESENCE OF A CONTROL
C    PHRASE. IBUF SHOULD CONTAIN ONE SYMBOL PER ARRAY ELEMENT.
C  JBUF RECEIVES THE POSITION IN IBUF OF THE START OF THE FIELD WHICH
C    WILL BE SCANNED FOR THE CONTROL PHRASE.
C  JL RECEIVES THE POSITION IN IBUF OF THE END OF THE FIELD WHICH
C    WILL BE SCANNED FOR THE CONTROL PHRASE.
C  ICPH RETURNS THE NUMBER OF THE CONTROL PHRASE, OR 0 IF THE PHRASE IS
C    INVALID.
C  JE. IF THE CONTROL PHRASE IS VALID, JE RETURNS THE POSITION IN IBUF
C    IMMEDIATELY AFTER THE END OF THE PHRASE. IF IT IS INVALID, JE
C    RETURNS THE POSITION OF THE FIRST INVALID SYMBOL, OR, IF THE FIELD
C    WAS EXHAUSTED BEFORE FINDING A VALID PHRASE, JL+1.
C
C  JBUF MUST NOT BE GREATER THAN JL.
C  THE PHRASE MAY BE PRECEDED BY BLANKS.
 
      CHARACTER*1 ICONPH(LCPH,NCPH),JCONPH(8)
      CHARACTER*(*) IBUF
 
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
C
      DO 10 I = 1, LCPH
   10   JCONPH(I) = BLANK
      ISIG = 1
      JCW = 1
      ICPH = 1
      JF = JBUF
C
C-    SKIP OVER BLANKS.
   12 IF (JF.GT.JL) GOTO 300
        IF (IBUF(JF:JF).NE.BLANK) GOTO 20
        JF = JF + 1
        GOTO 12
C
C--   TEST FOR CONTROL PHRASE.
   20 JCONPH(JCW) = IBUF(JF:JF)
C
C-      LOOK FOR MATCH OF LETTERS CONSIDERED SO FAR.
   30   DO 40 I = 1, JCW
            IF (JCONPH(I).NE.ICONPH(I,ICPH)) GOTO 60
   40       CONTINUE
          DO 50 I = 1, LCPH
            IF (JCONPH(I).NE.ICONPH(I,ICPH)) GOTO 100
   50       CONTINUE
          GOTO 500
   60     IF (ICPH.GE.NCPH) GOTO 300
          ICPH = ICPH + 1
          GOTO 30
C
C-      PARTIAL MATCH FOUND, BUT NOT COMPLETE MATCH.
C-      POSITION POINTERS FOR NEXT SIGNIFICANT LETTER IN PHRASE.
  100   IF (ISIG.GE.NSIG) GOTO 150
C       NEXT LETTER IS SIGNIFICANT (UNLESS FIELD IS EXHAUSTED).
        IF (IBUF(JF:JF).EQ.BLANK) GOTO 200
        JF = JF + 1
        IF (JF.GT.JL) GOTO 300
        GOTO 200
C       NO MORE SIGNIFICANT LETTERS IN CURRENT WORD. MOVE TO
C       START OF NEXT WORD.
  150   ISIG = 0
  160   IF (IBUF(JF:JF).EQ.BLANK) GOTO 170
          JF = JF + 1
          IF (JF.GT.JL) GOTO 300
          GOTO 160
  170   IF (IBUF(JF:JF).NE.BLANK) GOTO 200
          JF = JF + 1
          IF (JF.GT.JL) GOTO 300
          GOTO 170
C       INCREMENT OTHER POINTERS.
  200   ISIG = ISIG + 1
        JCW = JCW + 1
        GOTO 20
C
C--
C-    INVALID SYMBOL OR END OF FIELD.
  300 ICPH = 0
      GOTO 540
C
C-    VALID CONTROL PHRASE. SKIP PAST LAST WORD.
  500 IF (IBUF(JF:JF).EQ.BLANK) GOTO 540
        JF = JF + 1
        IF (JF.GT.JL) GOTO 540
        GOTO 500
C-
  540 JE = JF
      RETURN
      END
      SUBROUTINE CONTRL (ICPH, JE)                                          INOU
C
C* REVISED 25-JUL-89.
C* IDENTIFIES CONTROL PHRASE.
C
C  ICPH. IF A CONTROL PHRASE IS FOUND, ICPH RETURNS ITS NUMBER.
C    OTHERWISE, IT RETURNS 0.
C  JE. IF A CONTROL PHRASE IS FOUND, JE RETURNS THE POSITION IN IBUF
C    IMMEDIATELY AFTER THE END OF THE PHRASE.
 
C     NUMBER OF CONTROL PHRASES - MUST AGREE WITH SUBR. RDDIR.
      PARAMETER (NCON=16)                                                     =*
 
      CHARACTER*1 ICON(8,NCON)
C
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
C
C     1 HEADING
      DATA ICON(1,1),ICON(2,1),ICON(3,1),ICON(4,1),ICON(5,1),
     * ICON(6,1),ICON(7,1),ICON(8,1)/'H','E',' ',' ',' ',' ',' ',' '/
C     2 MAXIMUM ITEMS IN MEMORY
      DATA ICON(1,2),ICON(2,2),ICON(3,2),ICON(4,2),ICON(5,2),
     * ICON(6,2),ICON(7,2),ICON(8,2)/'M','A','I','T','I','N','M','E'/
C     3 LISTING FILE
      DATA ICON(1,3),ICON(2,3),ICON(3,3),ICON(4,3),ICON(5,3),
     * ICON(6,3),ICON(7,3),ICON(8,3)/'L','I','F','I',' ',' ',' ',' '/
C     4 ITEMS FILE
      DATA ICON(1,4),ICON(2,4),ICON(3,4),ICON(4,4),ICON(5,4),
     * ICON(6,4),ICON(7,4),ICON(8,4)/'I','T','F','I',' ',' ',' ',' '/
C     5 OUTPUT FILE
      DATA ICON(1,5),ICON(2,5),ICON(3,5),ICON(4,5),ICON(5,5),
     * ICON(6,5),ICON(7,5),ICON(8,5)/'O','U','F','I',' ',' ',' ',' '/
C     6 INCLUDE CHARACTERS
      DATA ICON(1,6),ICON(2,6),ICON(3,6),ICON(4,6),ICON(5,6),
     * ICON(6,6),ICON(7,6),ICON(8,6)/'I','N','C','H',' ',' ',' ',' '/
C     7 EXCLUDE CHARACTERS
      DATA ICON(1,7),ICON(2,7),ICON(3,7),ICON(4,7),ICON(5,7),
     * ICON(6,7),ICON(7,7),ICON(8,7)/'E','X','C','H',' ',' ',' ',' '/
C     8 INCLUDE ITEMS
      DATA ICON(1,8),ICON(2,8),ICON(3,8),ICON(4,8),ICON(5,8),
     * ICON(6,8),ICON(7,8),ICON(8,8)/'I','N','I','T',' ',' ',' ',' '/
C     9 EXCLUDE ITEMS
      DATA ICON(1,9),ICON(2,9),ICON(3,9),ICON(4,9),ICON(5,9),
     * ICON(6,9),ICON(7,9),ICON(8,9)/'E','X','I','T',' ',' ',' ',' '/
C     10 NAMES FILE
      DATA ICON(1,10),ICON(2,10),ICON(3,10),ICON(4,10),ICON(5,10),
     * ICON(6,10),ICON(7,10),ICON(8,10)/'N','A','F','I',' ',' ',' ',' '/
C     11 COMMENT
      DATA ICON(1,11),ICON(2,11),ICON(3,11),ICON(4,11),ICON(5,11),
     * ICON(6,11),ICON(7,11),ICON(8,11)/'C','O',' ',' ',' ',' ',' ',' '/
C     12 LOG
      DATA ICON(1,12),ICON(2,12),ICON(3,12),ICON(4,12),ICON(5,12),
     * ICON(6,12),ICON(7,12),ICON(8,12)/'L','O',' ',' ',' ',' ',' ',' '/
C     13 MATCH OVERLAP
      DATA ICON(1,13),ICON(2,13),ICON(3,13),ICON(4,13),ICON(5,13),
     * ICON(6,13),ICON(7,13),ICON(8,13)/'M','A','O','V',' ',' ',' ',' '/
C     14 MINIMUM NUMBER OF COMPARISONS
      DATA ICON(1,14),ICON(2,14),ICON(3,14),ICON(4,14),ICON(5,14),
     * ICON(6,14),ICON(7,14),ICON(8,14)/'M','I','N','U','O','F','C','O'/
C     15 CHARACTER WEIGHTS
      DATA ICON(1,15),ICON(2,15),ICON(3,15),ICON(4,15),ICON(5,15),
     * ICON(6,15),ICON(7,15),ICON(8,15)/'C','H','W','E',' ',' ',' ',' '/
C     16 PHYLIP FORMAT
      DATA ICON(1,16),ICON(2,16),ICON(3,16),ICON(4,16),ICON(5,16),
     * ICON(6,16),ICON(7,16),ICON(8,16)/'P','H','F','O',' ',' ',' ',' '/
C
      CALL CONPHR (ICON, 8, NCON, 2, IBUF, JBUF+1, JEDAT-1, ICPH, JE)
      RETURN
      END
      SUBROUTINE DERNG (IB, IE, IMAX, JB, JE)                               INOU
C
C* REVISED 14/2/86.
C* DECODES A RANGE OF POSITIVE INTEGER VALUES.
C
C  IB RETURNS THE START OF THE RANGE, OR 0 IF THERE ARE ERRORS.
C  IE RETURNS THE END OF THE RANGE.
C  IMAX RECEIVES THE MAXIMUM ALLOWED VALUE.
C  JB RECEIVES THE LOCATION IN IBUF OF THE START OF THE FIELD
C    TO BE DECODED.
C  JE RECEIVES THE LOCATION IN IBUF IMMEDIATELY AFTER THE END OF
C    THE FIELD TO BE DECODED.
C
C  THE TEXT TO BE DECODED IS IN THE INPUT BUFFER BETWEEN IBUF(JB)
C    AND IBUF(JE-1), AND TAKES THE FORM N OR N-M.
C
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
C
      IF (JB.GE.JE) GOTO 240
C-    FIND RANGE SYMBOL, IF ANY.
      JF = INDEX (IBUF(JB:JE), RANGE)
 
      IF (JF.EQ.0) THEN
 
C-      A SINGLE ELEMENT WAS SPECIFIED.
        CALL IDKOD (IB, IBUF(JB:JE-1), IERR)
        IF (IERR.NE.0) GOTO 200
        IF (IB.LT.1 .OR. IB.GT.IMAX) GOTO 210
        IE = IB
C
      ELSE
 
C-      A RANGE WAS SPECIFIED.
        JF = JF + JB - 1
        IF (JB.GE.JF) GOTO 240
        CALL IDKOD (IB, IBUF(JB:JF-1), IERR)
        IF (IERR.NE.0) GOTO 200
        IF (IB.LT.1 .OR. IB.GT.IMAX) GOTO 210
        JB = JF + 1
        IF (JB.GE.JE) GOTO 240
        CALL IDKOD (IE, IBUF(JB:JE-1), IERR)
        IF (IERR.NE.0) GOTO 200
        IF (IE.LT.1 .OR. IE.GT.IMAX) GOTO 210
        IF (IE.LE.IB) GOTO 230
C
      ENDIF
      GOTO 1000
 
C-    ERROR MESSAGES.
  200 CALL ERROR (JB, 'INVALID INTEGER.%')
      GOTO 900
  210 CALL ERROR (JB, 'ILLEGAL VALUE.%')
      GOTO 900
  230 CALL ERROR (JB, 'VALUE OUT OF ORDER.%')
      GOTO 900
  240 CALL ERROR (JB, 'MISSING DATA.%')
  900 IB = 0
C-
 1000 RETURN
      END
      SUBROUTINE ERROR (IPOINT, MBUF)                                       INOU
 
C* REVISED 26/7/87.
C* PRINTS ERROR MESSAGE.
 
C  IPOINT RECEIVES THE POSITION IN THE INPUT BUFFER AT WHICH THE ERROR
C    OCCURRED.
C  MBUF RECEIVES THE MESSAGE.
 
      CHARACTER*(*) MBUF
 
      COMMON /ERRXXX/ IERR
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /LUNXXX/ LUNI,LUNT,LUNO,LUNE,LUNL,LUNS,LUNN
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
 
      CHARACTER FMT*20,MTMP*127
 
      IERR = IERR + 1
 
      IF (IPOINT.LE.0) THEN
        CALL MESS (MBUF)
      ELSE
        CALL MESS (IBUF(1:JEDAT))
        WRITE (FMT, 30) IPOINT
   30   FORMAT ('(1X,T', I3, ',A1,1X,A)')
        L = LMESS(MBUF)
        WRITE (MTMP, FMT) UPAROW, MBUF(1:L)
        L = IPOINT + 2 + L
        CALL MESS (MTMP(1:L))
      ENDIF
 
      RETURN
      END
      SUBROUTINE FERROR (MBUF)                                              INOU
 
C* REVISED 26/7/87.
C* PRINTS FATAL ERROR MESSAGE AND STOPS.
 
C  MBUF RECEIVES THE MESSAGE.
 
      CHARACTER*(*) MBUF
 
      CALL ERROR (0, MBUF)
      CALL UCLOSE
 
      END
      SUBROUTINE GETAU (LUN)                                                INOU
 
C* REVISED 28/2/86.
C* GETS NUMBER OF FIRST AVAILABLE LOGICAL UNIT.
 
C  LUN RETURNS THE LOGICAL UNIT NUMBER.
 
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(8),
     *                LUNUSE(12),LUNREC(12),LUNPAG(12)
 
 
      DO 20 I = 1, NUN
        IF (LUNUSE(I).LT.0) GOTO 50
   20 CONTINUE
      CALL FERROR ('TOO MANY FILES IN USE.%')
 
   50 LUN = I
 
      RETURN
      END
      SUBROUTINE GETFLI (LUNTYP, IERR)                                      INOU
 
C* REVISED 25/7/87.
C* READS NAME OF INPUT FILE AND OPENS IT.
C  (CURRENTLY USED ONLY FOR ITEMS FILE.)
 
      LOGICAL*4 E,O
      CHARACTER S*60,SNAME*30
 
      COMMON /DAPXXX/ IRECDA,LRECDA
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /LUNXXX/ LUNI,LUNT,LUNO,LUNE,LUNL,LUNS,LUNN
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(8),
     *                LUNUSE(12),LUNREC(12),LUNPAG(12)
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
 
      DIMENSION LU(7)
      EQUIVALENCE (LU(1),LUNI)
 
      IERR = 0
      CALL NEXTWD (JE)
      IF (IBUF(JBUF:JBUF).EQ.STAR) THEN
        CALL ERROR (JBUF-1, 'MISSING DATA.%')
        IERR = 1
      ENDIF
      IF (IERR.NE.0) GOTO 1000
      S = IBUF(JBUF:JE)
      JBUF = JE
 
C     CHECK FILE NAME AND OPEN IF NECESSARY.
      CALL EXNAME (S, SNAME)
      INQUIRE (FILE=S, EXIST=E, OPENED=O, NUMBER=LUN, ERR=100)
      IF (.NOT.E) GOTO 110
      IF (O) THEN
        IF (LUNUSE(LUN).NE.LUNCOM(LUNTYP)) GOTO 120
        LU(LUNTYP) = LUN
      ELSE
        CALL GETAU (L)
        CALL SETLUN (S, L, LUNTYP)
        CALL UOPEN (L, LUNTYP, S, LRECDA, IDUMMY, IERR)
        IF (IERR.NE.0) GOTO 130
      ENDIF
      GOTO 1000
 
C     ERROR MESSAGES.
  100 CALL ERROR (JBUF-1, 'INVALID FILE NAME.%')
      GOTO 900
  110 CALL ERROR (JBUF-1, 'FILE DOES NOT EXIST.%')
      GOTO 900
  120 CALL ERROR (JBUF-1,
     *  'INCOMPATIBLE WITH PREVIOUS USE OF THIS FILE.%')
      GOTO 900
  130 CALL ERROR (JBUF-1, 'FILE IS INACCESSIBLE.%')
 
  900 IERR = 1
 
 1000 RETURN
      END
      SUBROUTINE GETFLO (LUNTYP, IERR)                                      INOU
 
C* REVISED 25/7/87.
C* READS NAME OF OUTPUT FILE, AND OPENS FILE.
 
      LOGICAL*4 O
      CHARACTER S*60,SNAME*30
 
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /LUNXXX/ LUNI,LUNT,LUNO,LUNE,LUNL,LUNS,LUNN
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(8),
     *                LUNUSE(12),LUNREC(12),LUNPAG(12)
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
 
      DIMENSION LU(7)
      EQUIVALENCE (LU(1),LUNI)
 
      IERR = 0
      CALL NEXTWD (JE)
      IF (IBUF(JBUF:JBUF).EQ.STAR) THEN
        CALL ERROR (JBUF-1, 'MISSING DATA.%')
        IERR = 1
        GOTO 1000
      ENDIF
      S = IBUF(JBUF:JE)
      JBUF = JE
 
C     CHECK FILE NAME AND OPEN IF NECESSARY.
      CALL EXNAME (S, SNAME)
      INQUIRE (FILE=S, OPENED=O, NUMBER=LUN, ERR=100)
      IF (O) THEN
        IF (LUNUSE(LUN).NE.LUNCOM(LUNTYP)) GOTO 110
        LU(LUNTYP) = LUN
      ELSE
        CALL GETAU (L)
        CALL SETLUN (S, L, LUNTYP)
        CALL UOPEN (L, LUNTYP, S, IDUMMY, IDUMMY, IERR)
        IF (IERR.NE.0) GOTO 120
      ENDIF
      GOTO 1000
 
C--   ERROR MESSAGES.
  100 CALL ERROR (JBUF-1, 'INVALID FILE NAME.%')
      GOTO 900
  110 CALL ERROR (JBUF-1,
     *  'INCOMPATIBLE WITH PREVIOUS USE OF THIS FILE.%')
      GOTO 900
  120 CALL ERROR (JBUF-1, 'CANNOT OPEN OUTPUT FILE.%')
 
  900 IERR = 1
C--
 1000 RETURN
      END
      SUBROUTINE GETIND (IB, IE, IC, MAX, JE)                               INOU
 
C* REVISED 11/6/85.
C* DECODES A SINGLE INDEX VALUE OR INDEX RANGE.
 
C  IB RETURNS THE START OF THE RANGE.
C  IE RETURNS THE END OF THE RANGE.
C  IC RECEIVES AND RETURNS THE LAST NUMBER READ.
C    IF THE NUMBER OR RANGE READ IS INVALID, IC RETURNS -1.
C  MAX RECEIVES THE MAXIMUM INDEX VALUE.
C  JE RECEIVES THE LOCATION IN IBUF IMMEDIATELY AFTER THE END OF
C    THE INPUT FIELD TO BE EXAMINED.
 
C  THE INPUT FIELD IS IBUF(JBUF) TO IBUF(JE-1).
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED.
C  ON EXIT WITH A VALID NUMBER, JBUF IS
C    IMMEDIATELY AFTER THE COMMA.
C    ON EXIT WITH AN INVALID NUMBER, JBUF IS SET TO JE.
 
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
 
C     SEARCH FOR COMMA.
      JF = INDEX (IBUF(JBUF:JE), COMMA)
      IF (JF.EQ.0) GOTO 100
      JF = JF + JBUF - 1
      IF (JF.EQ.JBUF) GOTO 100
 
C     COMMA FOUND, PRECEDING FIELD NON-EMPTY. DECODE NUMBER.
      CALL DERNG (IB, IE, MAX, JBUF, JF)
      IF (IB.LE.0) GOTO 150
 
C     CHECK NUMBERS.
      DO 55 IX = IB, IE
        IF (IX.LE.0 .OR. IX.GT.MAX) GOTO 120
   55   CONTINUE
      IC = IE
      JBUF = JF + 1
      GOTO 200
 
C     ERROR MESSAGES.
  100 CALL ERROR (JBUF, 'MISSING INDEX VALUE.%')
      GOTO 150
  120 CALL ERROR (JBUF, 'INDEX OUT OF RANGE.%')
 
  150 IC = -1
      IB = -1
      IE = -1
      JBUF = JE
 
  200 RETURN
      END
      SUBROUTINE HEADER                                                     INOU
 
C* REVISED 24/7/87.
C* READS HEADER FROM INPUT.
 
      COMMON /HEDXXX/ HEAD
      CHARACTER*200 HEAD
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /LHEADX/ LHEAD,MAXHDR
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
 
      ISK = 0
      CALL SKNONB
      LHEAD = 0
 
   10 CONTINUE
      J = INDEX (IBUF(JBUF:JEDAT), STAR)
        IF (J.EQ.0) THEN
          JE = JEDAT
        ELSE
          JE = J + JBUF - 2
        ENDIF
        L = JE - JBUF + 1
        IF (L.LE.0) GOTO 100
        IF (LHEAD+L.GT.MAXHDR) THEN
          L = MAXHDR - LHEAD
          ISK = 1
        ENDIF
        HEAD(LHEAD+1:LHEAD+L) = IBUF(JBUF:JBUF+L-1)
        LHEAD = LHEAD + L
        IF (ISK.NE.0) GOTO 50
        IF (J.NE.0) GOTO 100
        CALL RDBUF
        IF (IEOF.NE.0) GOTO 100
        GOTO 10
 
   50 CALL SKDELW
 
  100 RETURN
      END
      SUBROUTINE IDKOD (NUM, IBF, IERR)                                     INOU
 
C* REVISED 24/7/87.
C* DECODES AN INTEGER VALUE.
 
      CHARACTER*(*) IBF
      CHARACTER*10 FMT
 
      IERR = 0
      L = LEN (IBF)
 
      WRITE (FMT, 10) L
   10 FORMAT ('(I', I4, ')')
      READ (IBF, FMT, ERR=30) NUM
      GOTO 40
C
   30 IERR = 1
C
   40 RETURN
      END
      FUNCTION   NAMLEN (FNAME)                                             INOU
 
C* REVISED 24/7/87.
C* DETERMINES THE LENGTH OF THE 'NAME' PART OF A FILENAME.
 
C  FNAME RECEIVES THE FILENAME.
 
      CHARACTER*(*) FNAME
 
      L = LSTRB(FNAME)
      I = 0
      IF (L.GE.1) I = INDEX(FNAME(1:L),'.') - 1
      IF (I.LT.0) I = L
      NAMLEN = I
 
      RETURN
      END
      FUNCTION   LMESS (SBF)                                                INOU
 
C* REVISED 19/8/87.
C* FINDS THE LENGTH OF A CHARACTER STRING DELIMITED BY '%'.
 
C  THE FUNCTION RETURNS LENGTH OF THE STRING, EXCLUDING THE DELIMITER.
C  SBF RECEIVES THE STRING, DELIMITED BY '%' AT THE END.
 
      CHARACTER SBF*(*)
 
      DO 10 I = 1, LEN(SBF)
        IF (SBF(I:I).EQ.'%') GOTO 20
   10 CONTINUE
 
   20 LMESS = MAX(1,I-1)
 
      RETURN
      END
      FUNCTION   LSTRB (SBF)                                                INOU
 
C* REVISED 27/7/87.
C* FINDS THE LENGTH OF A CHARACTER STRING DELIMITED BY BLANK.
 
C  THE FUNCTION RETURNS LENGTH OF THE STRING, EXCLUDING THE BLANK.
C  SBF RECEIVES THE STRING, DELIMITED BY BLANK AT THE END.
 
      CHARACTER SBF*(*)
 
      L = INDEX(SBF,' ') - 1
      IF (L.LT.0) L = LEN(SBF)
      LSTRB = L
 
      RETURN
      END
      SUBROUTINE LCOUNT (LUN)                                               INOU
C
C* REVISED 28/7/87.
C* COUNTS OUTPUT RECORDS, AND HANDLES PAGINATION.
 
C  LUN RECEIVES THE LOGICAL UNIT.
 
C  IF A NEW PAGE IS NOT REQUIRED, LUNREC(LUN) IS INCREMENTED.
C    OTHERWISE, LUNREC(LUN) IS SET TO 1, AND A FORMFEED AND LTOP BLANK
C    LINES ARE OUTPUT.
 
      COMMON /FFFXXX/ FF
        CHARACTER*1 FF
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(8),
     *                LUNUSE(12),LUNREC(12),LUNPAG(12)
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
 
 
      IF (LUNPAG(LUN).EQ.0 .OR.
     *  (LUNREC(LUN).GT.0.AND.LUNREC(LUN).LT.LPRINT)) THEN
        LUNREC(LUN) = LUNREC(LUN) + 1
      ELSE
        LUNREC(LUN) = 1
C        CALL WREC (FF, LUN)
        DO 50 I = 1, LTOP
          CALL WREC (BLANK, LUN)
   50   CONTINUE
      ENDIF
 
      RETURN
      END
      SUBROUTINE MESS (MBUF)                                                INOU
 
C* REVISED 25/7/87.
C* PRINTS A MESSAGE ON THE ERROR AND LISTING UNITS.
 
C  MBUF RECEIVES THE MESSAGE.
 
      CHARACTER*(*) MBUF
 
      COMMON /LUNXXX/ LUNI,LUNT,LUNO,LUNE,LUNL,LUNS,LUNN
 
      L = LMESS(MBUF)
      CALL WRTREC (MBUF(1:L), LUNE)
      IF (LUNL.GT.0 .AND. LUNL.NE.LUNE) CALL WRTREC (MBUF(1:L), LUNL)
 
      RETURN
      END
      SUBROUTINE NEXTWD (JE)                                                INOU
C
C  REVISED 7/6/85.
C  FINDS THE END OF THE CURRENT WORD.
C
C  JE RETURNS THE POSITION IMMEDIATELY AFTER THE END OF THE WORD.
C  ON EXIT, JBUF IS AT THE START OF THE WORD.
C
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
C
      CALL SKNONB
      IF (IEOF.NE.0) GOTO 20
      J = INDEX (IBUF(JBUF+1:JEDAT), BLANK)
      JE = J + JBUF
C
   20 RETURN
      END
      FUNCTION   NONZER (IA, N)                                             INOU
C
C  REVISED 5/2/80.
C  COUNTS NON-ZERO ELEMENTS OF AN INTEGER ARRAY.
C
C  IA RECEIVES THE ARRAY TO BE COUNTED.
C  N RECEIVES THE LENGTH OF IA.
C
      DIMENSION IA(N)
C
      NONZER = 0
      DO 10 I = 1, N
        IF (IA(I).NE.0) NONZER = NONZER + 1
   10   CONTINUE
      RETURN
      END
      SUBROUTINE OPNDEF (LUNTYP)                                            INOU
 
C* REVISED 7/8/87.
C* OPENS DEFAULT INPUT AND OUTPUT FILES.
 
C  LUNTYP RECEIVES THE TYPE OF UNIT.
 
      LOGICAL*4 E
      CHARACTER DEFNAM*60,MBUF*70
 
      COMMON /DAPXXX/ IRECDA,LRECDA
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /LUFXXX/ FNAME(10),LFNAME(10)
        CHARACTER FNAME*30
      COMMON /LUNXXX/ LUNI,LUNT,LUNO,LUNE,LUNL,LUNS,LUNN
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(8),
     *                LUNUSE(12),LUNREC(12),LUNPAG(12)
 
      IF (LUNTYP.EQ.2) THEN
        DEFNAM = 'ditems'
        CALL EXNAME (DEFNAM, MBUF)
        INQUIRE (FILE=DEFNAM, EXIST=E)
        IF (.NOT.E) CALL FERROR ('NO DIST ITEMS FILE.%')
        CALL GETAU (LUN)
        CALL SETLUN (DEFNAM, LUN, LUNTYP)
        CALL UOPEN (LUN, LUNTYP, DEFNAM, LRECDA, IDUMMY, IERR)
        IF (IERR.NE.0) GOTO 100
 
      ELSE IF (LUNTYP.EQ.3) THEN
        IF (IFOPEN.EQ.0) THEN
          DEFNAM = 'dist.dis'
        ELSE
          L = NAMLEN (FNAME(LUNI))
          DEFNAM = ' '
          IF (L.GT.0) DEFNAM(1:L) = FNAME(LUNI)(1:L)
          DEFNAM(L+1:L+4) = '.dis'
        ENDIF
        CALL GETAU (LUN)
        CALL SETLUN (DEFNAM, LUN, LUNTYP)
        CALL UOPEN (LUN, LUNTYP, DEFNAM, IDUMMY, IDUMMY, IERR)
        IF (IERR.NE.0) GOTO 200
 
      ELSE IF (LUNTYP.EQ.7) THEN
          L = NAMLEN (FNAME(LUNO))
          DEFNAM = ' '
          IF (L.GT.0) DEFNAM(1:L) = FNAME(LUNO)(1:L)
          DEFNAM(L+1:L+4) = '.nam'
          CALL GETAU (LUN)
          CALL SETLUN (DEFNAM, LUN, LUNTYP)
          CALL UOPEN (LUN, LUNTYP, DEFNAM, IDUMMY, IDUMMY, IERR)
          IF (IERR.NE.0) GOTO 200
      ENDIF
 
      GOTO 300
 
  100 WRITE (MBUF, 110) FNAME(LUN)(1:LFNAME(LUN))
  110 FORMAT ('FILE ', A, ' IS INACCESSIBLE.%')
      CALL FERROR (MBUF)
 
  200 WRITE (MBUF, 210) FNAME(LUN)(1:LFNAME(LUN))
  210 FORMAT ('UNABLE TO OPEN OUTPUT FILE - ', A, '.%')
      CALL FERROR (MBUF)
 
  300 RETURN
      END
      SUBROUTINE PROGID (LUN)                                               INOU
 
C* REVISED 11-JUN-91.
C* OUTPUTS PROGRAM IDENTIFICATION.
 
C  LUN RECEIVES THE LOGICAL UNIT FOR THE OUTPUT.
 
      COMMON /PIDXXX/ PID
        CHARACTER*230 PID
 
      CHARACTER ENDLN*1
      PARAMETER(ENDLN='|')
 
      IB = 1
      L = LMESS(PID)
   10 L1 = INDEX(PID(IB:L), ENDLN) - 1
      IF (L1.LT.0)  L1 = L - IB + 1
      IF (L1.GT.0)  THEN
        CALL WRTREC (PID(IB:IB+L1-1), LUN)
      ELSE
        CALL WRTREC(' ', LUN)
      ENDIF
      IB = IB + L1 + 1
      IF (IB.LE.L)  GOTO 10
 
      RETURN
      END
      SUBROUTINE RDBUF                                                      INOU
 
C* REVISED 1/8/87.
C* READS NEXT INPUT RECORD.
 
C  IEOF IS SET TO 1 IF END-OF-FILE FOUND.
 
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /LUNXXX/ LUNI,LUNT,LUNO,LUNE,LUNL,LUNS,LUNN
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
C
      IEOF = 0
      IF (IFOPEN.EQ.0) THEN
        IEOF = 1
        GOTO 40
      ENDIF
 
      CALL RREC (IBUF, 120, JEDAT, LUNI)
 
      IF (JEDAT.LT.0) THEN
        IEOF = 1
        GOTO 40
      ENDIF
   20 I = JEDAT
   22 IF (I.LT.1) GOTO 30
        IF (IBUF(I:I).NE.BLANK) GOTO 30
        I = I - 1
      GOTO 22
   30 JEDAT = I + 1
      IBUF(JEDAT:JEDAT) = BLANK
      JBUF = 1
 
   40 RETURN
      END
      SUBROUTINE RDDAI (IA, N, JREC, LUN)                                   INOU
 
C  REVISED 28/1/87.
C  READS N INTEGER WORDS FROM A DIRECT-ACCESS FILE INTO THE ARRAY IA.
C  READING COMMENCES AT RECORD JREC ON LOGICAL UNIT LUN.
C  IF JREC < 0, THEN READING CONTINUES FROM THE CURRENT FILE POSITION.
 
 
      DIMENSION IA(N)
 
      COMMON /DAPXXX/ IRECDA,LRECDA
 
      I = 0
      NN = N
      IF (JREC.GT.0) IRECDA = JREC
 
   10 IF (NN.LE.0) GOTO 20
        IREAD = MIN0 (NN,LRECDA)
        READ(LUN,REC=IRECDA) (IA(J),J=I+1,I+IREAD)
        I = I + IREAD
        IRECDA = IRECDA + 1
        NN = NN - IREAD
        GOTO 10
 
   20 RETURN
      END
      SUBROUTINE RDDAR (A, N, JREC, LUN)                                    INOU
 
C  REVISED 28/1/87.
C  READS N REAL WORDS FROM A DIRECT-ACCESS FILE INTO THE ARRAY A.
C  READING COMMENCES AT RECORD JREC ON LOGICAL UNIT LUN.
C  IF JREC < 0, THEN READING CONTINUES FROM THE CURRENT FILE POSITION.
 
 
      DIMENSION A(N)
 
      COMMON /DAPXXX/ IRECDA,LRECDA
 
      I = 0
      NN = N
      IF (JREC.GT.0) IRECDA = JREC
 
   10 IF (NN.LE.0) GOTO 20
        IREAD = MIN0 (NN,LRECDA)
        READ(LUN,REC=IRECDA) (A(J),J=I+1,I+IREAD)
        I = I + IREAD
        IRECDA = IRECDA + 1
        NN = NN - IREAD
        GOTO 10
 
   20 RETURN
      END
      SUBROUTINE RDDIR (W, IW, LW, IPARAM, NPARAM)                          INOU
 
C* REVISED 13-DEC-93.
C* READS PARAMETERS.
 
      COMMON /ADRXXX/ IIMC,INSTAT,IITYPC,IWTC,IICPTW,IICPTB,
     * ICRANG,ICMIN,ICMAX,ISTPR1,ISTPR2,IIMI,IITMPT,ILNAME,IDM,IITMS,
     * IITMAP,IIBREC
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /LUNXXX/ LUNI,LUNT,LUNO,LUNE,LUNL,LUNS,LUNN
      COMMON /MEMXXX/ NIM,NIM1,NIM2,NIMMAX
      COMMON /MISXXX/ INCMSK,INTMSK,INCWT,LOGON,IPHYLP
      COMMON /PARXXX/ NCHAR,MCHAR,NITEM,MITEM,MS,LENITM,NBITS,MINCMP,
     *  MATCHO
 
C     NUMBER OF CONTROL PHRASES - MUST AGREE WITH SUBR. CONTRL.
      PARAMETER (NCON=16)                                                     =*
 
      DIMENSION JDIR(NCON),W(LW),IW(LW),IPARAM(NPARAM)
 
C     SET DEFAULT VALUES OF PARAMETERS.
 
      DO 40 I = 1, NCON
        JDIR(I) = 0
   40   CONTINUE
 
 
C--READ PARAMETERS FROM DIRECTIVES FILE.
 
      IEOF = 0
      CALL RDBUF
 
   50 IF (IEOF.NE.0) GOTO 5000
      CALL SKDELW
      IF (IEOF.NE.0) GOTO 5000
        CALL CONTRL (ICPH, JE)
        JBUF = JE
        IF (ICPH.GT.0) GOTO 60
          CALL ERROR (JBUF, 'INVALID DIRECTIVE.%')
          GOTO 50
 
   60 JDIR(ICPH) = 1
 
      GOTO (100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,
     *      1400,1500,1600) ICPH
 
C-    HEADING.
  100 CALL HEADER
      GOTO 50
 
C-    MAXIMUM ITEMS IN MEMORY.
  200 CALL RDINT (NIMMAX)
      GOTO 50
 
C-    LISTING FILE.
  300 LUNTYP = 5
      CALL GETFLO (LUNTYP, IERR)
      CALL PROGID (LUNL)
      IF (IERR.NE.0) GOTO 9000
      GOTO 50
 
C-    ITEMS FILE.
  400 IF (LUNT.GT.0) THEN
        CALL ERROR (JBUF, 'ITEMS FILE ALREADY OPEN.%')
        GOTO 50
      ENDIF
      LUNTYP = 2
      CALL GETFLI (LUNTYP, IERR)
      IF (IERR.NE.0) GOTO 9000
      CALL ALLOC1 (LW, IPARAM, NPARAM)
      GOTO 50
 
C-    OUTPUT FILE.
  500 LUNTYP = 3
      CALL GETFLO (LUNTYP, IERR)
      IF (IERR.NE.0) GOTO 9000
      GOTO 50
 
C-    INCLUDE CHARACTERS.
  600 IF (JDIR(7).NE.0) THEN
        CALL ERROR (JBUF, 'EQUIVALENT DIRECTIVE ALREADY USED.%')
      ELSE
        IF (LUNT.LT.0) THEN
          CALL OPNDEF (2)
          CALL ALLOC1 (LW, IPARAM, NPARAM)
        ENDIF
        CALL RDMSK (1, IW(IIMC), NCHAR, MCHAR)
        IF (MCHAR.LE.0) CALL FERROR ('ALL CHARACTERS EXCLUDED.%')
        INCMSK = 1
      ENDIF
      GOTO 50
 
C-    EXCLUDE CHARACTERS.
  700 IF (JDIR(6).NE.0) THEN
        CALL ERROR (JBUF, 'EQUIVALENT DIRECTIVE ALREADY USED.%')
      ELSE
        IF (LUNT.LT.0) THEN
          CALL OPNDEF (2)
          CALL ALLOC1 (LW, IPARAM, NPARAM)
        ENDIF
        CALL RDMSK (0, IW(IIMC), NCHAR, MCHAR)
        IF (MCHAR.LE.0) CALL FERROR ('ALL CHARACTERS EXCLUDED.%')
        INCMSK = 1
      ENDIF
      GOTO 50
 
C-    INCLUDE ITEMS.
  800 IF (JDIR(9).NE.0) THEN
        CALL ERROR (JBUF, 'EQUIVALENT DIRECTIVE ALREADY USED.%')
      ELSE
        IF (LUNT.LT.0) THEN
          CALL OPNDEF (2)
          CALL ALLOC1 (LW, IPARAM, NPARAM)
        ENDIF
        CALL RDMSK (1, IW(IIMI), NITEM, MITEM)
        IF (MITEM.LE.0) CALL FERROR ('ALL ITEMS EXCLUDED.%')
        INTMSK = 1
      ENDIF
      GOTO 50
 
C-    EXCLUDE ITEMS.
  900 IF (JDIR(8).NE.0) THEN
        CALL ERROR (JBUF, 'EQUIVALENT DIRECTIVE ALREADY USED.%')
      ELSE
        IF (LUNT.LT.0) THEN
          CALL OPNDEF (2)
          CALL ALLOC1 (LW, IPARAM, NPARAM)
        ENDIF
        CALL RDMSK (0, IW(IIMI), NITEM, MITEM)
        IF (MITEM.LE.0) CALL FERROR ('ALL ITEMS EXCLUDED.%')
        INTMSK = 1
      ENDIF
      GOTO 50
 
C-    NAMES FILE.
 1000 LUNTYP = 7
      CALL GETFLO (LUNTYP, IERR)
      IF (IERR.NE.0) GOTO 9000
      GOTO 50
 
C-    COMMENT.
 1100 GOTO 50
 
C-    LOG.
 1200 LOGON = 1
      GOTO 50
 
C-    MATCH OVERLAP.
 1300 MATCHO = 1
      GOTO 50
 
C-    MINIMUM NUMBER OF COMPARISONS.
 1400 CALL RDINT (MINCMP)
      GOTO 50
 
C-    CHARACTER WEIGHTS.
 1500 IF (LUNT.LT.0) THEN
        CALL OPNDEF (2)
        CALL ALLOC1 (LW, IPARAM, NPARAM)
      ENDIF
      CALL SETRA (W(IWTC), NCHAR, 1.)
      CALL CIREAL (W(IWTC), NCHAR, 0.03125, 32.)
      INCWT = 1
      GOTO 50

C-    PHYLIP FORMAT.
 1600 IPHYLP = 1
      GOTO 50
 
C     READ FIRST RECORD OF ITEMS FILE, IF NOT ALREADY OPENED.
 5000 IF (LUNT.LT.0) THEN
        CALL OPNDEF (2)
        CALL ALLOC1 (LW, IPARAM, NPARAM)
      ENDIF
 
      GOTO 9100
 
 9000 CALL UCLOSE
 
 9100 RETURN
      END
      SUBROUTINE RDINT (NUM)                                                INOU
C
C* REVISED 14/2/86.
C* READS A SINGLE INTEGER VALUE.
C
C  NUM RETURNS THE VALUE.
C
C  NEW RECORDS ARE READ IF REQUIRED.
C  ON EXIT, JBUF IS POSITIONED AFTER THE NUMBER, OR, IF THE NUMBER
C    WAS MISSING, AT THE START OF THE NEXT STAR-WORD.
C
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
C
C     LOCATE AND DECODE WORD.
      CALL NEXTWD (JE)
      IF (IEOF.NE.0) GOTO 100
      IF (IBUF(JBUF:JBUF).EQ.STAR) GOTO 100
      CALL IDKOD (NUM, IBUF(JBUF:JE-1), IERR)
      IF (IERR.NE.0) CALL ERROR (JBUF, 'INVALID INTEGER.%')
      JBUF = JE
  100 RETURN
      END
      SUBROUTINE RDITEM (ITMS, LITMS, ISTART, NO, IMI, ITPTR, LASTI,        INOU
     * NITMS)
 
C  REVISED 17/2/87.
C  READS SELECTED ITEMS INTO MEMORY.
 
C  ITM RECEIVES SPACE TO STORE THE ITEMS.
C  LITMS RECEIVES THE LENGTH OF ITMS.
C  ISTART RECEIVES THE NUMBER OF THE FIRST ITEM TO BE READ.
C  NO RECEIVES THE NUMBER OF ITEMS TO BE READ.
C  IMI RECEIVES THE ITEM MASK.
C  ITPTR RECEIVES THE RECORD ADDRESSES OF THE ITEMS ON FILE.
C  LASTI RETURNS THE NUMBER OF THE LAST ITEM READ.
C  NITM RETURNS THE NUMBER OF ITEMS READ (CAN BE LESS THAN NO WHEN
C    THE END OF THE ITEMS IS REACHED).
 
      COMMON /DAPXXX/ IRECDA,LRECDA
      COMMON /LUNXXX/ LUNI,LUNT,LUNO,LUNE,LUNL,LUNS,LUNN
      COMMON /PARXXX/ NCHAR,MCHAR,NITEM,MITEM,MS,LENITM,NBITS,MINCMP,
     *  MATCHO
 
      DIMENSION ITMS(LITMS),IMI(NITEM),ITPTR(NITEM)
 
      I = 0
      II = 1
      NITMS = 0
 
    5 ITNUM = ISTART + II - 1
        IF (ITNUM.GT.NITEM) GOTO 50
        IF (IMI(ITNUM).EQ.0) GOTO 20
        NITMS = NITMS + 1
        IRECDA = ITPTR(ITNUM) + 1
        LASTI = ITNUM
        NN = LENITM
 
   10   IF (NN.LE.0) GOTO 20
          IREAD = MIN(NN,LRECDA)
          READ (LUNT, REC=IRECDA) (ITMS(J),J=I+1,I+IREAD)
          I = I + IREAD
          IRECDA = IRECDA + 1
          NN = NN - IREAD
        GOTO 10
 
   20   II = II + 1
      IF (NITMS.LT.NO) GOTO 5
 
   50 RETURN
      END
      SUBROUTINE RDKOD (X, IBF, IERR)                                       INOU
 
C* REVISED 24/7/87.
C* DECODES A REAL VALUE.
 
      CHARACTER*(*) IBF
      CHARACTER*10 FMT
 
      IERR = 0
      L = LEN (IBF)
 
      WRITE (FMT, 10) L
   10 FORMAT ('(F', I4, '.0)')
      READ (IBF, FMT, ERR=20) X
      GOTO 30
 
   20 IERR = 1
 
   30 RETURN
      END
      SUBROUTINE RDMSK (ISET, MSK, LMSK, INCL)                              INOU
C
C* REVISED 11/6/85.
C* READS A MASK.
C
C  ISET RECEIVES A FLAG INDICATING THE VALUES TO BE SET IN THE MASK.
C    POSITIVE - 1 SET. ZERO - 0 SET. NEGATIVE - FIRST VALUE OF EACH
C    RANGE SET.
C  MSK RETURNS THE MASK (SEE BELOW).
C  LMSK RECEIVES THE LENGTH OF MSK.
C  INCL RETURNS THE NUMBER OF ELEMENTS OF MSK WITH NON-ZERO VALUES.
C
C  THE INPUT TAKES THE FORM N1-M1 N2-M2 ... AND IS TERMINATED BY A
C    STAR-WORD. THE -M1, -M2, ... ARE OPTIONAL.
C  MSK(N1) TO MSK(M1), ETC., ARE SET TO THE VALUE SPECIFIED BY ISET.
C    THE REST ARE SET TO 0 IF ISET IS NON-ZERO, OR 1 IF ISET IS ZERO.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR OF THE STAR-WORD.
C
      DIMENSION MSK(LMSK)
C
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
C
      JSET = MIN0(1,IABS(ISET))
      JPRE = 1 - JSET
      CALL SETIA (MSK, LMSK, JPRE)
C
C-    GET NEXT WORD AND CHECK FOR STAR.
   20 CALL NEXTWD (JE)
        IF (IEOF.NE.0) GOTO 1000
        IF (IBUF(JBUF:JBUF).EQ.STAR) GOTO 1000
C
C-      DECODE RANGE.
        CALL DERNG (IB, IE, LMSK, JBUF, JE)
        IF (IB.LE.0) GOTO 300
C
C-      SET VALUES.
        IF (ISET.LT.0) JSET = IB
        DO 150 I = IB, IE
          IF (MSK(I).NE.JPRE) GOTO 200
  150     MSK(I) = JSET
        GOTO 300
C
C-      ERROR MESSAGE.
  200   CALL ERROR (JBUF, 'VALUE ALREADY SPECIFIED.%')
C
C-      PREPARE FOR NEXT WORD.
  300   JBUF = JE
        GOTO 20
C
C-    COUNT NUMBER OF NON-ZERO VALUES.
 1000 INCL = NONZER(MSK,LMSK)
      RETURN
      END
      SUBROUTINE RDREAL (X)                                                 INOU
C
C* REVISED 14/2/86.
C* READS A SINGLE REAL VALUE.
C
C  X RETURNS THE VALUE.
C
C  NEW RECORDS ARE READ IF REQUIRED.
C  ON EXIT, JBUF IS POSITIONED AFTER THE NUMBER, OR, IF THE NUMBER
C    WAS MISSING, AT THE START OF THE NEXT STAR-WORD.
C
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
C
C     LOCATE AND DECODE WORD.
      CALL NEXTWD (JE)
      IF (IEOF.NE.0) GOTO 40
      IF (IBUF(JBUF:JBUF).EQ.STAR) GOTO 40
      CALL RDKOD (X, IBUF(JBUF:JE-1), IERR)
      IF (IERR.NE.0) CALL ERROR (JBUF, 'INVALID REAL NUMBER.%')
      JBUF = JE
C
   40 RETURN
      END
      SUBROUTINE RDSPEC (IPARAM, NPARAM, IMC, NSTAT, ITYPC, WTC,            INOU
     *  ICPTW, ICPTB, IMI, ITPTR, LNAME)
 
C* REVISED 21/7/87.
C* READS DATASET SPECIFICATIONS.
 
C  IPARAM RECEIVES THE RECORD POINTERS.
C  NPARAM RECEIVES THE LENGTH OF IPARAM.
C  IMC RETURNS THE CHARACTER MASK.
C  NSTAT RETURNS THE NUMBERS OF STATES.
C  ITYPC RETURNS THE CHARACTER TYPES.
C  WTC RETURNS THE CHARACTER WEIGHTS.
C  ICPTW RETURNS THE CHARACTER WORD POINTERS.
C  ICPTB RETURNS THE CHARACTER BIT OFFSETS.
C  IMI RETURNS THE ITEM MASK.
C  ITPTR RETURNS THE RECORD ADDRESSES OF THE ITEMS.
C  LNAME RETURNS THE LENGTHS OF THE ITEM NAMES.
 
      COMMON /LUNXXX/ LUNI,LUNT,LUNO,LUNE,LUNL,LUNS,LUNN
      COMMON /MISXXX/ INCMSK,INTMSK,INCWT,LOGON,IPHYLP
      COMMON /PARXXX/ NCHAR,MCHAR,NITEM,MITEM,MS,LENITM,NBITS,MINCMP,
     *  MATCHO
 
      DIMENSION IPARAM(NPARAM),IMC(NCHAR),NSTAT(NCHAR),ITYPC(NCHAR),
     * WTC(NCHAR),ICPTW(NCHAR),ICPTB(NCHAR),
     * IMI(NITEM),ITPTR(NITEM),LNAME(NITEM)
 
      CALL RDDAI (ITYPC, NCHAR, IPARAM(10), LUNT)
      CALL RDDAI (NSTAT, NCHAR, IPARAM(11), LUNT)
      IF (INCMSK.LE.0) CALL RDDAI (IMC, NCHAR, IPARAM(12), LUNT)
      IF (INCWT.LE.0) CALL RDDAR (WTC, NCHAR, IPARAM(13), LUNT)
      CALL RDDAI (ICPTW, NCHAR, IPARAM(14), LUNT)
      CALL RDDAI (ICPTB, NCHAR, IPARAM(15), LUNT)
      IF (INTMSK.LE.0) CALL RDDAI (IMI, NITEM, IPARAM(16), LUNT)
      CALL RDDAI (ITPTR, NITEM, IPARAM(17), LUNT)
      CALL RDDAI (LNAME, NITEM, IPARAM(18), LUNT)
 
      RETURN
      END
      FUNCTION   RELIN(LR)                                                  INOU
 
C* REVISED 6/7/87.
C* RETURNS THE VALUE OF A REAL FROM THE INTEGER LOCATION LR.
 
      EQUIVALENCE (VS,LS)
 
      LS = LR
      RELIN = VS
 
      RETURN
      END
      SUBROUTINE SETIA (IA, N, IVAL)                                        INOU
C
C  REVISED 7/6/85.
C  SETS ELEMENTS OF AN INTEGER ARRAY TO A GIVEN VALUE.
C
      DIMENSION IA(N)
 
      DO 10 I = 1, N
        IA(I) = IVAL
   10   CONTINUE
C
      RETURN
      END
      SUBROUTINE SETLUN (FSPEC, LUN, LUNTYP)                                INOU
 
C* REVISED 24/7/87.
C* SETS ATTRIBUTES OF A NEW LOGICAL UNIT.
 
C  FSPEC RECEIVES THE FILE SPECIFICATION.
C  LUN RECEIVES THE LOGICAL UNIT.
C  LUNTYP RECEIVES THE TYPE OF THE FILE.
 
      COMMON /LUFXXX/ FNAME(10),LFNAME(10)
        CHARACTER FNAME*30
      COMMON /LUNXXX/ LUNI,LUNT,LUNO,LUNE,LUNL,LUNS,LUNN
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(8),
     *                LUNUSE(12),LUNREC(12),LUNPAG(12)
 
      CHARACTER*60 FSPEC
      DIMENSION LU(7)                                                         =*
      EQUIVALENCE (LU(1),LUNI)
 
      CALL EXNAME (FSPEC, FNAME(LUN))
      LFNAME(LUN) = LSTRB(FNAME(LUN))
      LUNUSE(LUN) = LUNCOM(LUNTYP)
      LU(LUNTYP) = LUN
      IF (LUNTYP.EQ.4.OR.LUNTYP.EQ.5) LUNPAG(LUN) = 1
 
      RETURN
      END
      SUBROUTINE SETRA (A, N, VAL)                                          INOU
 
C  REVISED 20/1/87.
C  SETS THE ELEMENTS OF AN ARRAY TO A GIVEN VALUE.
 
C  A RECEIVES AND RETURNS THE ARRAY.
C  N RECEIVES THE LENGTH OF A.
C  VAL RECEIVES THE VALUE.
 
      DIMENSION A(N)
 
      DO 10 I = 1, N
        A(I) = VAL
   10   CONTINUE
 
      RETURN
      END
      SUBROUTINE SKB                                                        INOU
 
C  REVISED 4/8/87.
C  SKIPS TO THE FIRST BLANK SYMBOL ON CURRENT LINE.
 
C  ON EXIT, JBUF IS AT THE BLANK SYMBOL.
 
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
 
      J = INDEX (IBUF(JBUF:JEDAT), BLANK)
      JBUF = J + JBUF - 1
      RETURN
      END
      SUBROUTINE SKDELW                                                     INOU
C
C* REVISED 27/4/87.
C* SKIPS TO THE START OF THE NEXT WORD STARTING WITH A STAR.
C
C
C  THE DELIMITER MAY BE AT THE CURRENT POSITION OF JBUF ON ENTRY.
C  NEW RECORDS ARE READ IF REQUIRED.
C  ON EXIT, JBUF IS POSITIONED AT THE DELIMITER.
C
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
C
C     MAXIMUM NUMBER OF WORDS TO BE SKIPPED.
      PARAMETER (MAXWSK=200)
C
      NWSK = 0
      IF (JBUF.EQ.1) GOTO 100
      IF (IBUF(JBUF-1:JBUF-1).NE.BLANK) CALL SKB
C
  100 CALL SKNONB
      IF (IEOF.NE.0) GOTO 200
        IF (IBUF(JBUF:JBUF).EQ.STAR) GOTO 200
        CALL SKB
        NWSK = NWSK + 1
        IF (NWSK.GT.MAXWSK) GOTO 300
        GOTO 100
C
  200 RETURN
C
  300 CALL FERROR ('NO LEGAL DELIMITER FOUND.%')
      END
      SUBROUTINE SKNONB                                                     INOU
 
C  REVISED 4/8/87.
C  SKIPS TO THE FIRST NON-BLANK CHARACTER.
 
C  NEW RECORDS ARE READ IF REQUIRED.
C  ON EXIT, JBUF IS AT THE NON-BLANK CHARACTER.
 
C  4/8/87. LOOP CHANGED TO LOCAL VARIABLE BECAUSE OF BUG IN
C    MS FORTRAN 4.0.
 
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,IFOPEN
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *                COMMA,COLON
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON
 
      I = JBUF
   10 IF (IBUF(I:I).NE.BLANK) GOTO 20
        I = I + 1
        IF (I.GT.JEDAT) THEN
          CALL RDBUF
          I = JBUF
          IF (IEOF.NE.0) GOTO 20
        ENDIF
      GOTO 10
 
   20 JBUF = I
 
      RETURN
      END
      SUBROUTINE UCLOSE                                                     INOU
 
C* REVISED 22/9/87.
C* CLOSES FILES, LISTS NAMES OF OUTPUT FILES, AND STOPS.
 
C  NOTE. LUNPAG IS USED AS WORKING SPACE FOR FLAGS, AS ITS ORIGINAL
C    CONTENTS ARE NO LONGER NEEDED. 0 - DO NOT CLOSE FILE.
C    1 - CLOSE. 2 - CLOSE, LIST AS NON-EMPTY OUTPUT FILE.
C    3 - CLOSE AND DELETE. 4 - CLOSE AND DELETE, LIST AS EMPTY
C    OUTPUT FILE.
 
      LOGICAL*4 O,N,E
      CHARACTER*50 MBUF
 
      COMMON /ERRXXX/ IERR
      COMMON /LUFXXX/ FNAME(10),LFNAME(10)
        CHARACTER FNAME*30
      COMMON /LUNXXX/ LUNI,LUNT,LUNO,LUNE,LUNL,LUNS,LUNN
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(8),
     *                LUNUSE(12),LUNREC(12),LUNPAG(12)
      COMMON /LUTXXX/ LUNTI,LUNTO
 
   10 FORMAT (3X, A, '%')
 
      IF (IERR.NE.0) CALL MESS ('ABNORMAL TERMINATION.%')
 
C     WHETHER THERE ARE NON-EMPTY AND EMPTY OUTPUT FILES TO BE LISTED.
      N = .FALSE.
      E = .FALSE.
 
C--   SET FLAGS TO SHOW HOW EACH UNIT MUST BE TREATED.
      DO 100 LUN = 1, NUN
        L = LUNUSE(LUN)
 
C-      UNUSED OR TERMINAL.
        IF (L.LE.0 .OR. LUN.EQ.LUNTO .OR. LUN.EQ.LUNTI) THEN
          LUNPAG(LUN) = 0
 
C-      OUTPUT.
        ELSEIF (L.EQ.3 .OR. L.EQ.4 .OR. L.EQ.5 .OR. L.EQ.7) THEN
          IF (LUNREC(LUN).GT.0) THEN
            IF (L.EQ.9 .AND. IERR.GT.0) THEN
              LUNPAG(LUN) = 3
            ELSE
              LUNPAG(LUN) = 2
              N = .TRUE.
            ENDIF
          ELSE
            IF (IERR.GT.0) THEN
              LUNPAG(LUN) = 3
            ELSE
              LUNPAG(LUN) = 4
              E = .TRUE.
            ENDIF
          ENDIF
 
C-      SCRATCH.
        ELSEIF (L.EQ.6) THEN
          LUNPAG(LUN) = 3
 
C-      INPUT.
        ELSE
          LUNPAG(LUN) = 1
        ENDIF
 
  100 CONTINUE
 
C--   PRINT NAMES OF NON-EMPTY OUTPUT FILES.
      IF (N) THEN
        CALL MESS (' %')
        CALL MESS ('OUTPUT FILES - %')
        DO 200 LUN = 1, NUN
          IF (LUNPAG(LUN).EQ.2) THEN
            WRITE (MBUF,10) FNAME(LUN)(1:LFNAME(LUN))
            CALL MESS (MBUF)
          ENDIF
  200   CONTINUE
      ENDIF
 
C--   PRINT NAMES OF EMPTY OUTPUT FILES.
      IF (E) THEN
        CALL MESS (' %')
        CALL MESS ('OUTPUT FILES SPECIFIED BUT NOT USED -%')
        DO 300 LUN = 1, NUN
          IF (LUNPAG(LUN).EQ.4) THEN
            WRITE (MBUF,10) FNAME(LUN)(1:LFNAME(LUN))
            CALL MESS (MBUF)
          ENDIF
  300   CONTINUE
      ENDIF
 
C--   CLOSE FILES.
      DO 400 LUN = 1, NUN
        IF (LUNPAG(LUN).LE.0) GOTO 400
        INQUIRE (UNIT=LUN, OPENED=O)
        IF (.NOT.O) GOTO 400
        IF (LUNPAG(LUN).LE.2) THEN
          CLOSE (UNIT=LUN)
        ELSE
          CLOSE (UNIT=LUN, STATUS='DELETE')
        ENDIF
  400 CONTINUE
 
      STOP ' '
      END
      SUBROUTINE WRTREC (STR, LUN)                                          INOU
 
C* REVISED 24/7/87.
C* OUTPUTS A RECORD.
 
C  STR RECEIVES THE OUTPUT STRING.
C  LUN RECEIVES THE LOGICAL UNIT.
 
      CHARACTER*(*) STR
 
      CALL LCOUNT (LUN)
      CALL WREC (STR, LUN)
 
      RETURN
      END
