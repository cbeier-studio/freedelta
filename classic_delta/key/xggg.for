      PROGRAM    KEY                                                        XSSS
C* REVISED 11-MAR-93.
C* FORMS IDENTIFICATION KEYS.

      CHARACTER PIDP*230
      PARAMETER (PIDP = '|KEY version 2.12 Win32-gfortran||'//
     *'M.J. Dallwitz and T.A. Paine||'//
     *'CSIRO Division of Entomology, '//
     *'GPO Box 1700, Canberra, ACT 2601, Australia|'//
     *'Phone +61 2 6246 4075. '//
     *'Fax +61 2 6246 4000. Email delta@ento.csiro.au||%')
 
      PARAMETER (LDP = 600000)
      PARAMETER (NCINWD=4)
      PARAMETER (LDCP=LDP*NCINWD)

      COMMON /NCHXXX/ NCHAR
      COMMON /PIDXXX/ PID
        CHARACTER*230 PID
 
      INTEGER D(LDP)
      REAL RD(LDP)
      CHARACTER*1 CSTR(LDCP)
      EQUIVALENCE (D,RD,CSTR)

C--   INITIALISE.
      PID = PIDP
      LD = LDP
      LDC = LDCP
      NCHAR = NCINWD

      CALL KEY1 (D, RD, CSTR, LD, LDC)

      END
      SUBROUTINE MEM (CSTR, LD, LDC, IWST, ICWST)                           XSSS
 
C  REVISED 11-DEC-90.
C  DUMMY ROUTINE TO SATISFY MS-DOS MEMORY ALLOCATION REQUEST.
 
      CHARACTER*1 CSTR(LDC)
 
      IWST = 1
      ICWST = 1

      RETURN
      END
      SUBROUTINE BADBUF (IPOINT, BUF, N)                                    XSSSMMM
 
C  REVISED 1-OCT-92.
C  TRANSLATES AND OUTPUTS BUFFER CONTAINING CONTROL CHARACTERS.
 
C  IPOINT RECEIVES AND RETURNS A POINTER INTO THE BUFFER.
C  BUF RECEIVES THE BUFFER.
C  N RECEIVES THE NUMBER OF CHARACTERS IN THE BUFFER
 
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
 
      CHARACTER BUF*(*)
 
C     TMP MUST BE SAME LENGTH AS IBUF IN /INPBUF/                             =*
      CHARACTER TMP*121                                                       =*
      PARAMETER (LTMP=121)                                                    =*
 
      I = 1
      J = 1
      TMP = ' '
      DO WHILE (I.LE.N)
        IF (ICHAR(BUF(I:I)).LT.32)  THEN
          TMP(J:J) = UPAROW
          IF (J+1.GT.LTMP)  GOTO 10
          J = J + 1
          TMP(J:J) = CHAR(ICHAR(BUF(I:I))+64)
          IF (IPOINT.GT.I)  IPOINT = IPOINT + 1
        ELSE
          TMP(J:J) = BUF(I:I)
        ENDIF
        I = I + 1
        J = J + 1
        IF (J.GT.LTMP)  GOTO 10
      END DO
 
   10 CALL EMESS (TMP(1:J))
 
      END
      SUBROUTINE EXNAME (FSPEC, FNAME)                                      XSSS

C* REVISED 19/8/87.
C* EXTRACTS FILE NAME AND TYPE FROM FILE SPECIFICATION.

C  ALSO, IF THE SPECIFICATION DOES NOT CONTAIN A FILE TYPE, AND THE
C    DEFAULT FILE TYPE (AS INSERTED BY THE COMPILER) IS NOT NULL, A NULL
C    TYPE (I.E. A DOT) IS EXPLICITLY INSERTED IN THE SPECIFICATION.

C  FSPEC RECEIVES AND RETURNS A FILE SPECIFICATION.
C    IN THIS VERSION, THE RETURNED FILE SPECIFICATION IS UNALTERED.
C  FNAME RETURNS THE FILE NAME AND TYPE (EXTENSION), I.E. THE FILE
C    SPECIFICATION LESS ANY DISC NAME AND DIRECTORY NAME (PATH).

      CHARACTER*(*) FSPEC, FNAME

C     FIND END OF SPECIFICATION.
      LFS = LEN(FSPEC)
      DO 10 I = 1, LFS
        IF (FSPEC(I:I).EQ.' ') GOTO 20
   10 CONTINUE
   20 IES = I - 1
      IEN = IES

C     FIND START OF NAME.
      DO 30 I = IES, 1, -1
        IF (FSPEC(I:I).EQ.':' .OR. FSPEC(I:I).EQ.'/') GOTO 40
   30 CONTINUE
   40 IBN = I + 1

C     STORE NAME.
   80 IF (FSPEC(IEN:IEN).EQ.'.') IEN = IEN - 1
      FNAME = ' '
      IF (IBN.LE.IEN) FNAME = FSPEC(IBN:IEN)

      RETURN
      END
      SUBROUTINE GETTIME (TIM, DAT)                                         XSSS

C* REVISED 19/8/87.
C* GETS THE TIME AND DATE.

      CHARACTER*10 TIM,DAT

      character*25 test

      test = ctime(time8())
      tim = test(12:19)
      dat = test(9:10) // '-' // test(5:7) // '-' // test(23:24)
!      CALL TIME (TIM)
!      TIM(9:10) = ' '
!      CALL DATE (DAT)
!      DAT(10:10) = ' '

      RETURN
      END
      SUBROUTINE INITF (LUNE, LUNI, LUNTI, LUNTO, LUNUSE, NUN)              XSSS

C* REVISED 19/8/87.
C* INITIALIZES SYSTEM-DEPENDENT INPUT/OUTPUT.

C  LUNE RETURNS THE ERROR LOGICAL UNIT.
C  LUNI RETURNS THE INITIAL INPUT LOGICAL UNIT.
C  LUNTI RETURNS THE TERMINAL INPUT LOGICAL UNIT.
C  LUNTO RETURNS THE TERMINAL OUTPUT LOGICAL UNIT.
C  LUNUSE RETURNS FLAGS INDICATING UNAVAILABLE LOGICAL UNITS (SEE
C    BELOW).
C  NUN RECEIVES THE DIMENSION OF LUNUSE.

C  THIS SUBR. MUST:
C  (1) SET LUNUSE(LUN) TO 0 FOR ANY LOGICAL UNITS WHOSE USE
C      IS RESTRICTED BY THE OPERATING SYSTEM.
C  (2) IF TERMINAL INPUT/OUTPUT IS REQUIRED, SET LUNTI AND LUNTO
C      TO THE REQUIRED VALUES, AND OPEN THESE UNITS IF NECESSARY.
C  (3) OPEN A UNIT FOR INITIAL OUTPUT OF ERROR MESSAGES, AND SET
C      LUNE TO THE NUMBER OF THIS UNIT.
C  (4) OPEN A UNIT FOR INITIAL INPUT OF DIRECTIVES, AND SET
C      LUNI TO THE NUMBER OF THIS UNIT.

      DIMENSION LUNUSE(NUN)
      CHARACTER FNAME*60,MESS*20
      LOGICAL*4 E

C-    SET LUNUSE(LUN) TO 0 FOR ANY UNUSABLE LOGICAL UNITS.
      CONTINUE

C-    OPEN TERMINAL INPUT AND OUTPUT UNITS.
C     NOTE. ACTUAL I/O IS DONE ON UNIT 0. THE VARIABLES ARE SET TO 1 TO
C     AVOID ARRAY-BOUNDS ERRORS (MS-FORTRAN DOES NOT ALLOW SUBSCRIPT 0).
      LUNTI = 5
      LUNTO = 6

C-    SET ERROR UNIT.
      LUNE = LUNTO

C-    OPEN MAIN DIRECTIVES FILE.
      LUNI = 2

C     GET THE COMMAND LINE.
      IF (IARGC().GT.0) THEN
        CALL GETARG(1, FNAME) 

C     USE DEFAULT FILE IF IT EXISTS, ELSE USE NONE.
      ELSE
        FNAME = 'key'
        INQUIRE (FILE=FNAME, EXIST=E)
        IF (.NOT.E) GOTO 100
      ENDIF

C     CHECK FOR EXISTENCE OF THE FILE, AND OPEN IT.
      INQUIRE (FILE=FNAME, EXIST=E)
      IF (.NOT.E) GOTO 210
      OPEN (UNIT=LUNI, FILE=FNAME, STATUS='OLD', ERR=220)
C-
  100 RETURN

C-    FATAL ERRORS.
  210 MESS = ' does not exist.'
      GOTO 290

  220 MESS = ' is not accessible.'

  290 DO 292 I = 60, 2, -1
       IF (FNAME(I:I).NE.' ') GOTO 294
  292 CONTINUE

  294 WRITE (0, *) '****** File ', FNAME(1:I), MESS

  300 STOP ' '
      END
      SUBROUTINE PROGRS (N)                                                 XSSS
 
C* REVISED 29-JUN-92.
C* DUMMY ROUTINE TO MATCH DOS AND OS/2 VERSIONS.

      RETURN
      END
      SUBROUTINE RREC (IBUF, LBUF, LREC, LUN)                               XSSS

C* REVISED 19/8/87.
C* READS AN INPUT RECORD.

C  IBUF RETURNS THE RECORD.
C  LBUF RECEIVES THE AVAILABLE LENGTH OF IBUF. (ACTUAL LENGTH MUST BE
C    AT LEAST LBUF+1.)
C  LREC RETURNS THE RECORD LENGTH. IF EOF, LREC IS SET TO -1.
C  LUN RECEIVES THE LOGICAL UNIT.

      CHARACTER*(*) IBUF

      PARAMETER (ICR=13)
      READ (LUN, 10, END=20) IBUF
   10 FORMAT (A)
      LREC = LEN_TRIM(IBUF)
      IF (LREC.LE.0) GO TO 100
      IF (ICHAR(IBUF(LREC:LREC)).EQ.ICR) LREC = LREC - 1

      DO 15 I = 1, LREC
        IF (ICHAR(IBUF(I:I)).EQ.ICR)  IBUF(I:I) = ' '
   15 CONTINUE
      GO TO 100

   20 LREC = -1

  100 RETURN
      END
      SUBROUTINE UOPEN (LUN, LUNTYP, FSPEC, LRECDA, IERR)                   XSSS

C* REVISED 26-MAR-99.
C* OPENS A FILE.

C  LUN RECEIVES THE LOGICAL UNIT NUMBER.
C  LUNTYP RECEIVES THE TYPE OF LUN.
C  FSPEC RECEIVES THE FILE SPECIFICATION.
C  LRECDA RECEIVES THE LENGTH OF DIRECT-ACCESS RECORDS, IN WORDS.
C  IERR RETURNS 1 IF ERROR, 0 OTHERWISE.

      CHARACTER*(*) FSPEC

      IERR = 0

      IF (LUNTYP.EQ.1) THEN
        OPEN (UNIT=LUN, FILE=FSPEC, ERR=100, STATUS='OLD')
      ELSEIF (LUNTYP.EQ.2 .OR. LUNTYP.EQ.3) THEN
        OPEN (UNIT=LUN, FILE=FSPEC, ERR=100, STATUS='OLD',
     *  FORM='UNFORMATTED', ACCESS='DIRECT', RECL=LRECDA*4)
      ELSEIF (LUNTYP.EQ.4 .OR. LUNTYP.EQ.5 .OR. LUNTYP.EQ.6) THEN
        OPEN (UNIT=LUN, FILE=FSPEC, ERR=100,
     *  STATUS='UNKNOWN')
      ELSEIF (LUNTYP.EQ.7) THEN
        OPEN (UNIT=LUN, FILE=FSPEC, ERR=100, STATUS='UNKNOWN',
     *  FORM='UNFORMATTED', ACCESS='DIRECT', RECL=LRECDA*4)
      ELSEIF (LUNTYP.EQ.10)  THEN
        OPEN (UNIT=LUN, FILE=FSPEC, STATUS='UNKNOWN', ERR=100,
     *  FORM='UNFORMATTED', RECL=LRECDA)
      ENDIF

      RETURN

  100 IERR = 1

      RETURN
      END
C      CHARACTER*1 FUNCTION UPCASE (CHR)                                     XSSS
C
C* REVISED 14/2/92
C* CONVERTS SINGLE CHARACTER TO UPPERCASE
C
C      CHARACTER*1 CHR
C      IF (CHR.GE.'a'.AND.ICHR.LE.'z') THEN
C        UPCASE = CHAR (ICHAR(CHR) - 32)
C      ELSE
C        UPCASE = CHR
C      ENDIF
C
C      RETURN
C      END
      SUBROUTINE WREC (STR, LUN)                                            XSSS

C* REVISED 19/8/87.
C* WRITES A STRING ON A LOGICAL UNIT.

C  STR RECEIVES THE STRING.
C  LUN RECEIVES THE LOGICAL UNIT.

      COMMON /LUTXXX/ LUNTI,LUNTO

      CHARACTER*(*) STR

      WRITE (LUN, 20) STR
   20 FORMAT (A)

      RETURN
      END
      SUBROUTINE WRECB (STR, LUN)                                           XMMM

C* REVISED 26-MAR-99.
C* WRITES A STRING ON A LOGICAL UNIT IN BINARY MODE.

C  STR RECEIVES THE STRING.
C  LUN RECEIVES THE LOGICAL UNIT.

      COMMON /LUTXXX/ LUNTI,LUNTO
      COMMON /OUTXXX/ LFLAG

      CHARACTER*(*) STR

      IF (LUN.EQ.LUNTO) THEN
        WRITE (0, 10) STR
   10   FORMAT (1X, A)
        LFLAG = 1
      ELSE
      DO 20 K = 1, LEN(STR)
        CALL FPUTC(LUN, STR(K:K))
        CALL FPUTC(6, STR(K:K))
   20 CONTINUE
        call fputc(lun, char(13))
        CALL FPUTC(LUN, CHAR(10))
	  
!        WRITE (LUN) STR
      ENDIF

      RETURN
      END

