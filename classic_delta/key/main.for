      SUBROUTINE KEY1 (D, RD, CSTR, LD, LDC)                                MAIN

C* REVISED 24-FEB-99.
C* RECEIVES MAIN STORAGE ARRAYS.

C  23-MAY-91. IMPLEMENT 'PAGE LENGTH' DIRECTIVE. DEFAULT IS 0 (NO PAGING).
C  8-MAR-89. FIX BUG IN CLEARING DEPENDENCY FLAGS.
C  23-FEB-89. FIX BUG IN OUTPUT ON LUNL. N.B. DO NOT WRITE DIRECTLY ON
C    LUNL OR LUNE - GO THROUGH WRTREC, MESS, OR EMESS (THESE UNITS MAY
C    BE THE TERMINAL, WHICH IS TREATED SPECIALLY IN MS-DOS VERSION).
C  1-FEB-89. FIX DEPENDENCY BUG.
C  1-NOV-88. MODIFY CAP AND IGNOR FOR EXTENDED CHARACTER SET.
C  20-OCT-88. ADD RUN-TIME MEMORY ALLOCATION FOR MS-DOS. CHANGE
C    DEFAULT TO 'TREAT UNKNOWN AS VARIABLE'.
C  15/7/88. FIX ADDRESSING BUG IN SUBR. CLRNA.
C  22/6/88. SET VALUE OF ILAST TO MSTOR+1. (PARAMS)
C  18/4/88. REMOVE TYPSET WORD INSTRUCTION FROM PRESET CHARACTERS.
C  11/4/88. EOF BUF ON MS-DOS.
C  21/9/87. REWORD MATRIX DUMP OUTPUT.
C  2/9/87. REVISED HANDLING OF DEPENDENT CHARACTERS.
C  18/8/87. TIDY MACHINE-DEPENDENT CODE.
C  12/6/87. REMOVE SPECIAL CHARACTER HANDLING FOR MS FORTRAN 3.30.
C  13/4/87. DEFAULT VALUE OF RES CHANGED FROM 1.5 TO 0.
C  1/4/87. 'TYPSET STYLE' AND 'TYPSET TAB' DIRECTIVES ADDED.
C  26/3/87. 'MATRIX DUMP' DIRECTIVE ADDED.
C  9/3/87. SET LENGTH OF BLANK COMMON IN PARAMETER STATEMENT.
C  29/10/86. LENGTH OF TIM AND DAT CHANGED TO 10. COMMAND-LINE
C    INTERPRETATION ADDED TO MS-DOS VERSION.
C  21/10/86. 'DUMP' DIRECTIVE ADDED.
C  15/10/86. 'STOP AFTER COLUMN' DIRECTIVE ADDED.
C    'ALGORITHM' DIRECTIVE CHANGED TO 'ALLOW IMPROPER SUBGROUPS'.

C--STRUCTURE OF DATA FILES.

C  BOTH THE CHARACTERS AND ITEMS FILES (LUNC AND LUNT) ARE UNFORMATTED
C  DIRECT-ACCESS FILES. THE FIRST RECORD OF EACH FILE CONTAINS
C  INFORMATION WHICH IS USED TO ACCESS THE REMAINING DATA IN THE FILE.

C  THE FIRST RECORD OF THE CHARACTERS FILE CONTAINS 3 INTEGER VALUES -
C    1. THE NUMBER OF CHARACTERS.
C    2. RECORD ADDRESS OF THE NUMBERS OF STATES.
C    3. RECORD ADDRESS OF THE CHARACTER DESCRIPTIONS.

C  THE FIRST RECORD OF THE ITEMS FILE CONTAINS 11 INTEGER VALUES -
C    1. THE NUMBER OF ITEMS.
C    2. THE NUMBER OF CHARACTERS.
C    3. THE LENGTH (LCDEP) OF THE CHARACTER DEPENDENCY ARRAY.
C    4. RECORD ADDRESS OF THE HEADER TEXT.
C    5. RECORD ADDRESS OF THE CHARACTER MASK.
C    6. RECORD ADDRESS OF THE NUMBERS OF KEY STATES.
C    7. RECORD ADDRESS OF THE CHARACTER DEPENDENCIES.
C    8. RECORD ADDRESS OF THE CHARACTER RELIABILITIES.
C    9. RECORD ADDRESS OF THE ITEM MASK.
C    10. RECORD ADDRESS OF THE LENGTHS OF THE TAXON NAMES.
C    11. RECORD ADDRESS OF THE ITEM ABUNDANCES.

C--NOTES.                                                                     =/

C  CARDS REQUIRING SPECIAL ATTENTION WHEN THE PROGRAM IS ALTERED OR
C    IMPLEMENTED ON ANOTHER MACHINE ARE MARKED * (FOR CODE) OR /
C    (FOR COMMENTS) IN COLUMN 80. ON THESE CARDS, THE CONTENTS OF
C    OF COLUMNS 73-79 INDICATE THE ACTION REQUIRED:
C    =  MAY NEED ATTENTION IF PROGRAM IS ALTERED.

C  MOST VERSIONS USE SYSTEM ROUTINES TO GET THE TIME AND DATE.
C  INTEGER AND REAL VARIABLES MUST OCCUPY THE SAME NUMBER OF
C    COMPUTER WORDS.
C  4 SYMBOLS ARE STORED IN EACH INTEGER LOCATION.
C  CHARACTER VALUES MAY BE PRINTED AS NUMBERS INSTEAD
C    OF LETTERS BY CHANGING THE DATA STATEMENT IN  WRTKEY.

C  THE CODED DESCRIPTIONS OF THE TAXA ARE HELD IN THE FIRST PART OF
C    THE ARRAY D.
C    THE DATA IS ORGANIZED INTO ROWS (TAXA) AND COLUMNS
C    (FEATURES), AND IS STORED BY ROWS. EACH DATA ELEMENT OCCUPIES
C    31 BITS. THERE ARE NPACK ELEMENTS PER INTEGER LOCATION.                  =/
C    BIT 2 (THE SECOND BIT FROM THE LEFT) IS A FLAG INDICATING AN
C    UNSUITABLE OR A CONFIRMATORY FEATURE, BITS 3-10 CONTAIN THE FEATURE      =/
C    NUMBER, BIT 12 THE NOT-APPLICABLE FLAG,                                  =/
C    AND BITS 13-32 CONTAIN FLAGS INDICATING THE PRESENCE/ABSENCE OF          =/
C    STATES (THE STATE BITS ARE NUMBERED FROM RIGHT TO LEFT).
C    A MAXIMUM OF 20 STATES IS ALLOWED.                                       =/
C    (THE FEATURE NUMBER IS INITIALLY THE SAME AS THE COLUMN NUMBER,          =/
C    BUT THIS CORRESPONDENCE IS DESTROYED AS THE KEY IS FORMED.)

C  THE VARIABLES IN ADRXXX DEFINE THE STARTING ADRESSES OF ARRAYS
C   (SEE SUBR. STORAL).

C  LIST OF VARIABLES.
C  *****************

C  A = ABUNDANCE INDEX.
C  ABASE = BASE ITEM ABUNDANCE SCALE. (PARXXX)
C  ALOG2 = TABLE OF VALUES FOR CALCULATED LOG-BASED FUNCTION.
C  AVGL = AVERAGE LENGTH OF KEY. (COSTXX)
C  BLANK = THE CHARACTER ' '. (SYMXXX)
C  BREC = POINTERS TO BEGINNING OF EACH GROUP IN KEY STRUCTURE.
C  BRULE = BETWEEN-TAXON RULINGS IN TABULAR KEY.
C  COLON = THE CHARACTER ':'. (SYMXXX)
C  COMMA = THE CHARACTER ','. (SYMXXX)
C  CSTAVG = AVERAGE COST OF KEY (COSTXX)
C  CSTMAX = MAXIMUM COST OF KEY (COSTXX)
C  D = STORAGE ALLOCATED FOR VARIABLE LENGTH ARRAYS. THE VARIABLES IN
C      ADRXXX DEFINE THE STARTING ADRESSES IN D OF THE ARRAYS.
C  DAT = THE CURRENT DATE. (TIMXXX)
C  DIO = ARRAY FOR INPUT TAXON DATA.
C  DIROUT = NAME OF THE OUTPUT DIRECTORY. (OUTDXX)
C  ERULE = BETWEEN-CHARACTER RULINGS IN TABULAR KEY.
C  FF = FORM-FEED. (FFFXXX)
C  FLADDR = POINTERS TO LENGTHS OF FEATURE/STATE DESCRIPTIONS.
C  FMEM = MEMORY ADDRESSES OF FEATURE/STATE DESCRIPTIONS.
C  FMSK = FEATURE (CHARACTER) MASK.
C  FN = NEW FEATURE NUMBERS.
C  FNAME = FILE NAME. (LUFXXX)
C  FO = ORIGINAL FEATURE NUMBERS.
C  FREC = DIRECT-ACCESS RECORD ADDRESSES OF FEATURE/STATE DESCRIPTIONS.
C  HEAD = TEXT OF HEADER. (HEDXXX)
C  I = ROW NUMBER IN MATRIX. (MATXXX)
C  IABREC = RECORD ADDRESS OF THE ITEM ABUNDANCES IN THE ITEMS FILE.
C           (RECXXX)
C  IALG = ALGORITHM TO BE USED BY BEST - 0 OR 1. (ALGXXX)
C  IBUF = INPUT BUFFER. (INPBUF)
C  ICAP = WHETHER NEXT LETTER OUTPUT IS TO BE CAPITAL. (CAPXXX)
C  ICDEP = CHARACTER DEPENDENCIES.
C  ICMD = WHETHER EXPECTING TYPESETTING COMMAND. (IGNXXX)
C  ICREC = RECORD ADDRESS OF CHARACTER DESCRIPTION POINTERS IN CHARACTER
C          FILE. (RECXXX)
C  IDUMP = WHETHER TO DUMP INFORMATION FROM SUBR. BEST. (DMPXXX)
C  IDPREC = RECORD ADDRESS OF CHARACTER DEPENDENCIES IN ITEM FILE.
C           (RECXXX)
C  IENDWD = POINTER TO END OF LAST WORD IN OUTPUT BUFFER. (IOPARX)
C  IEOF = WHETHER END-OF-FILE HAS OCCURRED WHILE READING THE DIRECTIVES
C         FILE. (INPXXX)
C  IFL = LENGTHS OF FEATURE/STATE DESCRIPTIONS.
C  IHDREC = RECORD ADDRESS OF HEADER ON ITEMS FILE. (RECXXX)
C  IMDMP1 = FIRST COLUMN TO MATRIX DUMP. (DMPXXX)
C  IMDMP2 = LAST COLUMN TO MATRIX DUMP. (DMPXXX)
C  INCOMP = WHETHER KEY IS INCOMPLETE. (PARXXX)
C  IOUT = OUTPUT BUFFER. (IOBUFX)
C  IR = CHARACTER RELIABILITIES.
C  IRLREC = RECORD ADDRESS OF CHARACTER RELIABILITIES IN ITEMS
C           FILE. (RECXXX)
C  ISTOPC = COLUMN AFTER WHICH KEY FORMATION IS TO STOP. (STPXXX)
C  ITAB = LEFT-HAND TAB POSITION FOR BRACKETED KEY. (FMTXXX)
C  IRDMP1 = FIRST ROW OF MATRIX DUMP. (DMPXXX)
C  IRDMP2 = LAST ROW OF MATRIX DUMP. (DMPXXX)
C  ITCHV = WHETHER `TREAT CHARACTER AS VARIABLE' HAS BEEN USED. (PARXXX)
C  ITUNKV = WHETHER TO TREAT UNKNOWN VALUES AS VARIABLE. (PARXXX)
C  ITXNAM = POINTERS TO TAXON NAMES.
C  IWRK = WORKING ARRAY OF LENGTH MAX(NFR,NTR)
C  IWRK1 = WORKING ARRAY OF LENGTH NFR.
C  J = COLUMN NUMBER IN MATRIX. (MATXXX)
C  JB = COLUMN NUMBER OF BEST CHARACTER. (MATXXX)
C  JBSET = NUMBERS OF PRESET CHARACTERS.
C  JBUF = CURRENT POSITION IN THE INPUT BUFFER. (INPXXX)
C  JEDAT = LENGTH OF RECORD IN INPUT BUFFER. (INPXXX)
C  JF = FEATURE NUMBER. (MATXXX)
C  JOUT = CURRENT POSITION IN OUTPUT BUFFER. (IOPARX)
C  JS = STATE NUMBER. (MATXXX)
C  JU = UNSUITABILITY FLAG. (MATXXX)
C  KA  = STARTING ADDRESS OF ARRAY A . (ADRXXX)
C  KALOG2 = STARTING ADDRESS OF ARRAY ALOG2. (ADRXXX)
C  KBREC  = STARTING ADDRESS OF ARRAY BREC . (ADRXXX)
C  KBRUL = STARTING ADDRESS OF ARRAY BRUL. (ADRXXX)
C  KBRULE = STARTING ADDRESS OF ARRAY BRULE. (ADRXXX)
C  KCDEP  = STARTING ADDRESS OF ARRAY ICDEP . (ADRXXX)
C  KCOLS = COLUMN NUMBER AT WHICH TO TRUNCATE TABULAR KEY. (FMTXXX)
C  KDIO  = STARTING ADDRESS OF ARRAY DIO . (ADRXXX)
C  KDIV = STARTING ADDRESS OF ARRAY DIV. (ADRXXX)
C  KDUP  = STARTING ADDRESS OF ARRAY DUP . (ADRXXX)
C  KERUL = STARTING ADDRESS OF ARRAY KERUL. (ADRXXX)
C  KERULE = STARTING ADDRESS OF ARRAY ERULE. (ADRXXX)
C  KFLADD  = STARTING ADDRESS OF ARRAY FLADDR . (ADRXXX)
C  KFLAG  = STARTING ADDRESS OF ARRAY FLAG . (ADRXXX)
C  KFMEM  = STARTING ADDRESS OF ARRAY FMEM . (ADRXXX)
C  KFMSK  = STARTING ADDRESS OF ARRAY FMSK . (ADRXXX)
C  KFN  = STARTING ADDRESS OF ARRAY FN . (ADRXXX)
C  KFO  = STARTING ADDRESS OF ARRAY FO . (ADRXXX)
C  KFREC  = STARTING ADDRESS OF ARRAY FREC . (ADRXXX)
C  KAINDX = STARTING ADDRESS OF ARRAY AINDX (ADRXXX)
C  KIFL  = STARTING ADDRESS OF ARRAY IFL . (ADRXXX)
C  KRINDX  = STARTING ADDRESS OF ARRAY RINDX . (ADRXXX)
C  KJBSET  = STARTING ADDRESS OF ARRAY JBSET . (ADRXXX)
C  KKOSET  = STARTING ADDRESS OF ARRAY KOSET . (ADRXXX)
C  KLIST  = STARTING ADDRESS OF ARRAY LIST . (ADRXXX)
C  KNLSET  = STARTING ADDRESS OF ARRAY NLSET . (ADRXXX)
C  KNSTAT  = STARTING ADDRESS OF ARRAY NSTAT . (ADRXXX)
C  KOSET = GROUP NUMBER OF PRESET CHARACTER.
C  KR  = STARTING ADDRESS OF ARRAY R . (ADRXXX)
C  KT = STARTING ADDRESS OF ARRAY T. (ADRXXX)
C  KTAXON = STARTING ADDRESS OF ARRAY TAXON. (ADRXXX)
C  KTMP = TEMPORARY STARTING ADDRESS. (ADRXXX)
C  KTMSK  = STARTING ADDRESS OF ARRAY TMSK . (ADRXXX)
C  KTYPMK = STARTING ADDRESS OF ARRAY TYPMK . (ADRXXX)
C  KTXNAM  = STARTING ADDRESS OF ARRAY ITXNAM . (ADRXXX)
C  KUSED  = STARTING ADDRESS OF ARRAY USED . (ADRXXX)
C  KWRK  = STARTING ADDRESS OF ARRAY IWRK . (ADRXXX)
C  KWRK1 = STARTING ADDRESS OF ARRAY IWRK1. (ADRXXX)
C  KWRK2 = STARTING ADDRESS OF ARRAY IWRK2. (ADRXXX)
C  LBRAC = THE CHARACTER '('. (SYMXXX)
C  LCDEP = LENGTH OF ICDEP. (DIMXXX)
C  LCMT = LENGTH (IN CHARACTERS) OF TEXT IN "PRINT COMMENT" DIRECTIVE. (CMTXXX)
C  LCREC = RECORD LENGTH IN CHARACTERS OF DIRECT-ACCESS FILE. (LRECDA)
C  LD = LENGTH OF BLANK COMMON. (PARAMETER)
C  LDIROUT = LENGTH OF THE NAME OF THE OUTPUT DIRECTORY. (OUTDXX)
C  LDM = STORAGE ALLOCATED FOR CHARACTER-TAXON MATRIX. (DIMXXX)
C  LFD = TOTAL NUMBER OF FEATURES.
C  LFNAME = LENGTH OF FILE NAME. (LUFXXX)
C  LFOUT = OUTPUT WIDTH. (FMTXXX)
C  LHEAD = LENGTH OF HEADER TEXT. (LHEADX)
C  LIST = USED FOR STORING KEY STRUCTURE.
C  LMAX = MAXIMUM LENGTH OF KEY (COSTXX)
C  LRECDA = RECORD LENGTH OF DIRECT-ACCESS FILE. (LRECDA)
C  LSTYLE = LENGTH OF THE TYPSET STYLE SPECIFICATION. (LTYXXX)
C  LTAB = LENGTH OF THE TYPSET TAB SPECIFICATION. (LTYXXX)
C  LTD = TOTAL NUMBER OF ITEMS.
C  LTXOUT = RIGHT MARGIN FOR JUSTIFIED OUTPUT. (FMTXXX)
C  LUNC = LOGICAL UNIT FOR INPUT OF CHARACTERS FILE. (LUNXXX)
C  LUND = LOGICAL UNIT FOR INPUT OF DIRECTIVES. (LUNDXX)
C  LUNE = LOGICAL UNIT FOR OUTPUT OF DIAGNOSTICS. (LUNXXX)
C  LUNI = LOGICAL UNIT FOR INPUT OF DIRECTIVES. (LUNXXX)
C  LUNL = LOGICAL UNIT FOR OUTPUT OF LISTING. (LUNXXX)
C  LUNO = LOGICAL UNIT FOR OUTPUT OF PRINTED KEYS. (LUNXXX)
C  LUNP = LOGICAL UNIT FOR OUTPUT OF TYPSET KEY. (LUNXXX)
C  LUNOUT = CURRENT OUTPUT UNIT. (LUUXXX)
C  LUNPAG = WHETHER THERE IS PAGING ON AN OUTPUT UNIT. (LUOXXX)
C  LUNPRE = PREVIOUS INPUT FILE. (LUOXXX)
C  LUNREC = NUMBER OF RECORDS OUTPUT TO A UNIT. (LUOXXX)
C  LUNS = LOGICAL UNIT FOR OUTPUT OF KEY STRUCTURE. (LUNXXX)
C  LUNS1 = LOGICAL UNIT FOR OUTPUT OF SCRATCH FILE USED BY `TREAT CHARACTER AS
C    VARIABLE'. (LUNXXX)
C  LUNT = LOGICAL UNIT FOR INPUT OF ITEMS FILE. (LUNXXX)
C  LUNTI = LOGICAL UNIT FOR TERMINAL INPUT. (LUTXXX)
C  LUNTO = LOGICAL UNIT FOR TERMINAL OUTPUT. (LUTXXX)
C  LUNTYP = TYPE OF USE OF LOGICAL UNIT. 1 - INPUT OF DIRECTIVES.
C    2 - INPUT OF CHARACTERS. 3 - INPUT OF ITEMS. 4 - KEY OUTPUT FOR
C    PRINTING. 5 - KEY OUTPUT FOR TYPESETTING. 6 - KEY STRUCTURE.
C    7 - ERROR MESSAGES. 8 - LISTING (ERROR MESSAGES, PARAMETER VALUES,
C    DUMPS).
C  LUNUSE(LUN) = TYPE OF USE OF LOGICAL UNIT LUN. SEE LUNTYP.
C    -1 INITIALLY. LUNUSE(LUNI).EQ.0 IF NO DIRECTIVES FILE. (LUOXXX)
C  MAXSTY = LENGTH OF TYPSET STYLE BUFFER - TSTYLE. (LTYXXX)
C  MAXTAB = LENGTH OF TYPSET TAB BUFFER - TTAB. (LTYXXX)
C  MAXTYPMK = MAXIMUM NUMBER OF TYPESETTING MARKS THAT CAN BE DEFINED. (LTYXXX)
C  MNS = MAXIMUM NUMBER OF STATES. (MNSXXX)
C  MNS1 = MNS+1. (MNSXXX)
C  MNS2 = MN2+2. (MNSXXX)
C  MNS3 = MNS+3. (MNSXXX)
C  MSKCHR = RECORD ADDRESS OF CHARACTER MASK IN ITEMS FILE.(RECXXX)
C  MSKTAX = RECORD ADDRESS OF TAXON MASK ON ITEMS FILE. (RECXXX)
C  MSTOR = NUMBER OF LOCATIONS AVAILABLE FOR STORING DATA. (MSTXXX)
C  MSTORC = NUMBER OF CHARACTER LOCATIONS AVAILABLE FOR STORING DATA. (MSTXXX)
C  NAMTAX = RECORD ADDRESS OF TAXON NAMES ON ITEMS FILE. (RECXXX)
C  NB = START COLUMN OF CURRENT GROUP. (MATXXX)
C  NCHAR = NUMBER OF CHARACTERS STORED IN EACH WORD. (NCHXXX)
C  NCINWD = NUMBER OF CHARACTERS STORED IN EACH WORD. (PARAMETER)
C  NCONF = NUMBER OF CONFIRMATORY CHARACTERS. (PARXXX)
C  NDESC = NUMBER OF FEATURE+STATE DESCRIPTIONS. (DIMXXX)
C  NE = END COLUMN OF CURRENT GROUP. (MATXXX)
C  NF = NUMBER OF MASKED-IN FEATURES. (DIMXXX)
C  NFP = NUMBER OF WORDS REQUIRED TO STORE NF FEATURES, PACKED NPACK
C        PER WORD. (MATXXX)
C  NFR = NUMBER OF FEATURES READ.
C  NINPUT = NUMBER OF INPUT FILES. (INPXXX)
C  NL = (MATXXX)
C  NLSET = COLUMN FOR PRESET CHARACTER.
C  NOCC = NUMBER OF OCCURRENCES OF A TAXON IN KEY.
C  NP = OUTPUT OPTIONS. (PRFXXX)
C        NP(1)=1, PRINT CHARACTERS AND STATES.
C        NP(2)=1, LIST TAXA AND CHARACTER STATES.
C        NP(3)=1, OUTPUT TABULAR KEY WITH ORIGINAL NUMBERS.
C        NP(4)=1, OUTPUT TABULAR KEY WITH NEW NUMBERS.
C        NP(5)=1, OUTPUT BRACKETED KEY.
C        NP(6)=1, OUTPUT KEY STRUCTURE.
C        NP(7)=1, STATE DESCRIPTIONS REQUIRED.
C        NP(8)=1, A KEY IS REQUIRED.
C  NPACK = NUMBER OF ELEMENTS OF THE DATA MATRIX STORED PER WORD.
C          (PACXXX)
C  NSD = NUMBER OF PRESET CHARACTERS.
C  NSET = NUMBER OF PRESET CHARACTERS. (PARXXX)
C  NSTAT = NUMBERS OF FEATURE STATES.
C  NSTOR = AMOUNT OF STORAGE REQUIRED BY VARIABLE ARRAYS. (NSTXXX)
C  NSTREC = RECORD ADDRESS OF NUMBER OF STATES ON CHARACTERS FILE.
C           (RECXXX)
C  NSTTAX = RECORD ADDRESS OF NUMBER OF STATES ON ITEMS FILE. (RECXXX)
C  NTA = NUMBER OF TAXA ADDED TO MATRIX DURING KEY GENERATION. (PARXXX)
C  NTH = NTU/2. (DIMXXX)
C  NTM = NUMBER OF MASKED-IN ITEMS. (DIMXXX)
C  NTM1 = NTM+1. (DIMXXX)
C  NTR = NUMBER OF ITEMS READ. (PARXXX)
C  NTU = MAXIMUM NUMBER OF ITEMS (INCLUDING GENERATED VARIANTS).(DIMXXX)
C  NTYPMK = NUMBER OF TYPESETTING MARKS DEFINED. (LTYXXX)
C  NUN = NUMBER OF LOGICAL UNITS AVAILABLE FOR USE. (LUOXXX)
C  NUSED = NUMBER OF CHARACTERS USED IN MAKING KEY. (PARXXX)
C  NVAR = NUMBER OF VARIANTS GENERATED BY BEST CHARACTER. (PARXXX)
C  NWORD = NUMBER OF WORDS ALLOCATED TO STORE A TAXON NAME. (DIMXXX)
C  PID = PROGRAM IDENTIFICATION. (PIDXXX)
C  PIDP = PROGRAM IDENTIFICATION (PARAMETER).
C  R = CHARACTER RELIABILITY INDEX.
C  RANGE = THE CHARACTER '-'. (SYMXXX)
C  RBASE = BASE CHARACTER RELIABILITY SCALE. (PARXXX)
C  RBRAC = THE CHARACTER ')'. (SYMXXX)
C  REUSE = FACTOR USED IN CALCULATING THE COST OF REUSING A CHARACTER.
C          (PARXXX)
C  SEMIC = THE CHARACTER ';'. (SYMXXX)
C  STAR = THE CHARACTER '*'. (SYMXXX)
C  STOP = THE CHARACTER '.'. (SYMXXX)
C  T = NUMERIC TAXON IDENTIFIERS.
C  TAXON = TAXON NAMES.
C  TIM = TIME OF KEY RUN. (TIMXXX)
C  TMP = WORKING CHARACTER ARRAY. (TMPXXX)
C  TMSK = ITEM MASK.
C  UPAROW = THE CHARACTER '^'. (SYMXXX)
C  USED = WHETHER CHARACTER USED IN KEY.
C  VARW = (1-VARYWT)/VARYWT. (PARXXX)
C  VARYWT = FACTOR USED IN DETERMINING TREATMENT OF INTRA-TAXON
C           VARIABILITY AND UNKNOWNS. (PARXXX)

      COMMON /ADRXXX/ KT,KBRULE,KERULE,KTAXON,KTXNAM,KFMEM,KNSTAT,
     *                KFO,KFREC,KFLADD,KIFL,KDIO,KFN,KDUP,KBREC,
     *                KFLAG,KA,KLIST,KCDEP,KALOG2,KNBO,KBRUL,KNEO,KNBN,
     *                KERUL,KNEN,KNCO,KNOCC,KNCN,KDIV,
     *                KR,KRULE,KRINDX,KUSED,KAINDX,KTAXA,
     *                KWRK,KWRK1,KWRK2,KNLSET,KKOSET,KJBSET,KFMSK,KTMSK,
     *                KTMP,KBCMT,KBPRE,KBTYP,KCMT,KTYPMK
      COMMON /ALGXXX/ IALG
      COMMON /CAPXXX/ ICAP
      COMMON /COSTXX/ CSTAVG,CSTMAX,AVGL,LMAX
      COMMON /CWRKXX/ CTMP
      CHARACTER*10 CTMP
      COMMON /DIMXXX/ LDM,NFR,NF,NTM,NTM1,NTU,NTH,NWORD,NDESC,LCDEP
      COMMON /DMPXXX/ IDUMP,IMDMP1,IMDMP2,IRDMP1,IRDMP2
      COMMON /ERRXXX/ IERR
      COMMON /FBUFXX/ NEXT
      COMMON /FFFXXX/ FF
      CHARACTER*1 FF
      COMMON /FMTXXX/ ITAB,LFOUT,LTXOUT,KCOLS,MAXWID
      COMMON /HEDXXX/ HEAD
      CHARACTER*200 HEAD
      COMMON/ IGNXXX/ ICMD
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /IOBUFX/ IOUT
      CHARACTER*200 IOUT
      COMMON /IOPARX/ JOUT,IENDWD,IBINARY
      COMMON /LHEADX/ LHEAD,MAXHDR
      COMMON /LINEXX/ LINE
      CHARACTER*200 LINE
      COMMON /LRECDA/ LRECDA,LCREC
      COMMON /LTYXXX/ LSTYLE,MAXSTY,LTAB,MAXTAB
      COMMON /LUFXXX/ FNAME(12),LFNAME(12)
        CHARACTER FNAME*30
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(10),LUNPRE(10),
     *  LUNUSE(13),LUNREC(13),LUNPAG(13)
      COMMON /LUTXXX/ LUNTI,LUNTO
      COMMON /LUUXXX/ LUNOUT
      COMMON /MATXXX/ JU,JF,JS,I,J,NL,JB,NFP,NB,NE
      COMMON /MNSXXX/ MNS,MNS1,MNS2,MNS3
      COMMON /MSTXXX/ MSTOR,MSTORC
      COMMON /NCHXXX/ NCHAR
      COMMON /NSTXXX/ NSTOR
      COMMON /OUTDXX/ DIROUT,LDIROUT
        CHARACTER*128 DIROUT
      COMMON /PACXXX/ NPACK
      COMMON /PARXXX/ NFB,NFE,JFB,NVAR,NEWLN,NT,NTD,NTA,NO,KN,NUSED,
     *                INCOMP,VARW,NTR,RBASE,ABASE,REUSE,VARYWT,NCONF,
     *                NSET,RES,ITUNKV,IADCNO,ITCHV,IRTF,IHTML
      COMMON /PIDXXX/ PID
        CHARACTER*230 PID
      COMMON /PRFXXX/ NP(8)
      COMMON /RECXXX/ MSKTAX,NAMTAX,MSKCHR,NSTREC,IDPREC,IRLREC,ICREC,
     *                IHDREC,NSTTAX,IABREC
      COMMON /STYXXX/ TSTYLE,TTAB
        CHARACTER TSTYLE*100,TTAB*30
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      COMMON /TIMXXX/ TIM,DAT
      CHARACTER*10 TIM,DAT

      INTEGER D(LD)
      REAL RD(LD)
      CHARACTER*1 CSTR(LDC)

      CALL BLKDAT

C     USE ALL AVAILABLE MEMORY.
      CALL MEM (CSTR, LD, LDC, IWST, ICWST)

      CALL KEY2 (D(IWST), RD(IWST), CSTR(ICWST), LD, LDC)

      END
      SUBROUTINE KEY2 (D, RD, CSTR, LD, LDC)

C* REVISED 23-MAR-99.
C* READS DATA AND GENERATES KEY.

      INTEGER D(LD)
      REAL RD(LD)
      CHARACTER*1 CSTR(LDC)


      COMMON /ADRXXX/ KT,KBRULE,KERULE,KTAXON,KTXNAM,KFMEM,KNSTAT,
     *                KFO,KFREC,KFLADD,KIFL,KDIO,KFN,KDUP,KBREC,
     *                KFLAG,KA,KLIST,KCDEP,KALOG2,KNBO,KBRUL,KNEO,KNBN,
     *                KERUL,KNEN,KNCO,KNOCC,KNCN,KDIV,
     *                KR,KRULE,KRINDX,KUSED,KAINDX,KTAXA,
     *                KWRK,KWRK1,KWRK2,KNLSET,KKOSET,KJBSET,KFMSK,KTMSK,
     *                KTMP,KBCMT,KBPRE,KBTYP,KCMT,KTYPMK
      COMMON /CMTXXX/ LCMT
      COMMON /DIMXXX/ LDM,NFR,NF,NTM,NTM1,NTU,NTH,NWORD,NDESC,LCDEP
      COMMON /ERRXXX/ IERR
      COMMON /LUNDXX/ LUND
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(10),LUNPRE(10),
     *  LUNUSE(13),LUNREC(13),LUNPAG(13)
      COMMON /LUTXXX/ LUNTI,LUNTO
      COMMON /MSTXXX/ MSTOR,MSTORC
      COMMON /NCHXXX/ NCHAR
      COMMON /PARXXX/ NFB,NFE,JFB,NVAR,NEWLN,NT,NTD,NTA,NO,KN,NUSED,
     *                INCOMP,VARW,NTR,RBASE,ABASE,REUSE,VARYWT,NCONF,
     *                NSET,RES,ITUNKV,IADCNO,ITCHV,IRTF,IHTML
      COMMON /PRFXXX/ NP(8)
      COMMON /TPSXXX/ ITPSET,MAXTYPMK,NTYPMK,LTYPMK,INTYPMKS

      LOGICAL*4 O
      CHARACTER*60 FSPEC

      MSTOR = LD
      MSTORC = LDC
      CALL BLKDAT

      CALL INITF (LUNE, LUNI, LUNTI, LUNTO, LUNUSE, NUN)

      IF (LUNE.LT.0) STOP '****** PROGRAM BUG. LUNE NOT DEFINED.'
      LUND = LUNI
      LUNL = LUNE
      FSPEC= 'TERMINAL'
      IF (LUNTO.GE.0) CALL SETLUN (FSPEC, LUNTO, 7)
      IF (LUNUSE(LUNE).LT.0) THEN
        INQUIRE (UNIT=LUNE, NAME=FSPEC)
        CALL SETLUN (FSPEC, LUNE, 7)
      ENDIF

      CALL PROGID (LUNE)

      IF (LUNI.LT.0) STOP '****** PROGRAM BUG. LUNI NOT DEFINED.'
      INQUIRE (UNIT=LUNI, OPENED=O)
      IF (O) THEN
        INQUIRE (UNIT=LUNI, NAME=FSPEC)
        CALL SETLUN (FSPEC, LUNI, 1)
      ELSE
        LUNUSE(LUNI) = 0
      ENDIF

C--   READ PARAMETERS.
      CALL PARAMS (D, RD, CSTR, NSD, LWRK)
      IF (IERR.NE.0)  GOTO 300

C     ALLOCATE STORAGE.
      CALL STORAL (D(KWRK), LWRK, D(KWRK1), D(KFMSK))
      IF (NSET.GT.0)  CALL CPYPRE (D(KBPRE), NSD, D(KJBSET), D(KKOSET),
     * D(KNLSET), NSET)
      NSD = MAX0(1,NSET)
      IF (NTYPMK.GT.0)  CALL COPIA (D(KBTYP), D(KTYPMK), LTYPMK)
      IF (LCMT.GT.0)  CALL COPSA (CSTR(KBCMT), CSTR(KCMT), LCMT)

C--   READ CHARACTER AND STATE INFORMATION.
      IF (NP(1).EQ.0.AND.NP(8).EQ.0)  GO TO 80
      CALL RCHAR (RD(KR), D(KFO), D(KNSTAT), D(KFMEM),
     * D(KFREC), D(KFLADD), D(KIFL), RD(KRINDX), D(KWRK),
     * D(KFMSK))

C--   READ AND STORE TAXA AND CHARACTER VALUES.
   80 IF (NP(2).EQ.0.AND.NP(8).EQ.0)  GO TO 400
      LTAXON = NWORD * NTM * NCHAR
      ITXADR = (KTAXON-1)*NCHAR + 1
      CALL RTAX (D, RD(KA), D(KT), D(KDUP),
     * D(KNSTAT), D(KFO), D(KFLAG), D(KTXNAM),
     * D(KDIO), D(KFN), D(KCDEP), D(KFMSK),
     * RD(KAINDX), D(KTMSK), D(KTAXA), D(KWRK), D(KWRK1),
     * CSTR(ITXADR), LTAXON)
      IF (IERR.NE.0)  GO TO 300
      IF (NP(8).EQ.0)  GO TO 400
      CALL WRTREC ('Data input completed.', LUNE)

C--   FORM KEY.
      CALL KEYGEN (D, D(KT), D(KBRULE), D(KERULE), D(KDUP),
     * RD(KA), RD(KALOG2), D(KFN), RD(KRINDX), D(KFMSK), D(KWRK),
     * D(KWRK1),
     * D(KNSTAT), D(KFO), RD(KR), D(KUSED),D(KFLAG),
     * D(KNBO), D(KNEO), D(KNBN), D(KNEN), D(KNCO), D(KNCN), D(KDIV),
     * D(KNLSET), D(KKOSET), D(KJBSET),  NSD, D(KCDEP),
     * D(KTXNAM), CSTR(ITXADR), LTAXON)
      IF (IERR.NE.0)  GO TO 400
      CALL WRTREC ('Key generation completed.', LUNE)

C--   PRINT KEY.

C     TABULAR KEY.
      IRLADR = (KRULE-1)*NCHAR + 1
      CALL WRTKEY (D(1), D(KT), D(KBRULE), D(KERULE), D(KBRUL),
     * D(KERUL),D(KNOCC), D(KFO), RD(KR), D(KUSED), CSTR(IRLADR),
     * D(KDIO), D(KFLAG), D(KTXNAM),
     * D(KNLSET), D(KKOSET), D(KJBSET), NSD,
     * D(KFMSK), RD(KRINDX), D(KTMSK), RD(KAINDX),
     * CSTR(ITXADR), LTAXON)
      IF (NP(3).NE.0) THEN
        CALL WRTREC ('Tabular key completed.', LUNE)
      ENDIF

C     OUTPUT KEY STRUCTURE.
      IF (NP(5).NE.0.OR.NP(6).NE.0)
     * CALL STRUCT (D(1), D(KT), D(KBRULE), D(KERULE), D(KBREC),
     * D(KNSTAT), D(KFO), D(KLIST), MSTOR, IDIGS, INODE, ITAXON)

C     BRACKETED KEY.
      LDMC = LDM*NCHAR
      IF (NP(5).NE.0) THEN
        IF (ITPSET.GT.0)  THEN
          CALL PRTKEYT (CSTR(ITXADR), LTAXON, D(KTXNAM), CSTR, LDMC,
     *    D(KFREC), D(KFMEM), D(KFLADD), D(KNSTAT), D(KFN), D(KFO),
     *    D(KIFL), D(KBREC), D(KLIST), D(KTYPMK), MSTOR,
     *    IDIGS, INODE, ITAXON,
     *    D(KNLSET), D(KKOSET), D(KJBSET), NSD,
     *    D(KFMSK), RD(KRINDX), D(KTMSK), RD(KAINDX), CSTR(KCMT))
        ELSE
          CALL PRTKEY (CSTR(ITXADR), LTAXON, D(KTXNAM), CSTR, LDMC,
     *    D(KFREC), D(KFMEM), D(KFLADD), D(KNSTAT), D(KFN), D(KFO),
     *    D(KIFL), D(KBREC), D(KLIST), MSTOR,
     *    IDIGS, INODE, ITAXON)
        ENDIF
        CALL WRTREC ('Bracketted key completed.', LUNE)
      ENDIF
      GO TO 400

C--   ERROR MESSAGE.
  300 CALL FERROR ('Data error(s). Execution terminated.%')
C--
  400 CONTINUE

C--
C     CLOSE FILES.
      CALL UCLOSE
      END
      SUBROUTINE BLKDAT                                                     MAIN

C* REVISED 20-APR-99.
C* SETS PARAMETERS IN COMMON.

      COMMON /ADRXXX/ KT,KBRULE,KERULE,KTAXON,KTXNAM,KFMEM,KNSTAT,
     *                KFO,KFREC,KFLADD,KIFL,KDIO,KFN,KDUP,KBREC,
     *                KFLAG,KA,KLIST,KCDEP,KALOG2,KNBO,KBRUL,KNEO,KNBN,
     *                KERUL,KNEN,KNCO,KNOCC,KNCN,KDIV,
     *                KR,KRULE,KRINDX,KUSED,KAINDX,KTAXA,
     *                KWRK,KWRK1,KWRK2,KNLSET,KKOSET,KJBSET,KFMSK,KTMSK,
     *                KTMP,KBCMT,KBPRE,KBTYP,KCMT,KTYPMK
      COMMON /CAPXXX/ ICAP
      COMMON /DMPXXX/ IDUMP,IMDMP1,IMDMP2,IRDMP1,IRDMP2
      COMMON /FBUFXX/ NEXT
      COMMON /FFFXXX/ FF
      CHARACTER*1 FF
      COMMON /FMTXXX/ ITAB,LFOUT,LTXOUT,KCOLS,MAXWID
      COMMON /IGNXXX/ ICMD
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /IOBUFX/ IOUT
      CHARACTER*200 IOUT
      COMMON /IOPARX/ JOUT,IENDWD,IBINARY
      COMMON /LHEADX/ LHEAD,MAXHDR
      COMMON /LRECDA/ LRECDA,LCREC
      COMMON /LTYXXX/ LSTYLE,MAXSTY,LTAB,MAXTAB
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(10),LUNPRE(10),
     *  LUNUSE(13),LUNREC(13),LUNPAG(13)
      COMMON /LUTXXX/ LUNTI,LUNTO
      COMMON /MNSXXX/ MNS,MNS1,MNS2,MNS3
      COMMON /NCHXXX/ NCHAR
      COMMON /PACXXX/ NPACK
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      COMMON /TPSXXX/ ITPSET,MAXTYPMK,NTYPMK,LTYPMK,INTYPMKS

      DIMENSION LU(10)
      EQUIVALENCE (LU(1),LUNI)

C  LRECDA = LENGTH OF RECORDS ON THE DIRECT ACCESS FILE IN WORDS.
C  LUNI = LOGICAL UNIT FOR INPUT OF PARAMETER CARDS.
C  LUNC = LOGICAL UNIT FOR INPUT OF CHARACTER CARDS.
C  LUNT = LOGICAL UNIT FOR INPUT OF TAXON CARDS.
C  LUNO = LOGICAL UNIT FOR OUTPUT OF KEYS.
C  LUNS = LOGICAL UNIT FOR OUTPUT OF KEY STRUCTURE.
C  LUNE = LOGICAL UNIT FOR OUTPUT OF DIAGNOSTICS.
C  LUNL = LOGICAL UNIT FOR OUTPUT OF LISTING.
C  LUNTI = LOGICAL UNIT FOR TERMINAL INPUT.
C  LUNTO = LOGICAL UNIT FOR TERMINAL OUTPUT.
C  MNS = MAXIMUM NUMBER OF STATES.
C  NPACK = NUMBER OF ELEMENTS OF THE DATA MATRIX STORED PER WORD.
C    EACH ELEMEMT REQUIRES 31 BITS, AND THE SIGN BIT IS NOT USED.

C     ADRXXX.
      KTMP = 1
 
C     CAPXXX.
      ICAP = 0

C     CMTXXX.
      LCMT = 0
 
C     DMPXXX.
      IMDMP1 = -1
      IMDMP2 = -1

C     FBUFXX.
      NEXT = 1

C     FFFXXX.
      FF = CHAR(12)

C     FMTXXX.
      LFOUT = 80
      LTXOUT = 80
      KCOLS = 1000
      MAXWID = 200

C     IGNXXX.
      ICMD = 0

C     INPXXX.
      NINPUT = 0
 
C     IOBUFX.
      DO 10 L = 1, MAXWID
        IOUT(L:L) = ' '
   10 CONTINUE

C     IOPARX.
      JOUT = 0
      IENDWD = -1
      IBINARY = 0

C     LHEADX.
      MAXHDR = 200

C     LRECDA.
      LRECDA = 32

C     LTYXXX.
      LSTYLE = 0
      MAXSTY = 100
      LTAB = 0
      MAXTAB = 30

C     LUNXXX, LUOXXX.
      DO 45 LUNTYP = 1, 10
        LU(LUNTYP) = -1
        LUNCOM(LUNTYP) = LUNTYP
        LUNPRE(LUNTYP) = -1
   45 CONTINUE
      LUNCOM(8) = 4
      LUNCOM(9) = 4

C     LUOXXX.
      NUN = 13
      LPRINT = 0
      LTOP = 0
      DO 50 LUN = 1, NUN
        LUNUSE(LUN) = -1
        LUNREC(LUN) = 0
        LUNPAG(LUN) = 0
   50 CONTINUE

C     LUTXXX.
      LUNTI = -1
      LUNTO = -1

C     MNSXXX.
      MNS = 20                                                                =*

      NPACK = 1

C     SYMXXX.
      BLANK = ' '
      STOP = '.'
      SEMIC = ';'
      LBRAC = '('
      RBRAC = ')'
      RANGE = '-'
      STAR = '*'
      UPAROW = '^'
      COMMA = ','
      COLON = ':'
      NUMERO = '#'
      LABRAC = '<'
      RABRAC = '>'
      LBRACE = '{'
      RBRACE = '}'
      BSLSH = '\'

C     TPSXXX.
      ITPSET = -1
      MAXTYPMK = 51
      NTYPMK = 0
      LTYPMK = 0

C     DIRECT ACCESS RECORD LENGTH IN CHARACTERS.
      LCREC = LRECDA*NCHAR

      RETURN
      END
      SUBROUTINE CPYPRE (IPRE, L, JBSET, KOSET, NLSET, NSET)                MAIN

C  REVISED 17/6/85.
C  COPIES INFORMATION ABOUT PRESET CHARACTERS TO PERMANENT ARRAYS.

C  IPRE RECEIVES THE INFORMATION.
C  L RECEIVES THE LENGTH OF IPRE.
C  JBSET RETURNS THE PRESET CHARACTER NUMBERS.
C  KOSET RETURNS THE PRESET GROUP NUMBERS.
C  NLSET RETURNS THE PRESET COLUMN NUMBERS.
C  NSET RECEIVES THE NUMBER OF PRESET CHARACTERS.

      DIMENSION IPRE(L),JBSET(NSET),KOSET(NSET),NLSET(NSET)

      K = 1
      DO 10 I = 1, NSET
        JBSET(I) = IPRE(K)
        KOSET(I) = IPRE(K+1)
        NLSET(I) = IPRE(K+2)
        K = K + 3
   10   CONTINUE

      RETURN
      END
      SUBROUTINE CPYTAX (D, LDM, ITAX, FN, FMSK, NFR, ICDEP, LCDEP,         MAIN
     * NSTAT, NF, MI, NFP, ITUNKV, ITXREC, ITCHV, IWRK)

C  REVISED 8-SEP-94.
C  COPIES DATA FOR A TAXON INTO THE MATRIX, OMITTING ANY FEATURES
C   THAT HAVE BEEN MASKED OUT.

C  D RETURNS THE CHARACTER-TAXON MATRIX.
C  LDM RECEIVES THE LENGTH OF D.
C  ITAX RECEIVES THE TAXON DATA.
C  FN RECEIVES THE CORRESPONDENCE BETWEEN NEW AND ORIGINAL CHARACTER
C   NUMBERS.
C  FMSK RECEIVES THE FEATURE MASK.
C  NFR RECEIVES THE NUMBER OF FEATURES READ IN.
C  ICDEP RECEIVES THE CHARACTER DEPENDENCIES.
C  LCDEP RECEIVES THE LENGTH OF ICDEP.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  NF RECEIVES THE NUMBER OF MASKED-IN FEATURES.
C  MI RECEIVES THE MASKED-IN ITEM NUMBER.
C  NFP RECEIVES THE NUMBER OF WORDS REQUIRED TO STORE A ROW
C   OF THE MATRIX.
C  ITUNKV RECEIVES WHETHER UNKNOWNS ARE TO BE TREATED AS VARIABLE.
C  ITXREC RECEIVES A RECORD POINTER, IF ITCHV IS NON-ZERO
C  ITCHV RECEIVES WHETHER THERE ARE VARIABLE CHARACTERS ASSOCIATED WITH TAXA
C  IWRK RECEIVES WORKING SPACE OF LENGTH NFR

      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /MNSXXX/ MNS,MNS1,MNS2,MNS3

      INTEGER D(LDM),ITAX(NFR),FN(NFR),FMSK(NFR),ICDEP(LCDEP),NSTAT(NF),
     * IWRK(NFR)

C     THE DIMENSION OF ISTAT SHOULD BE EQUAL TO MNS3                          =/
      DIMENSION ISTAT(23)                                                     =*

      IOK = 0
      IF (ITCHV.NE.0)  THEN
        IF (ITXREC.NE.0)  THEN
          READ(LUNS1,REC=ITXREC)(IWRK(I),I=1,NFR)
          IOK = 1
        ENDIF
      ENDIF
 
      IF (IOK.EQ.0) CALL SETIA (IWRK, NFR, 0)
 
      JF = 0
      DO 100 IF = 1, NFR
        IF (FMSK(IF).EQ.0) GOTO 100

C       COPY FEATURE VALUES TO ROW MI, COLUMN JF.
        JF = JF + 1
        K = (MI-1)*NFP + JF
        D(K) = ITAX(IF)
        CALL SETF (D, LDM, MI, JF)
        NS = NSTAT(JF)
        CALL FINDST (D, LDM, MI, JF, ISTAT, NS, NSP)
        IF (ISTAT(MNS3).NE.0)  THEN
          IF (ITUNKV.NE.0)  CALL SETV (D, LDM, MI, JF, NS)
        ELSEIF (IWRK(IF).NE.0) THEN
          CALL SETV (D, LDM, MI, JF, NS)
        ENDIF
  100   CONTINUE

      IF (LCDEP.LE.1)  GOTO 300

C     MODIFY VALUES TO REFLECT CHARACTER DEPENDENCIES.
      JF = 0
      DO 200 IF = 1, NFR
        IF (FMSK(IF).EQ.0)  GOTO 200
        JF = JF + 1
        IF (ICDEP(IF).EQ.0)  GOTO 200
        II = ICDEP(IF)
        NS = NSTAT(JF)
        CALL FINDST (D, LDM, MI, JF, ISTAT, NS, NSP)
        DO 180 IS = 1, NS
          IF (ICDEP(II+IS-1).EQ.0)  GOTO 180
          IF (ISTAT(IS).EQ.0.AND.ISTAT(MNS2).EQ.0)  GOTO 180
          JJ = ICDEP(II+IS-1)
          NR = ICDEP(JJ)
          DO 150 IR = 1, NR
            IB = ICDEP(JJ+2*IR-1)
            IE = ICDEP(JJ+2*IR)
            DO 120 KF = IB, IE
              IF (FMSK(KF).EQ.0)  GOTO 120
              KFN = FN(KF)
              CALL SETNA (D, LDM, MI, KFN)
  120         CONTINUE
  150       CONTINUE
  180     CONTINUE
  200   CONTINUE

  300 RETURN
      END
      SUBROUTINE INICHR (NC, ILAST)                                         MAIN

C  REVISED 12/11/86.
C  READS FIRST PARAMETER RECORD OF CHARACTERS FILE AND ALLOCATES
C   STORAGE FOR CHARACTER MASK AND CHARACTER RELIABILITIES.

C  NC RETURNS THE NUMBER OF CHARACTERS.
C  ILAST RECEIVES AND RETURNS THE INDEX OF THE LAST WORD OF STORAGE
C   ALLOCATED.

      DIMENSION IDAT(3)

      COMMON /ADRXXX/ KT,KBRULE,KERULE,KTAXON,KTXNAM,KFMEM,KNSTAT,
     *                KFO,KFREC,KFLADD,KIFL,KDIO,KFN,KDUP,KBREC,
     *                KFLAG,KA,KLIST,KCDEP,KALOG2,KNBO,KBRUL,KNEO,KNBN,
     *                KERUL,KNEN,KNCO,KNOCC,KNCN,KDIV,
     *                KR,KRULE,KRINDX,KUSED,KAINDX,KTAXA,
     *                KWRK,KWRK1,KWRK2,KNLSET,KKOSET,KJBSET,KFMSK,KTMSK,
     *                KTMP,KBCMT,KBPRE,KBTYP,KCMT,KTYPMK
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /RECXXX/ MSKTAX,NAMTAX,MSKCHR,NSTREC,IDPREC,IRLREC,ICREC,
     *                IHDREC,NSTTAX,IABREC

C     READ AND CHECK FIRST RECORD.
      CALL RDDAI (IDAT, 3, 1, LUNC)
      DO 10 I = 1, 3
        IF (IDAT(I).LE.0)  CALL FERROR ('Invalid KEY CHARACTERS file.%')
   10   CONTINUE
      NC = IDAT(1)
      NSTREC = IDAT(2)
      ICREC = IDAT(3)

C     ALLOCATE STORAGE FOR CHARACTER MASK.
C     KFMSK IS STARTING ADDRESS OF MASK ARRAY.
      KFMSK = ILAST - NC

C     ALLOCATE STORAGE FOR CHARACTER RELIABILITIES - RINDX(NC),R(NC).
      KRINDX = KFMSK - NC
      KR = KRINDX - NC
      ILAST = KR

      RETURN
      END
      SUBROUTINE INITEM (NI, NFI, LCDEP, ILAST)                             MAIN

C  REVISED 12/11/86.
C  READS FIRST PARAMETER RECORD OF ITEMS FILE AND ALLOCATES
C   STORAGE FOR ITEM MASK AND ITEM ABUNDANCES.

C  NI RETURNS THE NUMBER OF ITEMS.
C  NFI NUMBER OF FEATURES (CHARACTERS) AS RECORDED IN ITEMS FILE.
C  LCDEP RETURNS THE LENGTH OF THE CHARACTER DEPENDENCY ARRAY.
C  ILAST RECEIVES AND RETURNS THE INDEX OF THE LAST WORD OF STORAGE
C   ALLOCATED.

      DIMENSION IDAT(11)

      COMMON /ADRXXX/ KT,KBRULE,KERULE,KTAXON,KTXNAM,KFMEM,KNSTAT,
     *                KFO,KFREC,KFLADD,KIFL,KDIO,KFN,KDUP,KBREC,
     *                KFLAG,KA,KLIST,KCDEP,KALOG2,KNBO,KBRUL,KNEO,KNBN,
     *                KERUL,KNEN,KNCO,KNOCC,KNCN,KDIV,
     *                KR,KRULE,KRINDX,KUSED,KAINDX,KTAXA,
     *                KWRK,KWRK1,KWRK2,KNLSET,KKOSET,KJBSET,KFMSK,KTMSK,
     *                KTMP,KBCMT,KBPRE,KBTYP,KCMT,KTYPMK
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /RECXXX/ MSKTAX,NAMTAX,MSKCHR,NSTREC,IDPREC,IRLREC,ICREC,
     *                IHDREC,NSTTAX,IABREC

C     READ AND CHECK FIRST RECORD.
      CALL RDDAI (IDAT, 11, 1, LUNT)
      DO 10 I = 1, 11
        IF (IDAT(I).LE.0.AND.I.NE.3)
     *   CALL FERROR ('Invalid KEY ITEMS file.%')
   10   CONTINUE
      NI = IDAT(1)
      NFI = IDAT(2)
      LCDEP = MAX0(1,IDAT(3))
      IHDREC = IDAT(4)
      MSKCHR = IDAT(5)
      NSTTAX = IDAT(6)
      IDPREC = IDAT(7)
      IRLREC = IDAT(8)
      MSKTAX = IDAT(9)
      NAMTAX = IDAT(10)
      IABREC = IDAT(11)


C     ALLOCATE STORAGE FOR TAXON MASK.
C     KTMSK IS STARTING ADDRESS OF MASK ARRAY.
      KTMSK = ILAST - NI

C     ALLOCATE STORAGE FOR ITEM ABUNDANCES - AINDX(NI).
      KAINDX = KTMSK - NI
      ILAST = KAINDX

      RETURN
      END
      SUBROUTINE INITAX (NI, ILAST)                                         MAIN

C  REVISED 7-SEP-94.
C  ALLOCATES STORAGE FOR TAXON RECORD POINTERS USED BY THE DIRECTIVE
C  `TREAT CHARACTER AS VARIABLE'

C  NI RECEIVES THE NUMBER OF ITEMS
C  ILAST RECEIVES AND RETURNS THE INDEX OF THE LAST WORD OF STORAGE
C   ALLOCATED.

      COMMON /ADRXXX/ KT,KBRULE,KERULE,KTAXON,KTXNAM,KFMEM,KNSTAT,
     *                KFO,KFREC,KFLADD,KIFL,KDIO,KFN,KDUP,KBREC,
     *                KFLAG,KA,KLIST,KCDEP,KALOG2,KNBO,KBRUL,KNEO,KNBN,
     *                KERUL,KNEN,KNCO,KNOCC,KNCN,KDIV,
     *                KR,KRULE,KRINDX,KUSED,KAINDX,KTAXA,
     *                KWRK,KWRK1,KWRK2,KNLSET,KKOSET,KJBSET,KFMSK,KTMSK,
     *                KTMP,KBCMT,KBPRE,KBTYP,KCMT,KTYPMK

C     ALLOCATE STORAGE
C     KTAXA IS STARTING ADDRESS OF ARRAY.
      KTAXA = ILAST - NI
      ILAST = KTAXA

      RETURN
      END
      SUBROUTINE INITMP (NC, NI, ILAST, NSD, LWRK, NOTMP)                   MAIN

C  REVISED 7-SEP-94.
C  INITIALISES STORAGE FOR TEMPORARY WORKING ARRAYS.

C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  NI RECEIVES THE NUMBER OF ITEMS.
C  ILAST RECEIVES AND RETURNS THE INDEX OF THE LAST WORD OF STORAGE
C   ALLOCATED.
C  NSD RETURNS SPACE AVAILABLE FOR PRESET CHARACTERS.
C  LWRK RETURNS THE LENGTH OF THE WORKING ARRAY IWRK.
C  NOTMP RECEIVES AND RETURNS WHETHER TEMPORARY STORAGE HAS BEEN
C   ALLOCATED.

      COMMON /ADRXXX/ KT,KBRULE,KERULE,KTAXON,KTXNAM,KFMEM,KNSTAT,
     *                KFO,KFREC,KFLADD,KIFL,KDIO,KFN,KDUP,KBREC,
     *                KFLAG,KA,KLIST,KCDEP,KALOG2,KNBO,KBRUL,KNEO,KNBN,
     *                KERUL,KNEN,KNCO,KNOCC,KNCN,KDIV,
     *                KR,KRULE,KRINDX,KUSED,KAINDX,KTAXA,
     *                KWRK,KWRK1,KWRK2,KNLSET,KKOSET,KJBSET,KFMSK,KTMSK,
     *                KTMP,KBCMT,KBPRE,KBTYP,KCMT,KTYPMK

      IF (NC.GT.0.AND.NI.GT.0)  THEN
C       ALLOCATE STORAGE FOR TEMPORARY WORKING ARRAYS.
        LWRK = MAX0 (NC,NI)
        KWRK = ILAST - LWRK
        KWRK1 = KWRK - NC
        KWRK2 = KWRK1 - NC

C       SET TEMPORARY STORAGE SIZE FOR PRESET CHARACTERS.
        ILAST = KWRK2
        NSD = ILAST - 1

        NOTMP = 0
      ENDIF

      RETURN
      END
      SUBROUTINE RCHAR (R, FO, NSTAT, FMEM, FREC, FLADDR,                   MAIN
     * IFL, RINDX, IWRK, FMSK)

C  REVISED 02-APR-97.
C  READS CHARACTER PARAMETERS.

C  R RETURNS THE VALUE OF THE RELIABILITY FUNCTION.
C  FO RETURNS THE OLD (ORIGINAL) FEATURE NUMBERS.
C  NSTAT RECEIVES THE NUMBERS OF STATES.
C  FMEM RETURNS THE ADDRESS IN MEMORY OF THE FEATURE DESCRIPTION.
C  FREC RETURNS THE RECORD ADDRESS OF THE FEATURE DESCRIPTION.
C  FLADDR RETURNS ADDRESS (IN IFL) OF LENGTHS OF THE FEATURE/STATE
C   DESCRIPTIONS.
C  IFL RETURNS THE LENGTHS OF THE FEATURE/STATE DESCRIPTIONS.
C  RINDX RECEIVES THE RELIABILITY INDEX.
C  IWRK RECEIVES WORKING SPACE OF LENGTH NFR.
C  FMSK RECEIVES THE FEATURE MASK.

      COMMON /DIMXXX/ LDM,NFR,NF,NTM,NTM1,NTU,NTH,NWORD,NDESC,LCDEP
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /MNSXXX/ MNS,MNS1,MNS2,MNS3
      COMMON /PARXXX/ NFB,NFE,JFB,NVAR,NEWLN,NT,NTD,NTA,NO,KN,NUSED,
     *                INCOMP,VARW,NTR,RBASE,ABASE,REUSE,VARYWT,NCONF,
     *                NSET,RES,ITUNKV,IADCNO,ITCHV,IRTF,IHTML
      COMMON /RECXXX/ MSKTAX,NAMTAX,MSKCHR,NSTREC,IDPREC,IRLREC,ICREC,
     *                IHDREC,NSTTAX,IABREC

      REAL R(NF),RINDX(NFR)
      INTEGER FO(NF),NSTAT(NF),FMEM(NF),FREC(NF),FLADDR(NF),
     * IFL(NDESC),IWRK(NFR),FMSK(NFR)

C-    READ PARAMETERS PERTAINING TO CHARACTER DESCRIPTIONS.

C     NUMBERS OF STATES.
      CALL RDDAI (IWRK, NFR, NSTREC, LUNC)
 
C     EXCLUDE UNSUITABLE CHARACTERS WHICH MAY HAVE BEEN INCLUDED BY
C     AN INCLUDE/EXCLUDE CHARACTERS DIRECTIVE.
      DO I = 1, NFR
        IF (IWRK(I).LE.1.OR.IWRK(I).GT.MNS) FMSK(I) = 0
      END DO


      J = 0
      DO 20 JF = 1, NFR
        IF (FMSK(JF).EQ.0)  GOTO 20
        J = J + 1
        RX = MIN(RINDX(JF),10.)
        R(J) = RBASE**(5.-RX)
        NSTAT(J) = IWRK(JF)
        FO(J) = JF
        FMEM(J) = 0
   20   CONTINUE

C-    READ RECORD ADDRESSES OF CHARACTER DESCRIPTIONS.
      CALL RDDAI (IWRK, NFR, ICREC, LUNC)

      J = 0
      L = 0
      DO 50 JF = 1, NFR
        IF (FMSK(JF).EQ.0)  GOTO 50
        J = J + 1
        FREC(J) = IWRK(JF)
        FLADDR(J) = L + 1
        NS = NSTAT(J) + 1
        CALL RDDAI (IFL(L+1), NS, FREC(J), LUNC)
        L = L + NS
   50   CONTINUE

      RETURN
      END
      SUBROUTINE RTAX (D, A, T, DUP, NSTAT, FO,                             MAIN
     * FLAG, ITXNAM, DIO, FN, ICDEP, FMSK,
     * AINDX, TMSK, TAXCHV, IWRK, JWRK, TAXON, LTAXON)

C  REVISED 8-SEP-94.
C  READS TAXA AND CHARACTER VALUES.

C  15/6/87. MASKED OUT TAXA NOT READ.

C  D RETURNS THE CHARACTER-TAXON MATRIX.
C  A RETURNS THE ABUNDANCE INDICES.
C  T RETURNS THE TAXON ID. AS A NUMERIC VALUE.
C  DUP RETURNS WHETHER THE ITEM IS DUPLICATED.
C  NSTAT RECEIVES THE NUMBERS OF FEATURE STATES.
C  FO RECEIVES THE ORIGINAL FEATURE NUMBERS.
C  FLAG RETURNS
C  ITXNAM RETURNS THE STARTING LOCATIONS (IN TAXON) OF THE ITEM NAMES.
C  DIO RECEIVES WORKING SPACE OF LENGTH OF NFR.
C  FN RECEIVES THE NEW FEATURE NUMBERS.
C  ICDEP RETURNS THE FEATURE DEPENDENCIES.
C  FMSK RECEIVES THE FEATURE MASK.
C  AINDX RECEIVES THE ITEM ABUNDANCE INDICES.
C  TMSK RECEIVES THE ITEM MASK.
C  TAXCHV RECEIVES RECORDS POINTERS FOR TAXA WITH VARIABLE CHARACTERS
C  IWRK RECEIVES WORKING SPACE OF LENGTH NTR.
C  JWRK RECEIVES WORKING SPACE OF LENGTH NFR.
C  TAXON RETURNS THE TAXON NAMES.
C  LTAXON RECEIVES THE LENGTH OF TAXON.

      COMMON /DIMXXX/ LDM,NFR,NF,NTM,NTM1,NTU,NTH,NWORD,NDESC,LCDEP
      COMMON /ERRXXX/ IERR
      COMMON /LRECDA/ LRECDA,LCREC
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /MATXXX/ JU,JF,JS,I,J,NL,JB,NFP,NB,NE
      COMMON /PARXXX/ NFB,NFE,JFB,NVAR,NEWLN,NT,NTD,NTA,NO,KN,NUSED,
     *                INCOMP,VARW,NTR,RBASE,ABASE,REUSE,VARYWT,NCONF,
     *                NSET,RES,ITUNKV,IADCNO,ITCHV,IRTF,IHTML
      COMMON /RECXXX/ MSKTAX,NAMTAX,MSKCHR,NSTREC,IDPREC,IRLREC,ICREC,
     *                IHDREC,NSTTAX,IABREC
      COMMON /TPSXXX/ ITPSET,MAXTYPMK,NTYPMK,LTYPMK,INTYPMKS

      REAL A(NTU),AINDX(NTR)
      INTEGER D(LDM),T(NTU),DUP(NTU),NSTAT(NF),FO(NF),
     * FLAG(NTM),ITXNAM(NTM1),DIO(NFR),FN(NFR),ICDEP(LCDEP),FMSK(NFR),
     * TMSK(NTR),TAXCHV(NTR),IWRK(NTR),JWRK(NFR)
      CHARACTER*1 TAXON(LTAXON),MTAXON(256)

C    SET UP TABLE OF CORRESPONDENCES BETWEEN ORIGINAL AND NEW CHARACTER
C     NUMBERS.
 
      DO 110 L = 1, NFR
        FN(L) = 0
  110   CONTINUE
      DO 120 K = 1, NF
        L = FO(K)
        FN(L) = K
  120   CONTINUE
 
C-    READ CHARACTER DEPENDENCIES.
      IF (LCDEP.GT.1)  CALL RDDAI (ICDEP, LCDEP, IDPREC, LUNT)
 
C--READ AND STORE TAXA NAMES AND DATA MATRIX.

      MI = 0
      ITSTR = 0
      ID = 0
      IREAD = 1

C     READ LENGTHS OF TAXON NAMES.
      CALL RDDAI (IWRK, NTR, NAMTAX, LUNT)
 
C     POSITION ITEMS FILE AT START OF DATA.
      IREC = 1

C     TAXON NAME.
    1 LT = IWRK(IREAD)
      L = LT
      J = ITSTR
    5 IF (L.LE.0)  GOTO 8
        LL = MIN0(L,LCREC)
        IREC = IREC + 1
        IF (TMSK(IREAD).NE.0) READ (LUNT,REC=IREC) (TAXON(I),I=J+1,J+LL)
        J = J + LL
        L = L - LL
      GOTO 5

    8 IF (TMSK(IREAD).NE.0 .AND. ITPSET.LT.0)
     *  CALL REMTYP (TAXON(ITSTR+1), LT)

C     TAXON DATA.
   10 L = NFR
      J = 0
   11 IF (L.LE.0)  GOTO 15
        LL = MIN0(L,LRECDA)
        IREC = IREC + 1
        IF (TMSK(IREAD).NE.0) READ (LUNT,REC=IREC) (DIO(I),I=J+1,J+LL)
        J = J + LL
        L = L - LL
      GOTO 11

   15 IF (TMSK(IREAD).EQ.0)  GOTO 100
 
      MI = MI + 1
C     COMPARE TAXON NAMES.
      IF (IREAD.GT.1) THEN
        IF (LM.NE.LT)  GOTO 30
        DO 20 I = 1, LM
          IF (MTAXON(I).NE.TAXON(ITSTR+I))  GOTO 30
   20     CONTINUE
        GOTO 40
      ENDIF

C-    NEW NAME.
   30 IF (ITSTR+LT.GT.LTAXON)  GOTO 300
      ITEM = 0
      ID = ID + 1
      LM = MIN0(LT, 256)
      DO 31 I = 1, LM
        MTAXON(I) = TAXON(ITSTR+I)
   31   CONTINUE
      ITXNAM(ID) = ITSTR + 1
      ITSTR = ITSTR + LT
C-
   40 ITEM = ITEM + 1
      IF (ITEM.LE.1)  THEN
        DUP(MI) = 0
        FLAG(ID) = 1
      ELSE
        DUP(MI-1) = 1
        DUP(MI) = 2
        FLAG(ID) = 2
      ENDIF

      T(MI) = ID
      A(MI) = ABASE**(AINDX(IREAD)-5.)
      I = MI
 
      CALL CPYTAX (D, LDM, DIO, FN, FMSK, NFR, ICDEP, LCDEP, NSTAT, NF,
     * MI, NFP, ITUNKV, TAXCHV(IREAD), ITCHV, JWRK)

      IF (MI.GE.NTM.OR.IERR.GT.100)  GOTO 200

  100 IREAD = IREAD + 1
      GOTO 1


  200 NTD = ID
      ITXNAM(ID+1) = ITSTR + 1
      GOTO 350

  300 CALL ERROR (0, 'Insufficient room to store taxon names.%')
      GOTO 400

  350 CONTINUE
  400 RETURN
      END
      SUBROUTINE STORAL (IWRK, LWRK, IWRK1, FMSK)                           MAIN

C* REVISED 25-FEB-99.
C* ALLOCATES STORAGE.

C  IWRK RECEIVES WORKING SPACE OF LENGTH LWRK.
C  LWRK = MAX (NFR,NTR).
C  IWRK1 RECEIVES WORKING SPACE OF LENGTH LFD.
C  FMSK RECEIVES THE CHARACTER MASK.

      COMMON /ADRXXX/ KT,KBRULE,KERULE,KTAXON,KTXNAM,KFMEM,KNSTAT,
     *                KFO,KFREC,KFLADD,KIFL,KDIO,KFN,KDUP,KBREC,
     *                KFLAG,KA,KLIST,KCDEP,KALOG2,KNBO,KBRUL,KNEO,KNBN,
     *                KERUL,KNEN,KNCO,KNOCC,KNCN,KDIV,
     *                KR,KRULE,KRINDX,KUSED,KAINDX,KTAXA,
     *                KWRK,KWRK1,KWRK2,KNLSET,KKOSET,KJBSET,KFMSK,KTMSK,
     *                KTMP,KBCMT,KBPRE,KBTYP,KCMT,KTYPMK
      COMMON /CMTXXX/ LCMT
      COMMON /DIMXXX/ LDM,NFR,NF,NTM,NTM1,NTU,NTH,NWORD,NDESC,LCDEP
      COMMON /FMTXXX/ ITAB,LFOUT,LTXOUT,KCOLS,MAXWID
      COMMON /LINEXX/ LINE
      CHARACTER*200 LINE
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /LUUXXX/ LUNOUT
      COMMON /MATXXX/ JU,JF,JS,I,J,NL,JB,NFP,NB,NE
      COMMON /MNSXXX/ MNS,MNS1,MNS2,MNS3
      COMMON /MSTXXX/ MSTOR,MSTORC
      COMMON /NCHXXX/ NCHAR
      COMMON /NSTXXX/ NSTOR
      COMMON /PACXXX/ NPACK
      COMMON /PARXXX/ NFB,NFE,JFB,NVAR,NEWLN,NT,NTD,NTA,NO,KN,NUSED,
     *                INCOMP,VARW,NTR,RBASE,ABASE,REUSE,VARYWT,NCONF,
     *                NSET,RES,ITUNKV,IADCNO,ITCHV,IRTF,IHTML
      COMMON /PRFXXX/ NP(8)
      COMMON /RECXXX/ MSKTAX,NAMTAX,MSKCHR,NSTREC,IDPREC,IRLREC,ICREC,
     *                IHDREC,NSTTAX,IABREC
      COMMON /TPSXXX/ ITPSET,MAXTYPMK,NTYPMK,LTYPMK,INTYPMKS

      INTEGER IWRK(LWRK),IWRK1(NFR),FMSK(NFR)

C--READ NUMBERS OF STATES INTO TEMPORARY BUFFER.
      CALL RDDAI (IWRK, NFR, NSTREC, LUNC)
      CALL RDDAI (IWRK1, NFR, NSTTAX, LUNT)

C     COMPARE NUMBERS OF STATES ON ITEMS AND CHARACTERS FILES.
      DO 10 JF = 1, NFR
        IF (IWRK(JF).NE.IWRK1(JF))
     *   CALL FERROR ('Items and characters files do not match.%')
   10   CONTINUE

C     CALCULATE NUMBER OF CHARACTER DESCRIPTION STRINGS TO BE STORED.
      NDESC = 0
      DO 20 JF = 1, NFR
        IF (FMSK(JF).EQ.0)  GOTO 20
        NDESC = NDESC + IWRK(JF) + 1
   20   CONTINUE

      IF (VARYWT.GT.0.) THEN
        VARW = (1.-VARYWT)/VARYWT
      ELSE
        VARW = 0.
      ENDIF


C--ALLOCATE STORAGE.

C     NO. WORDS REQUIRED TO STORE NF FEATURES, PACKED NPACK PER WORD.
      NFP = (NF+NPACK-1)/NPACK
C     AVERAGE NUMBER OF WORDS TO STORE A TAXON NAME.
      NWORD = 256/NCHAR
C     BUFFER SPACE FOR CHARACTER DESCRIPTIONS WHEN PRINTING BRACKETTED
C     KEY. (USES DATA-MATRIX SPACE, WHICH IS NO LONGER REQUIRED AS
C     STRUCTURE IS STORED ELSEWHERE.)
C     MINBUF = 300*MNS/NCHAR

      NT = NTM
      NTA = NTM
      N1 = NFP*NTM
C     N1 = MAX(NFP*NTM,MINBUF)
 
C** NEW VERSION 14.3.96
      N2 = (2+NWORD)*NTM + 1 + 7*NF + NDESC + LCDEP  + 2*NFR + 
     * 3*NSET + LTYPMK + (LCMT+NCHAR-1)/NCHAR +
C   ALLOCATED IN SUBR. INITMP
     * LWRK + 2*NFR +
C   ALLOCATED IN SUBR. INITEM
     * 2*NTR +
C   ALLOCATED IN SUBR. INICHR
     * 3*NFR
 
C     OPTIONAL ARRAY IF 'TREAT TAXA AS VARIABLE' USED
      IF (ITCHV.NE.0) N2 = N2 + NTR
 
C** REMOVED TO TEST NEW VERSION 14.2.96
C**      N2 = (2+NWORD)*NTM + 1 + 7*NF + NDESC + LCDEP  + 4*NFR + LWRK +
C**     *  NTR + 3*NSET + NTR + NFR
      NSTOR = N1 + (19*NTM)/2  + N2
      IF (NSTOR.GT.MSTOR)  GO TO 100
      IF (NF.GT.511)  GO TO 110                                               =*
      NTU = (2*(MSTOR-N2)+1)/(2*NFP+19)
C     IF (NFP*NTU.LT.MINBUF) NTU = (2*(MSTOR-MINBUF-N2)+1)/19
      IF (RES.GE.1.) NTU = RES*NTM
      NTH = NTU/2
      LDM = NFP*NTU
C     LDM = MAX(NFP*NTU,MINBUF)

      NSTOR = LDM + N2 + (19*NTU)/2
      IF (NSTOR.GT.MSTOR)  GOTO 100

      LUNOUT = LUNL
      CALL JSTI (NF, 0, LTXOUT)
      CALL JSTSTR ('characters included.', 1, LTXOUT)
      CALL JSTI (NTM, 0, LTXOUT)
      CALL JSTSTR ('items included.', 1, LTXOUT)
      CALL JSTSTR ('Storage available for', 0, LTXOUT)
      CALL JSTI (NTU, 0, LTXOUT)
      CALL JSTSTR ('items.', 2, LTXOUT)

C     T(NTU) - TAXON IDENTIFIER AS A NUMERIC.
      KT = LDM + 1

C     BRULE(NTU).
      KBRULE = KT + NTU

C     ERULE(NTU).
      KERULE = KBRULE + NTU

C     TAXON(NWORD*NTM) - TAXON NAMES.
      KTAXON = KERULE + NTU

C     ITXNAM(NTM1) - POINTERS TO START OF TAXON NAMES.
      NTM1 = NTM + 1
      KTXNAM = KTAXON + NWORD*NTM

C     FMEM(NF) - MEMORY ADDRESSES OF FEATURE DESCRIPTIONS.
      KFMEM = KTXNAM + NTM1

C     NSTAT(NF) - NUMBERS OF STATES.
      KNSTAT = KFMEM + NF

C     FO(NF) - ORIGINAL FEATURE NUMBERS.
      KFO = KNSTAT + NF

C     FREC(NF) - RECORD ADDRESS OF FEATURE DESCRIPTIONS.
      KFREC = KFO + NF

C     FLADDR(NF) - ADDRESS (IN IFL) OF FEATURE/STATE LENGTHS.
      KFLADD = KFREC + NF

C     IFL(NDESC) - LENGTHS OF FEATURE/STATE DESCRIPTIONS.
      KIFL = KFLADD + NF

C     DIO(NFR).
      KDIO = KIFL + NDESC

C     FN(NFR).
      KFN = KDIO + NFR

C     DUP(NTU), BREC(NTU).
      KDUP = KFN + NFR
      KBREC = KDUP

C     FLAG(NTM).
      KFLAG = KDUP + NTU

C     A(NTU) - ABUNDANCE, LIST. (IN STRUCT AND PRTKEY, LIST USES ALL
C      THE STORAGE ABOVE THIS ADDRESS.)
      KA = KFLAG + NTM
      KLIST = KA

C     ICDEP(LCDEP) - CHARACTER DEPENDENCIES.
      KCDEP = KA + NTU

C     ALOG2(NTU).
      KALOG2 = KCDEP + LCDEP

C     NBO(NTH), BRUL(NTU) (IN WRTKEY. USES STORAGE OF NEO ALSO.)
      KNBO = KALOG2 + NTU
      KBRUL = KNBO

C     NEO(NTH).
      KNEO = KNBO + NTH

C     NBN(NTH), ERUL(NTU) (IN WRTKEY. USES STORAGE OF NEN ALSO.)
      KNBN = KNBO + NTU
      KERUL = KNBN

C     NEN(NTH).
      KNEN = KNBN + NTH

C     NCO(NTH), NOCC(NTU) (IN WRTKEY. USES STORAGE OF NCN ALSO.)
      KNCO = KNBN + NTU
      KNOCC = KNCO

C     NCN(NTH).
      KNCN = KNCO + NTH

C     DIV(NTH).
      KDIV = KNCO + NTU

C     USED(NF).
      KUSED = KDIV + NTH

C     RULE(NF).
      KRULE = KUSED + NF
      KLAST = KRULE + NF

C     JBSET(NSET),KOSET(NSET),NLSET(NSET).
      IF (NSET.GT.0)  THEN
        KJBSET = KRULE + NF
        KKOSET = KJBSET + NSET
        KNLSET = KKOSET + NSET
        KLAST = KNLSET + NSET
      ENDIF
 
C     ITYPMK(LTYPMK).
      IF (NTYPMK.GT.0)  THEN
        KTYPMK = KLAST
        KLAST = KLAST + LTYPMK
      ENDIF
 
C     CMT(LCMT) - CHAR*1 ARRAY.
      IF (LCMT.GT.0) THEN
        KCMT = (KLAST-1)*NCHAR + 1
        KLAST = KLAST + (LCMT+NCHAR-1)/NCHAR
      ENDIF


      IF (KLAST.GT.KWRK)  GOTO 100
C     STORAGE AVAILABLE IN STRUCT FOR STORING KEY STRUCTURE.                  =/
      MSTOR = MSTOR - KLIST

      RETURN

C--ERROR MESSAGES.
  100 WRITE(LINE,102) MSTOR,NSTOR
  102 FORMAT('Insufficient storage -',I8,' locations available,',i8,
     1 ' required.%')
      CALL ERROR (0, LINE)
      WRITE(LINE,103) NFR,NF,NTR,NTM
  103 FORMAT(I5,' characters,',I5,' included.',I5,' items,',I5,
     * ' included.%')
      CALL ERROR (0, LINE)
      WRITE(LINE,104) NSET,(NP(I),I=1,6)
  104 FORMAT(I5,' Preset characters. Output flags -',6I2,'%')
      CALL FERROR (LINE)
  110 WRITE(LINE,112) NFR,NF
  112 FORMAT('Too many characters -',I5,' read,',i5,' included.%')
      CALL FERROR (LINE)
      END
