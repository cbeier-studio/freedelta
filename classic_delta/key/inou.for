      LOGICAL FUNCTION ADDDIR(NAME)
      use clib
 
C  REVISED 17-SEP-98.
C  ATTEMPTS TO CREATE NEW DIRECTORY USING NAME. RETURNS TRUE IF SUCCESSFUL.
 
C  NAME RECEIVES THE DIRECTORY NAME.
 
      CHARACTER*(*) NAME
C      LOGICAL ISADIR
      LOGICAL DIREXISTS
      
      ADDDIR = .FALSE.
      DO ILEN = LEN(NAME), 1, -1
         IF (NAME(ILEN:ILEN).NE.' ') GOTO 10
      ENDDO
      
   10 IF (ILEN.LE.0) GOTO 1000
      IF (NAME(ILEN:ILEN).EQ.'\'.AND.
     *       ILEN.GT.1) ILEN = ILEN - 1
	
C     Find beginning of directory name taking into account UNC file names
C     of the form \\machine_name\...
      IB = 2
      IF (NAME(1:1).EQ.CHAR(KDBSLSH).AND.
     *    NAME(2:2).EQ.CHAR(KDBSLSH)) THEN
   14   IB = IB + 1
c        IF (IB.GT.ILEN)  GOTO 30
        IF (IB.GT.ILEN)  GOTO 1000
        IF (NAME(IB:IB).EQ.CHAR(KDBSLSH)) THEN
          IB = IB + 1
c          GOTO 15
          GOTO 1000
        ENDIF
        GOTO 14
      ENDIF
 
      DO 20 JLEN = 2, ILEN - 1
        IF (NAME(JLEN:JLEN).EQ.'\') THEN
          IF (NAME(JLEN-1:JLEN-1).EQ.':') GOTO 20
          IF (DIREXISTS(NAME, JLEN-1)) GOTO 20
          IF (MKDIR(NAME(:JLEN-1)//char(0)).eq.0) GOTO 20
          GOTO 1000
       ENDIF
   20 CONTINUE

      IF (MKDIR(NAME(:ILEN)//char(0)).eq.0) ADDDIR = .TRUE.
	
1000  RETURN
      END
      LOGICAL FUNCTION CHKDIRY (DIRNAME, LDIR)
 
C     REVISED 19-APR-99.
C     CHECKS IF A SPECIFIED DIRECTORY EXISTS. IF NOT, ATTEMPTS TO CREATE IT.
C     RETURNS IF THE DIRECTORY EXISTS.
 
C     DIRNAME RECEIVES THE DIRECTORY NAME.
C     LDIR RECEIVES THE LENGTH OF THE DIRECTORY NAME.
 
      CHARACTER*(*) DIRNAME
      LOGICAL ADDDIR, DIREXISTS
      CHARACTER*80 F,S

 
      F = DIRNAME(1:LDIR)
      LF = LDIR
      IF (F(LF:LF).NE.'\')  THEN
        LF = LF + 1
        F(LF:LF) = '\'
      ENDIF
C     MAKE INTO A FILENAME BEFORE CALL TO EXNAME
      F(LF+1:LF+1) = '.'
 
C     THE CALL BELOW IS REQUIRED TO FILL OUT RELATIVE PATHNAMES IN WINDOWS VERSION
      CALL EXNAME(F, S)
      LF = LSTRB(F)
C     REMOVE '.' FROM NAME
      LF = LF - 1
 
      CHKDIRY = .FALSE.
      IF (DIREXISTS(F, LF))  THEN
        CHKDIRY = .TRUE.
      ELSE
        IF (ADDDIR(F(1:LF)))  CHKDIRY = .TRUE.
      ENDIF
 
      RETURN
      END
      SUBROUTINE CONPHR (ICONPH, LCPH, NCPH, NSIG, IBUF, JBUF, JL,          INOU
     * ICPH, JE)
C
C  REVISED 14/2/86.
C  DETERMINES THE NUMBER ASSOCIATED WITH A CONTROL PHRASE.
C
C  ICONPH, DIMENSIONED (LCPH,NCPH), RECEIVES THE LIST OF CONTROL
C    PHRASES. ICONPH(1,ICPH) TO ICONPH(LCPH,ICPH) CONTAIN THE ICPH-TH
C    CONTROL PHRASE. EACH WORD OF THE PHRASE IS REPRESENTED BY ITS
C    FIRST NSIG LETTERS (FILLED OUT WITH BLANKS IF THE WORD IS SHORTER
C    THAN NSIG).
C    THUS, A PHRASE MAY CONTAIN AT MOST (LCPH+NSIG-1)/NSIG WORDS.
C    IF THE NUMBER OF WORDS IN THE PHRASE IS LESS THAN THIS, THE
C    REMAINING ELEMENTS OF ICONPH MUST BE FILLED OUT WITH BLANKS.
C    EACH CONTROL PHRASE MUST HAVE A DISTINCT REPRESENTATION ON
C    THE LIST. REPRESENTATIONS DIFFERING ONLY BY HAVING BLANKS
C    INSTEAD OF NON-BLANKS IN SOME ELEMENTS ARE NOT DISTINCT.
C  LCPH RECEIVES THE NUMBER OF ELEMENTS RESERVED IN ICONPH FOR THE
C    REPRESENTATION OF EACH CONTROL PHRASE. IT MUST NOT BE GREATER THAN
C    THE LENGTH OF THE LOCAL ARRAY JCONPH.
C  NCPH RECEIVES THE NUMBER OF CONTROL PHRASES IN ICONPH.
C  NSIG RECEIVES THE NUMBER OF SIGNIFICANT SYMBOLS IN EACH WORD OF
C    THE CONTROL PHRASE.
C  IBUF RECEIVES THE ARRAY TO BE TESTED FOR THE PRESENCE OF A CONTROL
C    PHRASE. IBUF SHOULD CONTAIN ONE SYMBOL PER ARRAY ELEMENT.
C  JBUF RECEIVES THE POSITION IN IBUF OF THE START OF THE FIELD WHICH
C    WILL BE SCANNED FOR THE CONTROL PHRASE.
C  JL RECEIVES THE POSITION IN IBUF OF THE END OF THE FIELD WHICH
C    WILL BE SCANNED FOR THE CONTROL PHRASE.
C  ICPH RETURNS THE NUMBER OF THE CONTROL PHRASE, OR 0 IF THE PHRASE IS
C    INVALID.
C  JE. IF THE CONTROL PHRASE IS VALID, JE RETURNS THE POSITION IN IBUF
C    IMMEDIATELY AFTER THE END OF THE PHRASE. IF IT IS INVALID, JE
C    RETURNS THE POSITION OF THE FIRST INVALID SYMBOL, OR, IF THE FIELD
C    WAS EXHAUSTED BEFORE FINDING A VALID PHRASE, JL+1.
C
C  JBUF MUST NOT BE GREATER THAN JL.
C  THE PHRASE MAY BE PRECEDED BY BLANKS.
C
      CHARACTER*1 ICONPH(LCPH,NCPH),JCONPH(8)
      CHARACTER*(*) IBUF

      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
C
      DO 10 I = 1, LCPH
   10   JCONPH(I) = BLANK
      ISIG = 1
      JCW = 1
      ICPH = 1
      JF = JBUF
C
C-    SKIP OVER BLANKS.
   12 IF (JF.GT.JL)  GO TO 300
        IF (IBUF(JF:JF).NE.BLANK)  GO TO 20
        JF = JF + 1
        GO TO 12
C
C--   TEST FOR CONTROL PHRASE.
   20 JCONPH(JCW) = IBUF(JF:JF)
C
C-      LOOK FOR MATCH OF LETTERS CONSIDERED SO FAR.
   30   DO 40 I = 1, JCW
            IF (JCONPH(I).NE.ICONPH(I,ICPH))  GO TO 60
   40       CONTINUE
          DO 50 I = 1, LCPH
            IF (JCONPH(I).NE.ICONPH(I,ICPH))  GO TO 100
   50       CONTINUE
          GO TO 500
   60     IF (ICPH.GE.NCPH)  GO TO 300
          ICPH = ICPH + 1
          GO TO 30
C
C-      PARTIAL MATCH FOUND, BUT NOT COMPLETE MATCH.
C-      POSITION POINTERS FOR NEXT SIGNIFICANT LETTER IN PHRASE.
  100   IF (ISIG.GE.NSIG)  GO TO 150
C       NEXT LETTER IS SIGNIFICANT (UNLESS FIELD IS EXHAUSTED).
        IF (IBUF(JF:JF).EQ.BLANK)  GO TO 200
        JF = JF + 1
        IF (JF.GT.JL)  GO TO 300
        GO TO 200
C       NO MORE SIGNIFICANT LETTERS IN CURRENT WORD. MOVE TO
C       START OF NEXT WORD.
  150   ISIG = 0
  160   IF (IBUF(JF:JF).EQ.BLANK)  GO TO 170
          JF = JF + 1
          IF (JF.GT.JL)  GO TO 300
          GO TO 160
  170   IF (IBUF(JF:JF).NE.BLANK)  GO TO 200
          JF = JF + 1
          IF (JF.GT.JL)  GO TO 300
          GO TO 170
C       INCREMENT OTHER POINTERS.
  200   ISIG = ISIG + 1
        JCW = JCW + 1
        GO TO 20
C
C--
C-    INVALID SYMBOL OR END OF FIELD.
  300 ICPH = 0
      GO TO 540
C
C-    VALID CONTROL PHRASE. SKIP PAST LAST WORD.
  500 IF (IBUF(JF:JF).EQ.BLANK)  GO TO 540
        JF = JF + 1
        IF (JF.GT.JL)  GO TO 540
        GO TO 500
C-
  540 JE = JF
      RETURN
      END
      SUBROUTINE CONTRL (ICPH, JE)                                          INOU
 
C* REVISED 7-SEP-94.
C* IDENTIFIES CONTROL PHRASE.
C
C  ICPH. IF A CONTROL PHRASE IS FOUND, ICPH RETURNS ITS NUMBER.
C    OTHERWISE, IT RETURNS 0.
C  JE. IF A CONTROL PHRASE IS FOUND, JE RETURNS THE POSITION IN IBUF
C    IMMEDIATELY AFTER THE END OF THE PHRASE. OTHERWISE, JE RETURNS
C    THE POSITION OF THE FIRST INVALID SYMBOL.

C     NUMBER OF CONTROL PHRASES - MUST AGREE WITH SUBR. PARAMS.
      PARAMETER (NCON=43)                                                     =*

      CHARACTER*1 ICON(8,NCON)
C
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
C
C     1 HEADING
      DATA ICON(1,1),ICON(2,1),ICON(3,1),ICON(4,1),ICON(5,1),
     * ICON(6,1),ICON(7,1),ICON(8,1)/'H','E',' ',' ',' ',' ',' ',' '/
C     2 RBASE
      DATA ICON(1,2),ICON(2,2),ICON(3,2),ICON(4,2),ICON(5,2),
     * ICON(6,2),ICON(7,2),ICON(8,2)/'R','B',' ',' ',' ',' ',' ',' '/
C     3 ABASE
      DATA ICON(1,3),ICON(2,3),ICON(3,3),ICON(4,3),ICON(5,3),
     * ICON(6,3),ICON(7,3),ICON(8,3)/'A','B',' ',' ',' ',' ',' ',' '/
C     4 REUSE
      DATA ICON(1,4),ICON(2,4),ICON(3,4),ICON(4,4),ICON(5,4),
     * ICON(6,4),ICON(7,4),ICON(8,4)/'R','E',' ',' ',' ',' ',' ',' '/
C     5 VARYWT
      DATA ICON(1,5),ICON(2,5),ICON(3,5),ICON(4,5),ICON(5,5),
     * ICON(6,5),ICON(7,5),ICON(8,5)/'V','A',' ',' ',' ',' ',' ',' '/
C     6 INCLUDE CHARACTERS
      DATA ICON(1,6),ICON(2,6),ICON(3,6),ICON(4,6),ICON(5,6),
     * ICON(6,6),ICON(7,6),ICON(8,6)/'I','N','C','H',' ',' ',' ',' '/
C     7 EXCLUDE CHARACTERS
      DATA ICON(1,7),ICON(2,7),ICON(3,7),ICON(4,7),ICON(5,7),
     * ICON(6,7),ICON(7,7),ICON(8,7)/'E','X','C','H',' ',' ',' ',' '/
C     8 INCLUDE ITEMS
      DATA ICON(1,8),ICON(2,8),ICON(3,8),ICON(4,8),ICON(5,8),
     * ICON(6,8),ICON(7,8),ICON(8,8)/'I','N','I','T',' ',' ',' ',' '/
C     9 EXCLUDE ITEMS
      DATA ICON(1,9),ICON(2,9),ICON(3,9),ICON(4,9),ICON(5,9),
     * ICON(6,9),ICON(7,9),ICON(8,9)/'E','X','I','T',' ',' ',' ',' '/
C     10 CHARACTER RELIABILITIES
      DATA ICON(1,10),ICON(2,10),ICON(3,10),ICON(4,10),ICON(5,10),
     * ICON(6,10),ICON(7,10),ICON(8,10)/'C','H','R','E',' ',' ',' ',' '/
C     11 ITEM ABUNDANCES
      DATA ICON(1,11),ICON(2,11),ICON(3,11),ICON(4,11),ICON(5,11),
     * ICON(6,11),ICON(7,11),ICON(8,11)/'I','T','A','B',' ',' ',' ',' '/
C     12 NUMBER OF CONFIRMATORY CHARACTERS
      DATA ICON(1,12),ICON(2,12),ICON(3,12),ICON(4,12),ICON(5,12),
     * ICON(6,12),ICON(7,12),ICON(8,12)/'N','U','O','F','C','O','C','H'/
C     13 PRESET CHARACTERS
      DATA ICON(1,13),ICON(2,13),ICON(3,13),ICON(4,13),ICON(5,13),
     * ICON(6,13),ICON(7,13),ICON(8,13)/'P','R','C','H',' ',' ',' ',' '/
C     14 TYPESETTING MARKS
      DATA ICON(1,14),ICON(2,14),ICON(3,14),ICON(4,14),ICON(5,14),
     * ICON(6,14),ICON(7,14),ICON(8,14)/'T','Y','M','A',' ',' ',' ',' '/
C     15 OMIT TYPESETTING MARKS
      DATA ICON(1,15),ICON(2,15),ICON(3,15),ICON(4,15),ICON(5,15),
     * ICON(6,15),ICON(7,15),ICON(8,15)/'O','M','T','Y','M','A',' ',' '/
C     16 NO TABULAR KEY
      DATA ICON(1,16),ICON(2,16),ICON(3,16),ICON(4,16),ICON(5,16),
     * ICON(6,16),ICON(7,16),ICON(8,16)/'N','O','T','A','K','E',' ',' '/
C     17 NO BRACKETTED KEY
      DATA ICON(1,17),ICON(2,17),ICON(3,17),ICON(4,17),ICON(5,17),
     * ICON(6,17),ICON(7,17),ICON(8,17)/'N','O','B','R','K','E',' ',' '/
C     18 OUTPUT KEY STRUCTURE
      DATA ICON(1,18),ICON(2,18),ICON(3,18),ICON(4,18),ICON(5,18),
     * ICON(6,18),ICON(7,18),ICON(8,18)/'O','U','K','E','S','T',' ',' '/
C     19 STORAGE FACTOR
      DATA ICON(1,19),ICON(2,19),ICON(3,19),ICON(4,19),ICON(5,19),
     * ICON(6,19),ICON(7,19),ICON(8,19)/'S','T','F','A',' ',' ',' ',' '/
C     20 ALLOW IMPROPER SUBGROUPS
      DATA ICON(1,20),ICON(2,20),ICON(3,20),ICON(4,20),ICON(5,20),
     * ICON(6,20),ICON(7,20),ICON(8,20)/'A','L','I','M','S','U',' ',' '/
C     21 TREAT UNKNOWN AS INAPPLICABLE
      DATA ICON(1,21),ICON(2,21),ICON(3,21),ICON(4,21),ICON(5,21),
     * ICON(6,21),ICON(7,21),ICON(8,21)/'T','R','U','N','A','S','I','N'/
C     22 PRINT WIDTH
      DATA ICON(1,22),ICON(2,22),ICON(3,22),ICON(4,22),ICON(5,22),
     * ICON(6,22),ICON(7,22),ICON(8,22)/'P','R','W','I',' ',' ',' ',' '/
C     23 TRUNCATE TABULAR KEY AT
      DATA ICON(1,23),ICON(2,23),ICON(3,23),ICON(4,23),ICON(5,23),
     * ICON(6,23),ICON(7,23),ICON(8,23)/'T','R','T','A','K','E','A','T'/
C     24 CHARACTERS FILE
      DATA ICON(1,24),ICON(2,24),ICON(3,24),ICON(4,24),ICON(5,24),
     * ICON(6,24),ICON(7,24),ICON(8,24)/'C','H','F','I',' ',' ',' ',' '/
C     25 ITEMS FILE
      DATA ICON(1,25),ICON(2,25),ICON(3,25),ICON(4,25),ICON(5,25),
     * ICON(6,25),ICON(7,25),ICON(8,25)/'I','T','F','I',' ',' ',' ',' '/
C     26 KEY OUTPUT FILE
      DATA ICON(1,26),ICON(2,26),ICON(3,26),ICON(4,26),ICON(5,26),
     * ICON(6,26),ICON(7,26),ICON(8,26)/'K','E','O','U','F','I',' ',' '/
C     27 KEY STRUCTURE FILE
      DATA ICON(1,27),ICON(2,27),ICON(3,27),ICON(4,27),ICON(5,27),
     * ICON(6,27),ICON(7,27),ICON(8,27)/'K','E','S','T','F','I',' ',' '/
C     28 ADD CHARACTER NUMBERS
      DATA ICON(1,28),ICON(2,28),ICON(3,28),ICON(4,28),ICON(5,28),
     * ICON(6,28),ICON(7,28),ICON(8,28)/'A','D','C','H','N','U',' ',' '/
C     29 LISTING FILE
      DATA ICON(1,29),ICON(2,29),ICON(3,29),ICON(4,29),ICON(5,29),
     * ICON(6,29),ICON(7,29),ICON(8,29)/'L','I','F','I',' ',' ',' ',' '/
C     30 KEY TYPESETTING FILE
      DATA ICON(1,30),ICON(2,30),ICON(3,30),ICON(4,30),ICON(5,30),
     * ICON(6,30),ICON(7,30),ICON(8,30)/'K','E','T','Y','F','I',' ',' '/
C     31 COMMENT
      DATA ICON(1,31),ICON(2,31),ICON(3,31),ICON(4,31),ICON(5,31),
     * ICON(6,31),ICON(7,31),ICON(8,31)/'C','O',' ',' ',' ',' ',' ',' '/
C     32 STOP AFTER COLUMN
      DATA ICON(1,32),ICON(2,32),ICON(3,32),ICON(4,32),ICON(5,32),
     * ICON(6,32),ICON(7,32),ICON(8,32)/'S','T','A','F','C','O',' ',' '/
C     33 DUMP
      DATA ICON(1,33),ICON(2,33),ICON(3,33),ICON(4,33),ICON(5,33),
     * ICON(6,33),ICON(7,33),ICON(8,33)/'D','U',' ',' ',' ',' ',' ',' '/
C     34 MATRIX DUMP
      DATA ICON(1,34),ICON(2,34),ICON(3,34),ICON(4,34),ICON(5,34),
     * ICON(6,34),ICON(7,34),ICON(8,34)/'M','A','D','U',' ',' ',' ',' '/
C     35 TYPSET STYLE
      DATA ICON(1,35),ICON(2,35),ICON(3,35),ICON(4,35),ICON(5,35),
     * ICON(6,35),ICON(7,35),ICON(8,35)/'T','Y','S','T',' ',' ',' ',' '/
C     36 TYPSET TAB
      DATA ICON(1,36),ICON(2,36),ICON(3,36),ICON(4,36),ICON(5,36),
     * ICON(6,36),ICON(7,36),ICON(8,36)/'T','Y','T','A',' ',' ',' ',' '/
C     37 PAGE LENGTH
      DATA ICON(1,37),ICON(2,37),ICON(3,37),ICON(4,37),ICON(5,37),
     * ICON(6,37),ICON(7,37),ICON(8,37)/'P','A','L','E',' ',' ',' ',' '/
C     38 TREAT CHARACTER AS VARIABLE
      DATA ICON(1,38),ICON(2,38),ICON(3,38),ICON(4,38),ICON(5,38),
     * ICON(6,38),ICON(7,38),ICON(8,38)/'T','R','C','H','A','S','V','A'/
C     39 INPUT FILE
      DATA ICON(1,39),ICON(2,39),ICON(3,39),ICON(4,39),ICON(5,39),
     * ICON(6,39),ICON(7,39),ICON(8,39)/'I','N','F','I',' ',' ',' ',' '/
C     40 OUTPUT FORMAT RTF
      DATA ICON(1,40),ICON(2,40),ICON(3,40),ICON(4,40),ICON(5,40),
     * ICON(6,40),ICON(7,40),ICON(8,40)/'O','U','F','O','R','T',' ',' '/
C     41 OUTPUT FORMAT HTML
      DATA ICON(1,41),ICON(2,41),ICON(3,41),ICON(4,41),ICON(5,41),
     * ICON(6,41),ICON(7,41),ICON(8,41)/'O','U','F','O','H','T',' ',' '/
C     42 PRINT COMMENT
      DATA ICON(1,42),ICON(2,42),ICON(3,42),ICON(4,42),ICON(5,42),
     * ICON(6,42),ICON(7,42),ICON(8,42)/'P','R','C','O',' ',' ',' ',' '/
C     43 OUTPUT DIRECTORY
      DATA ICON(1,43),ICON(2,43),ICON(3,43),ICON(4,43),ICON(5,43),
     * ICON(6,43),ICON(7,43),ICON(8,43)/'O','U','D','I',' ',' ',' ',' '/
C
      CALL CONPHR (ICON, 8, NCON, 2, IBUF, JBUF+1, JEDAT-1, ICPH, JE)
      RETURN
      END
      SUBROUTINE COPIA (IA, IB, L)                                          INOU
 
C* REVISED 2/9/78.
C* COPIES AN INTEGER ARRAY.
 
C  IA RECEIVES THE ARRAY TO BE COPIED.
C  IB RETURNS THE COPIED ARRAY.
C  L RECEIVES THE LENGTHS OF IA AND IB.
 
      DIMENSION IA(L),IB(L)
 
      DO 10 I = 1, L
   10   IB(I) = IA(I)
 
      RETURN
      END
      SUBROUTINE COPSA (IA, IB, L)                                          INOU
 
C* REVISED 20-APR-99.
C* COPIES A CHARACTER*1 ARRAY.
 
C  IA RECEIVES THE ARRAY TO BE COPIED.
C  IB RETURNS THE COPIED ARRAY.
C  L RECEIVES THE LENGTHS OF IA AND IB.
 
      CHARACTER*1 IA(L),IB(L)
 
      DO 10 I = 1, L
   10   IB(I) = IA(I)
 
      RETURN
      END
      SUBROUTINE DERNG (IB, IE, IMIN, IMAX, JB, JE)                         INOU
C
C* REVISED 31/3/87.
C* DECODES A RANGE OF POSITIVE INTEGER VALUES.
C
C  IB RETURNS THE START OF THE RANGE, OR IMIN-1 IF THERE ARE ERRORS.
C  IE RETURNS THE END OF THE RANGE.
C  IMIN RECEIVES THE MINIMUM ALLOWED VALUE.
C  IMAX RECEIVES THE MAXIMUM ALLOWED VALUE.
C  JB RECEIVES THE LOCATION IN IBUF OF THE START OF THE FIELD
C    TO BE DECODED.
C  JE RECEIVES THE LOCATION IN IBUF IMMEDIATELY AFTER THE END OF
C    THE FIELD TO BE DECODED.
C
C  THE TEXT TO BE DECODED IS IN THE INPUT BUFFER BETWEEN IBUF(JB)
C    AND IBUF(JE-1), AND TAKES THE FORM N OR N-M.
C

      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
C
      IF (JB.GE.JE)  GO TO 240
C-    FIND RANGE SYMBOL, IF ANY.
      JF = INDEX (IBUF(JB:JE), RANGE)

      IF (JF.EQ.0)  THEN

C-      A SINGLE ELEMENT WAS SPECIFIED.
        CALL IDKOD (IB, IBUF(JB:JE-1), IERR)
        IF (IERR.NE.0)  GO TO 200
        IF (IB.LT.IMIN .OR. IB.GT.IMAX)  GO TO 210
        IE = IB
C
      ELSE

C-      A RANGE WAS SPECIFIED.
        JF = JF + JB - 1
        IF (JB.GE.JF)  GO TO 240
        CALL IDKOD (IB, IBUF(JB:JF-1), IERR)
        IF (IERR.NE.0)  GO TO 200
        IF (IB.LT.IMIN .OR. IB.GT.IMAX)  GO TO 210
        JB = JF + 1
        IF (JB.GE.JE)  GO TO 240
        CALL IDKOD (IE, IBUF(JB:JE-1), IERR)
        IF (IERR.NE.0)  GO TO 200
        IF (IE.LT.IMIN .OR. IE.GT.IMAX)  GO TO 210
        IF (IE.LE.IB)  GO TO 230
C
      ENDIF
      GOTO 1000

C-    ERROR MESSAGES.
  200 CALL ERROR (JB, 'Invalid integer.%')
      GO TO 900
  210 CALL ERROR (JB, 'Illegal value.%')
      GO TO 900
  230 CALL ERROR (JB, 'Value out of order.%')
      GO TO 900
  240 CALL ERROR (JB, 'Missing data.%')
  900 IB = IMIN - 1
C-
 1000 RETURN
      END
      LOGICAL FUNCTION DIREXISTS (DIRNAME, LDIR)
 
C     REVISED 18-SEP-98.
C     RETURNS IF A SPECIFIED DIRECTORY EXISTS.
 
C     DIRNAME RECEIVES THE DIRECTORY NAME.
C     LDIR RECEIVES THE LENGTH OF THE DIRECTORY NAME.
 
      CHARACTER*(*) DIRNAME
      CHARACTER*80 F
C      CHARACTER*80 S
      LOGICAL*4 E,O
 
      F = DIRNAME(1:LDIR)
      LF = LDIR
      IF (F(LF:LF).NE.'\')  THEN
        LF = LF + 1
        F(LF:LF) = '\'
      ENDIF
      F(LF+1:LF+1) = '.'
C      CALL EXNAME(F, S)
 
      DIREXISTS = .FALSE.
      INQUIRE (FILE=F, EXIST=E, OPENED=O, NUMBER=LUN, ERR=100)
      IF (E) THEN
        DIREXISTS = .TRUE.
      ENDIF
 
  100 RETURN
      END
      SUBROUTINE ERROR (IPOINT, MBUF)                                       INOU

C* REVISED 1-OCT-92.
C* PRINTS ERROR MESSAGE.

C  IPOINT RECEIVES THE POSITION IN THE INPUT BUFFER AT WHICH THE ERROR
C   OCCURRED.
C  MBUF RECEIVES THE MESSAGE.

      CHARACTER*(*) MBUF

      COMMON /ERRXXX/ IERR
      COMMON /FMTXXX/ ITAB,LFOUT,LTXOUT,KCOLS,MAXWID
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH

C     DIMENSION OF MTMP MUST BE SAME AS LENGTH OF IOUT IN /IOBUFX/
      CHARACTER MTMP*200                                                      =*

      IERR = IERR + 1

      L = LMESS (MBUF)
      IF (IPOINT.LE.0)  THEN
        CALL EMESS (MBUF(:L))
      ELSE
        DO I = 1, JEDAT
          IF (ICHAR(IBUF(I:I)).LT.32)  THEN
            CALL BADBUF(IPOINT, IBUF(1:JEDAT), JEDAT)
            GOTO 10
          ENDIF
        ENDDO
        CALL EMESS (IBUF(:JEDAT))
   10   MTMP = ' '
        MTMP(IPOINT:IPOINT) = UPAROW
        IF (L.LE.IPOINT-2) THEN
          MTMP(IPOINT-1-L:IPOINT-2) = MBUF(:L)
          CALL EMESS (MTMP(:IPOINT))
        ELSEIF (IPOINT+1+L.LE.MAXWID) THEN
          MTMP(IPOINT+2:) = MBUF(:L)
          CALL EMESS (MTMP(:IPOINT+1+L))
        ELSE
          CALL EMESS (MTMP(:IPOINT))
          CALL EMESS (MBUF(:L))
        ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE FERROR (MESS)                                              INOU

C* REVISED 5/8/87.
C* PRINTS FATAL ERROR MESSAGE AND STOPS.

C  MESS RECEIVES THE MESSAGE.

      CHARACTER*(*) MESS

      CALL ERROR (0, MESS)
      CALL UCLOSE

      END
      SUBROUTINE GETAU (LUN)                                                INOU

C* REVISED 28/2/86.
C* GETS NUMBER OF FIRST AVAILABLE LOGICAL UNIT.

C  LUN RETURNS THE LOGICAL UNIT NUMBER.

      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(10),LUNPRE(10),
     *  LUNUSE(13),LUNREC(13),LUNPAG(13)


      DO 20 I = 1, NUN
        IF (LUNUSE(I).LT.0) GOTO 50
   20 CONTINUE
      CALL FERROR ('Too many files in use.%')

   50 LUN = I

      RETURN
      END
      SUBROUTINE GETFLI (LUNTYP, IERR)                                      INOU

C* REVISED 08-MAR-99.
C* READS NAME OF INPUT FILE AND OPENS IT.

      LOGICAL*4 E,O
      CHARACTER S*60,SNAME*30

      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /LRECDA/ LRECDA,LCREC
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(10),LUNPRE(10),
     *  LUNUSE(13),LUNREC(13),LUNPAG(13)
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH

      DIMENSION LU(10)
      EQUIVALENCE (LU(1),LUNI)

      IERR = 0
      CALL NEXTWD (JE)
      IF (IBUF(JBUF:JBUF).EQ.STAR) THEN
        CALL ERROR (JBUF-1, 'Missing data.%')
        IERR = 1
      ENDIF
      IF (IERR.NE.0) GOTO 1000
      S = IBUF(JBUF:JE)
      JBUF = JE

C     CHECK FILE NAME AND OPEN IF NECESSARY.
      CALL EXNAME (S, SNAME)
      INQUIRE (FILE=S, EXIST=E, OPENED=O, NUMBER=LUN, ERR=100)
      IF (.NOT.E)  GOTO 110
      IF (O)  THEN
        IF (LUNUSE(LUN).NE.LUNCOM(LUNTYP))  GOTO 120
        LUNPRE(LUNTYP) = LU(LUNTYP)
        LU(LUNTYP) = LUN
      ELSE
        CALL GETAU (L)
        CALL SETLUN (S, L, LUNTYP)
        CALL UOPEN (L, LUNUSE(L), S, LRECDA, IERR)
        IF (IERR.NE.0)  GOTO 130
      ENDIF
      GOTO 1000

C     ERROR MESSAGES.
  100 CALL ERROR (JE-1, 'Invalid file name.%')
      GOTO 900
  110 CALL ERROR (JE-1, 'File does not exist.%')
      GOTO 900
  120 CALL ERROR (JE-1, 'Incompatible with previous use of this file.%')
      GOTO 900
  130 CALL ERROR (JE-1, 'File is inaccessible.%')

  900 IERR = 1

 1000 RETURN
      END
      SUBROUTINE GETFLO (LUNTYP, IERR)                                      INOU

C* REVISED 20/8/87.
C* READS NAME OF OUTPUT FILE, AND OPENS FILE.

      LOGICAL*4 O
      CHARACTER S*60,SNAME*30

      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(10),LUNPRE(10),
     *  LUNUSE(13),LUNREC(13),LUNPAG(13)
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH

      DIMENSION LU(10)
      EQUIVALENCE (LU(1),LUNI)

      IERR = 0
      CALL NEXTWD (JE)
      IF (IBUF(JBUF:JBUF).EQ.STAR) THEN
        CALL ERROR (JBUF-1, 'Missing data.%')
        IERR = 1
        GOTO 1000
      ENDIF
      S = IBUF(JBUF:JE)
      JBUF = JE

C     CHECK FILE NAME AND OPEN IF NECESSARY.
      CALL EXNAME (S, SNAME)
      INQUIRE (FILE=S, OPENED=O, NUMBER=LUN, ERR=100)
      IF (O)  THEN
        IF (LUNUSE(LUN).NE.LUNCOM(LUNTYP))  GOTO 110
        LU(LUNTYP) = LUN
      ELSE
        CALL GETAU (L)
        CALL SETLUN (S, L, LUNTYP)
        CALL UOPEN (L, LUNUSE(L), S, IDUMMY, IERR)
        IF (IERR.NE.0)  GOTO 120
      ENDIF
      GOTO 1000

C--   ERROR MESSAGES.
  100 CALL ERROR (JE-1, 'Invalid file name.%')
      GOTO 900
  110 CALL ERROR (JE-1, 'Incompatible with previous use of this file.%')
      GOTO 900
  120 CALL ERROR (JE-1, 'File is inaccessible.%')

  900 IERR = 1
C--
 1000 RETURN
      END
      SUBROUTINE GETIND (IB, IE, IC, MAX, JE)                               INOU

C* REVISED 11/6/85.
C* DECODES A SINGLE INDEX VALUE OR INDEX RANGE.

C  IB RETURNS THE START OF THE RANGE.
C  IE RETURNS THE END OF THE RANGE.
C  IC RECEIVES AND RETURNS THE LAST NUMBER READ.
C    IF THE NUMBER OR RANGE READ IS INVALID, IC RETURNS -1.
C  MAX RECEIVES THE MAXIMUM INDEX VALUE.
C  JE RECEIVES THE LOCATION IN IBUF IMMEDIATELY AFTER THE END OF
C    THE INPUT FIELD TO BE EXAMINED.

C  THE INPUT FIELD IS IBUF(JBUF) TO IBUF(JE-1).
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED.
C  ON EXIT WITH A VALID NUMBER, JBUF IS
C    IMMEDIATELY AFTER THE COMMA.
C    ON EXIT WITH AN INVALID NUMBER, JBUF IS SET TO JE.

      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH

C     SEARCH FOR COMMA.
      JF = INDEX (IBUF(JBUF:JE), COMMA)
      IF (JF.EQ.0)  GOTO 100
      JF = JF + JBUF - 1
      IF (JF.EQ.JBUF)  GO TO 100

C     COMMA FOUND, PRECEDING FIELD NON-EMPTY. DECODE NUMBER.
      CALL DERNG (IB, IE, 1, MAX, JBUF, JF)
      IF (IB.LE.0)  GOTO 150

C     CHECK NUMBERS.
      DO 55 IX = IB, IE
        IF (IX.LE.0 .OR. IX.GT.MAX)  GO TO 120
   55   CONTINUE
      IC = IE
      JBUF = JF + 1
      GO TO 200

C     ERROR MESSAGES.
  100 CALL ERROR (JBUF, 'Missing index value.%')
      GOTO 150
  120 CALL ERROR (JBUF, 'Index out of range.%')

  150 IC = -1
      IB = -1
      IE = -1
      JBUF = JE

  200 RETURN
      END
      SUBROUTINE IDKOD (NUM, IBF, IERR)                                     INOU
 
C  REVISED 23-JUN-92.
C  DECODES AN INTEGER VALUE.
C

      CHARACTER*(*) IBF
      CHARACTER*10 FMT
C
      IERR = 0
      L = LEN (IBF)
      IF (L.LE.0)  GOTO 30

      WRITE(FMT,10)L
   10 FORMAT( '(I', I4, ')' )
      READ(IBF,FMT,ERR=30) NUM
      GOTO 40
C
   30 IERR = 1
C
   40 RETURN
      END
      SUBROUTINE CIREAL (VAL, MAXIND, XMIN, XMAX, ITYPE)                    INOU
C
C* REVISED 24-JAN-94.
C* READS A CHARACTER (OR TAXON) INDEXED LIST OF REAL VALUES.
C
C  VAL RETURNS THE VALUES READ.
C  MAXIND RECEIVES THE MAXIMUM PERMISSIBLE INDEX.
C  XMIN RECEIVES THE MINIMUM ALLOWED VALUE.
C  XMAX RECEIVES THE MAXIMUM ALLOWED VALUE.
C  ITYPE RECEIVES THE TYPE OF LIST. 1=CHARS, 2=TAXA.
C
C  THE INPUT TAKES THE FORM IC1,V1 IC2,V2 ... AND IS TERMINATED
C    BY A STAR-WORD.
C    IVAL(IC1) IS SET TO IV1, ETC.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR.
C
C
      DIMENSION VAL(MAXIND)
C
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
C
      IC = 0
C
C     READ AND DECODE NEXT WORD.
   30 CALL NEXTWD (JE)
        IF (IEOF.NE.0)  GOTO 200
        IF (IBUF(JBUF:JBUF).EQ.STAR)  GO TO 200
C       SAVE POSITION IN BUFFER OF CHARACTER NUMBER.
        KBUF = JBUF
        CALL GETIND (IB, IE, IC, MAXIND, JE)
        IF (IC.LE.0)  GO TO 100
        CALL RDKOD (VALUE, IBUF(JBUF:JE-1), IERR)
        IF (IERR.NE.0)  GO TO 50
        IF (VALUE.LT.XMIN .OR. VALUE.GT.XMAX)  GO TO 60
        DO 40 JC = IB, IE
          IF (VAL(JC).GE.XMIN) THEN
            IF (ITYPE.EQ.1) THEN
             CALL WERROR(KBUF, 'Character has already been specified.%')
            ELSE
             CALL WERROR(KBUF, 'Taxon has already been specified.%')
            ENDIF
          ENDIF
          VAL(JC) = VALUE
   40     CONTINUE
        GO TO 100
C
C       ERROR MESSAGES.
   50   CALL ERROR (JBUF, 'Invalid integer.%')
        GOTO 100
   60   CALL ERROR (JBUF, 'Illegal value.%')
C
  100   JBUF = JE
        GO TO 30
C
  200 RETURN
      END
      SUBROUTINE EMESS (MBUF)                                               INOU

C* REVISED 25/7/87.
C* PRINTS A MESSAGE ON THE ERROR AND LISTING UNITS.

C  MBUF RECEIVES THE MESSAGE.

      CHARACTER*(*) MBUF

      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB

      L = LMESS(MBUF)
      CALL WRTREC (MBUF(1:L), LUNE)
      IF (LUNL.GT.0 .AND. LUNL.NE.LUNE) CALL WRTREC (MBUF(1:L), LUNL)

      RETURN
      END
      SUBROUTINE LCOUNT (LUN)                                               INOU
C
C* REVISED 18/8/87.
C* COUNTS OUTPUT RECORDS, AND HANDLES PAGINATION.

C  LUN RECEIVES THE LOGICAL UNIT.

C  IF A NEW PAGE IS NOT REQUIRED, LUNREC(LUN) IS INCREMENTED.
C    OTHERWISE, LUNREC(LUN) IS SET TO 1, AND A FORMFEED AND LTOP BLANK
C    LINES ARE OUTPUT.

      COMMON /FFFXXX/ FF
        CHARACTER*1 FF
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(10),LUNPRE(10),
     *  LUNUSE(13),LUNREC(13),LUNPAG(13)
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH


      IF (LUNPAG(LUN).EQ.0 .OR.
     *  (LUNREC(LUN).GE.0.AND.LUNREC(LUN).LT.LPRINT)) THEN
        LUNREC(LUN) = LUNREC(LUN) + 1
      ELSE
        LUNREC(LUN) = 1
        CALL WREC (FF, LUN)
        DO 50 I = 1, LTOP
          CALL WREC (BLANK, LUN)
   50   CONTINUE
      ENDIF

      RETURN
      END
      FUNCTION   LMESS (SBF)                                                INOU

C* REVISED 22-FEB-89.
C* FINDS THE LENGTH OF A CHARACTER STRING DELIMITED BY '%'.

C  THE FUNCTION RETURNS LENGTH OF THE STRING, EXCLUDING THE DELIMITER
C    AND TRAILING BLANKS.
C  SBF RECEIVES THE STRING, DELIMITED BY '%' AT THE END.

      CHARACTER SBF*(*)

      DO 10 I = 1, LEN(SBF)
        IF (SBF(I:I).EQ.'%')  GOTO 20
   10 CONTINUE

   20 DO 30 J = I-1, 1, -1
        IF (SBF(J:J).NE.' ')  GOTO 40
   30 CONTINUE
      J = 1

   40 LMESS = J

      RETURN
      END
      FUNCTION   LSTRB (SBF)                                                INOU

C* REVISED 18/8/87.
C* FINDS THE LENGTH OF A CHARACTER STRING DELIMITED BY BLANK.

C  THE FUNCTION RETURNS LENGTH OF THE STRING, EXCLUDING THE BLANK.
C  SBF RECEIVES THE STRING, DELIMITED BY BLANK AT THE END.
C  M RECEIVES THE MAXIMUM LENGTH OF THE STRING.

      CHARACTER SBF*(*)

      DO 10 I = 1, LEN(SBF)
        IF (SBF(I:I).EQ.' ')  GOTO 20
   10 CONTINUE

   20 LSTRB = I - 1

      RETURN
      END
      SUBROUTINE MESS (MBUF, LUN)                                           INOU

C* REVISED 23-FEB-89.
C* PRINTS A MESSAGE.

C  MBUF RECEIVES THE MESSAGE, OPTIONALLY DELIMITED BY '%'.

      CHARACTER*(*) MBUF

      L = LMESS(MBUF)
      CALL WRTREC (MBUF(1:L), LUN)

      RETURN
      END
      FUNCTION   NAMLEN (FNAME)                                             INOU

C* REVISED 24/7/87.
C* DETERMINES THE LENGTH OF THE 'NAME' PART OF A FILENAME.

C  FNAME RECEIVES THE FILENAME.

      CHARACTER*(*) FNAME

      L = LSTRB(FNAME)
      I = 0
      IF (L.GE.1) I = INDEX(FNAME(1:L),'.') - 1
      IF (I.LT.0) I = L
      NAMLEN = I

      RETURN
      END
      SUBROUTINE NEXTWD (JE)                                                INOU

C  REVISED 11/4/88.
C  FINDS THE END OF THE CURRENT WORD.

C  JE RETURNS THE POSITION IMMEDIATELY AFTER THE END OF THE WORD.
C  ON EXIT, JBUF IS AT THE START OF THE WORD.

      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH

      IF (IEOF.NE.0)  GOTO 10
      CALL SKNONB
      J = INDEX (IBUF(JBUF+1:JEDAT), BLANK)
      JE = J + JBUF

   10 RETURN
      END
      FUNCTION   NONZER (IA, N)                                             INOU
C
C  REVISED 5/2/80.
C  COUNTS NON-ZERO ELEMENTS OF AN INTEGER ARRAY.
C
C  IA RECEIVES THE ARRAY TO BE COUNTED.
C  N RECEIVES THE LENGTH OF IA.
C
      DIMENSION IA(N)
C
      NONZER = 0
      DO 10 I = 1, N
        IF (IA(I).NE.0)  NONZER = NONZER + 1
   10   CONTINUE
      RETURN
      END
      SUBROUTINE OPNDEF (LUNTYP)                                            INOU

C* REVISED 19-APR-99.
C* OPENS DEFAULT INPUT AND OUTPUT FILES.

C  LUNTYP RECEIVES THE TYPE OF UNIT.

      LOGICAL*4 E
      CHARACTER DEFNAM*128,FSPEC*128,MBUF*70

      COMMON /LRECDA/ LRECDA,LCREC
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(10),LUNPRE(10),
     *  LUNUSE(13),LUNREC(13),LUNPAG(13)
      COMMON /LUFXXX/ FNAME(12),LFNAME(12)
        CHARACTER FNAME*128
      COMMON /OUTDXX/ DIROUT,LDIROUT
        CHARACTER*128 DIROUT
      COMMON /PARXXX/ NFB,NFE,JFB,NVAR,NEWLN,NT,NTD,NTA,NO,KN,NUSED,
     *                INCOMP,VARW,NTR,RBASE,ABASE,REUSE,VARYWT,NCONF,
     *                NSET,RES,ITUNKV,IADCNO,ITCHV,IRTF,IHTML

      IF (LUNTYP.EQ.2) THEN
        DEFNAM = 'kchars'
        CALL EXNAME (DEFNAM, MBUF)
        INQUIRE (FILE=DEFNAM, EXIST=E)
        IF (.NOT.E) CALL FERROR ('No KEY CHARACTERS file.%')
        CALL GETAU (LUN)
        CALL SETLUN (DEFNAM, LUN, LUNTYP)
        CALL UOPEN (LUN, LUNTYP, DEFNAM, LRECDA, IERR)
        IF (IERR.NE.0) GOTO 100

      ELSEIF (LUNTYP.EQ.3) THEN
        DEFNAM = 'kitems'
        CALL EXNAME (DEFNAM, MBUF)
        INQUIRE (FILE=DEFNAM, EXIST=E)
        IF (.NOT.E) CALL FERROR ('No KEY ITEMS file.%')
        CALL GETAU (LUN)
        CALL SETLUN (DEFNAM, LUN, LUNTYP)
        CALL UOPEN (LUN, LUNTYP, DEFNAM, LRECDA, IERR)
        IF (IERR.NE.0) GOTO 100

      ELSE IF (LUNTYP.EQ.4) THEN
        IF (LUNUSE(LUNI).LE.0) THEN
          DEFNAM = 'key.prt'
        ELSE
          L = NAMLEN (FNAME(LUNI))
          DEFNAM = ' '
          IF (L.GT.0) DEFNAM(1:L) = FNAME(LUNI)(1:L)
          DEFNAM(L+1:L+4) = '.prt'
        ENDIF
        CALL GETAU (LUN)
        CALL SETLUN (DEFNAM, LUN, LUNTYP)
        CALL UOPEN (LUN, LUNTYP, DEFNAM, IDUMMY, IERR)
        IF (IERR.NE.0) GOTO 200

      ELSE IF (LUNTYP.EQ.5.OR.LUNTYP.EQ.10) THEN
        IF (LUNUSE(LUNI).LE.0) THEN
          DEFNAM = 'key.out'
        ELSE
          CALL EXNAME (FNAME(LUNI), FSPEC)
          L = NAMLEN (FSPEC)
          DEFNAM = ' '
          LDEF = 0
          IF (LDIROUT.GT.0)  THEN
            DEFNAM = DIROUT(1:LDIROUT)
            LDEF = LDIROUT
          ENDIF
          IF (L.GT.0) THEN
            DEFNAM(LDEF+1:) = FSPEC(1:L)
            LDEF = LDEF + L
          ENDIF
          IF (IRTF.NE.0)  THEN
            DEFNAM(LDEF+1:LDEF+4) = '.rtf'
          ELSE IF (IHTML.NE.0)  THEN
            DEFNAM(LDEF+1:LDEF+4) = '.htm'
          ELSE
            DEFNAM(LDEF+1:LDEF+4) = '.out'
          ENDIF
          LDEF = LDEF + 4
C         Need this call in Windows version to fill out complete path.
          CALL EXNAME (DEFNAM, FSPEC)
        ENDIF
        CALL GETAU (LUN)
        CALL SETLUN (DEFNAM, LUN, LUNTYP)
        CALL UOPEN (LUN, LUNTYP, DEFNAM, LRECDA, IERR)
        IF (IERR.NE.0) GOTO 200

      ELSE IF (LUNTYP.EQ.6) THEN
        IF (LUNUSE(LUNI).LE.0) THEN
          DEFNAM = 'key.str'
        ELSE
          L = NAMLEN (FNAME(LUNI))
          DEFNAM = ' '
          IF (L.GT.0) DEFNAM(1:L) = FNAME(LUNI)(1:L)
          DEFNAM(L+1:L+4) = '.str'
        ENDIF
        CALL GETAU (LUN)
        CALL SETLUN (DEFNAM, LUN, LUNTYP)
        CALL UOPEN (LUN, LUNTYP, DEFNAM, IDUMMY, IERR)
        IF (IERR.NE.0) GOTO 200

      ENDIF

      GOTO 300

  100 WRITE (MBUF, 110) FNAME(LUN)(1:LFNAME(LUN))
  110 FORMAT ('File ', A, ' is inaccessible.%')
      CALL FERROR (MBUF)

  200 WRITE (MBUF, 210) FNAME(LUN)(1:LFNAME(LUN))
  210 FORMAT ('Unable to open output FILE - ', A, '.%')
      CALL FERROR (MBUF)

  300 RETURN
      END
      SUBROUTINE PARAMS (D, RD, CSTR, NSD, LWRK)                            INOU

C* REVISED 20-APR-99.
C* READS PARAMETERS AND ALLOCATES STORAGE FOR MASKS ETC.

C  NSD RETURNS LENGTH OF SPACE AVAILABLE IN D FOR STORING PRESET
C   CHARACTERS.
C  LWRK RETURNS LENGTH OF WORKING ARRAY.

C  HISTORY.

C  13/4/87. DEFAULT VALUE OF RES CHANGED FROM 1.5 TO 0.
C  1/4/87. 'TYPSET STYLE' AND 'TYPSET TABS' DIRECTIVES ADDED.
C  26/3/87. 'MATRIX DUMP' DIRECTIVE ADDED.
C  27/10/86. TIM AND DAT LENGTH CHANGED FROM 9 TO 10.
C  22/10/86. 'DUMP' DIRECTIVE ADDED.
C  15/10/86. 'STOP AFTER COLUMN' DIRECTIVE ADDED.

      COMMON /ADRXXX/ KT,KBRULE,KERULE,KTAXON,KTXNAM,KFMEM,KNSTAT,
     *                KFO,KFREC,KFLADD,KIFL,KDIO,KFN,KDUP,KBREC,
     *                KFLAG,KA,KLIST,KCDEP,KALOG2,KNBO,KBRUL,KNEO,KNBN,
     *                KERUL,KNEN,KNCO,KNOCC,KNCN,KDIV,
     *                KR,KRULE,KRINDX,KUSED,KAINDX,KTAXA,
     *                KWRK,KWRK1,KWRK2,KNLSET,KKOSET,KJBSET,KFMSK,KTMSK,
     *                KTMP,KBCMT,KBPRE,KBTYP,KCMT,KTYPMK
      COMMON /ALGXXX/ IALG
      COMMON /CMTXXX/ LCMT
      COMMON /DIMXXX/ LDM,NFR,NF,NTM,NTM1,NTU,NTH,NWORD,NDESC,LCDEP
      COMMON /DMPXXX/ IDUMP,IMDMP1,IMDMP2,IRDMP1,IRDMP2
      COMMON /FMTXXX/ ITAB,LFOUT,LTXOUT,KCOLS,MAXWID
      COMMON /HEDXXX/ HEAD
      CHARACTER*200 HEAD
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /IOPARX/ JOUT,IENDWD,IBINARY
      COMMON /LHEADX/ LHEAD,MAXHDR
      COMMON /LINEXX/ LINE
      CHARACTER*200 LINE
      COMMON /LTYXXX/ LSTYLE,MAXSTY,LTAB,MAXTAB
      COMMON /LRECDA/ LRECDA,LCREC
      COMMON /LUFXXX/ FNAME(12),LFNAME(12)
        CHARACTER FNAME*128
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(10),LUNPRE(10),
     *  LUNUSE(13),LUNREC(13),LUNPAG(13)
      COMMON /LUTXXX/ LUNTI,LUNTO
      COMMON /LUUXXX/ LUNOUT
      COMMON /MNSXXX/ MNS,MNS1,MNS2,MNS3
      COMMON /MSTXXX/ MSTOR,MSTORC
      COMMON /NCHXXX/ NCHAR
      COMMON /OUTDXX/ DIROUT,LDIROUT
        CHARACTER*128 DIROUT
      COMMON /PARXXX/ NFB,NFE,JFB,NVAR,NEWLN,NT,NTD,NTA,NO,KN,NUSED,
     *                INCOMP,VARW,NTR,RBASE,ABASE,REUSE,VARYWT,NCONF,
     *                NSET,RES,ITUNKV,IADCNO,ITCHV,IRTF,IHTML
      COMMON /PRFXXX/ NP(8)
      COMMON /RECXXX/ MSKTAX,NAMTAX,MSKCHR,NSTREC,IDPREC,IRLREC,ICREC,
     *                IHDREC,NSTTAX,IABREC
      COMMON /STPXXX/ ISTOPC
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      COMMON /STYXXX/ TSTYLE,TTAB
        CHARACTER TSTYLE*100,TTAB*30
      COMMON /TIMXXX/ TIM,DAT
      CHARACTER*10 TIM,DAT
      COMMON /TPSXXX/ ITPSET,MAXTYPMK,NTYPMK,LTYPMK,INTYPMKS


      INTEGER D(MSTOR)
      REAL RD(MSTOR)
      CHARACTER*1 CSTR(MSTORC)

C     NUMBER OF CONTROL PHRASES - MUST AGREE WITH SUBR. CONTRL.
      PARAMETER (NCON=43)                                                     =*

      DIMENSION JDIR(NCON)
      CHARACTER MBUF*50
      LOGICAL CHKDIRY


C     GET TIME AND DATE.
      CALL GETTIME (TIM, DAT)

C     SET DEFAULT VALUES OF PARAMETERS.
      IALG = 1
      IERR = 0
      IDUMP = 0
      ISTOPC = 0
      MNS1 = MNS + 1
      MNS2 = MNS + 2
      MNS3 = MNS + 3
      RBASE = 1.4
      ABASE = 2.0
      REUSE = 1.01
      VARYWT = 0.8
      ITUNKV = 1
      IADCNO = 0
      ITCHV = 0
      IRTF = 1
      IHTML = 0
      LDIROUT = 0
      RES = 0.
      NCONF = 0
      NSET = 0
      DO 10 I = 1, 8
        NP(I) = 0
   10   CONTINUE
C     SET DEFAULT TO OUTPUT BOTH TABULAR AND CONVENTIAL KEYS.
      NP(3) = 1
      NP(5) = 1
      NP(8) = NP(3) + NP(4) + NP(5) +NP(6)

C     LIMIT OF AVAILABLE STORAGE.
      ILAST = MSTOR + 1

C     REQUESTED STORAGE.
      ISTOR = 0

      DO 40 I = 1, NCON
        JDIR(I) = 0
   40   CONTINUE

      NFR = -1
      NTR = -1

C     FLAGS INDICATING INPUT OF OVERRIDING INFORMATION.
      INFMSK = 0
      INTMSK = 0
      INHDR = 0
      INREL = 0
      INABUN = 0

C--READ PARAMETERS FROM DIRECTIVES FILE.

      NOTMP = 1
      IEOF = 0
      CALL RDBUF

   50 IF (IEOF.NE.0)  GOTO 5000
      CALL SKDELW
      IF (IEOF.NE.0)  GOTO 5000
        CALL CONTRL (ICPH, JE)
        JBUF = JE
        IF (ICPH.GT.0)  GOTO 60
          CALL ERROR (JBUF, 'Invalid directive.%')
          GOTO 50

   60 JDIR(ICPH) = 1

      GOTO (100,200,300,400,500,600,700,800,900,1000,
     * 1100,1200,1300,1400,1500,1600,1700,1800,1900,2000,
     * 2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
     * 3100,3200,3300,3400,3500,3600,3700,3800,3900,4000,
     * 4100,4200,4300) ICPH

C-    HEADING.
  100 CALL RDTEXT (HEAD, LHEAD, MAXHDR)
      INHDR = 1
      GOTO 50

C-    RBASE.
  200 CALL RDREAL (RBASE)
      IF (RBASE.LT.1.0.OR.RBASE.GT.5.0)
     * CALL ERROR (JBUF, 'Value must be in the range 1.0-5.0.%')
      GOTO 50

C-    ABASE.
  300 CALL RDREAL (ABASE)
      IF (ABASE.LT.1.0.OR.ABASE.GT.5.0)
     * CALL ERROR (JBUF, 'Value must be in the range 1.0-5.0.%')
      GOTO 50

C-    REUSE.
  400 CALL RDREAL (REUSE)
      IF (REUSE.LT.1.0.OR.REUSE.GT.5.0)
     * CALL ERROR (JBUF, 'Value must be in the range 1.0-5.0.%')
      GOTO 50

C-    Varywt.
  500 CALL RDREAL (Varywt)
      IF (Varywt.lt.0.0.or.varywt.gt.1.0)
     * CALL ERROR (JBUF, 'Value must be in the range 0.0-1.0.%')
      GOTO 50

C-    INCLUDE CHARACTERS.
  600 IF (JDIR(7).NE.0)  THEN
        CALL ERROR (JBUF, 'Equivalent directive already used.%')
      ELSE
        IF (LUNC.LT.0)  THEN
          CALL OPNDEF (2)
          CALL INICHR (NFR, ILAST)
          IF (NOTMP.EQ.1) CALL INITMP (NFR, NTR, ILAST, NSD, LWRK,
     *     NOTMP)
        ENDIF
        CALL RDMSK (1, D(KFMSK), NFR, NF)
        IF (NF.LE.0)  CALL FERROR ('All characters excluded.%')
        INFMSK = 1
      ENDIF
      GOTO 50

C-    EXCLUDE CHARACTERS.
  700 IF (JDIR(6).NE.0)  THEN
        CALL ERROR (JBUF, 'Equivalent directive already used.%')
      ELSE
        IF (LUNC.LT.0)  THEN
          CALL OPNDEF (2)
          CALL INICHR (NFR, ILAST)
          IF (NOTMP.EQ.1) CALL INITMP (NFR, NTR, ILAST, NSD, LWRK,
     *     NOTMP)
        ENDIF
        CALL RDMSK (0, D(KFMSK), NFR, NF)
        IF (NF.LE.0)  CALL FERROR ('All characters excluded.%')
        INFMSK = 1
      ENDIF
      GOTO 50

C-    INCLUDE ITEMS.
  800 IF (JDIR(9).NE.0)  THEN
        CALL ERROR (JBUF, 'Equivalent directive already used.%')
      ELSE
        IF (LUNT.LT.0)  THEN
          CALL OPNDEF (3)
          CALL INITEM (NTR, NFI, LCDEP, ILAST)
          IF (NOTMP.EQ.1) CALL INITMP (NFR, NTR, ILAST, NSD, LWRK,
     *     NOTMP)
        ENDIF
        CALL RDMSK (1, D(KTMSK), NTR, NTM)
        IF (NTM.LE.0)  CALL FERROR ('All items excluded.%')
        INTMSK = 1
      ENDIF
      GOTO 50

C-    EXCLUDE ITEMS.
  900 IF (JDIR(8).NE.0)  THEN
        CALL ERROR (JBUF, 'Equivalent directive already used.%')
      ELSE
        IF (LUNT.LT.0)  THEN
          CALL OPNDEF (3)
          CALL INITEM (NTR, NFI, LCDEP, ILAST)
          IF (NOTMP.EQ.1) CALL INITMP (NFR, NTR, ILAST, NSD, LWRK,
     *     NOTMP)
        ENDIF
        CALL RDMSK (0, D(KTMSK), NTR, NTM)
        IF (NTM.LE.0)  CALL FERROR ('All items excluded.%')
        INTMSK = 1
      ENDIF
      GOTO 50

C-    CHARACTER RELIABILITIES.
 1000 IF (LUNC.LT.0)  THEN
        CALL OPNDEF (2)
        CALL INICHR (NFR, ILAST)
      ENDIF
      IF (LUNT.LT.0)  THEN
        CALL OPNDEF (3)
        CALL INITEM (NTR, NFI, LCDEP, ILAST)
      ENDIF
      IF (NOTMP.EQ.1)  CALL INITMP (NFR, NTR, ILAST, NSD, LWRK, NOTMP)
      CALL SETRA (RD(KWRK1), NFR, -1.)
      CALL CIREAL (RD(KWRK1), NFR, 0., 10., 1)
      INREL = 1
      GOTO 50

C-    ITEM ABUNDANCES.
 1100 IF (LUNC.LT.0)  THEN
        CALL OPNDEF (2)
        CALL INICHR (NFR, ILAST)
      ENDIF
      IF (LUNT.LT.0)  THEN
        CALL OPNDEF (3)
        CALL INITEM (NTR, NFI, LCDEP, ILAST)
      ENDIF
      IF (NOTMP.EQ.1)  CALL INITMP (NFR, NTR, ILAST, NSD, LWRK, NOTMP)
      CALL SETRA (RD(KWRK), NTR, -1.)
      CALL CIREAL (RD(KWRK), NTR, 0., 10., 2)
      INABUN = 1
      GOTO 50

C-    NUMBER OF CONFIRMATORY CHARACTERS.
 1200 CALL RDINT (NCONF)
      IF (NCONF.LT.0.OR.NCONF.GT.4)  CALL ERROR (JBUF,
     * 'Value must be in the range 0-4.%')
      GOTO 50

C-    PRESET CHARACTERS.
 1300 IF (LUNT.LT.0)  THEN
        CALL OPNDEF (3)
        CALL INITEM (NTR, NFI, LCDEP, ILAST)
      ENDIF
      IF (LUNC.LT.0)  THEN
        CALL OPNDEF (2)
        CALL INICHR (NFR, ILAST)
      ENDIF
      IF (NOTMP.EQ.1)  CALL INITMP (NFR, NTR, ILAST, NSD, LWRK, NOTMP)
      KBPRE = KTMP
      CALL PRESET (D(KBPRE), NSD-KBPRE+1, NSET)
      KTMP = KTMP + 3*NSET
      GOTO 50

C     TYPESETTING MARKS.
 1400 CONTINUE
      IF (LUNT.LT.0)  THEN
        CALL OPNDEF (3)
        CALL INITEM (NTR, NFI, LCDEP, ILAST)
      ENDIF
      IF (LUNC.LT.0)  THEN
        CALL OPNDEF (2)
        CALL INICHR (NFR, ILAST)
      ENDIF
      IF (NOTMP.EQ.1)  CALL INITMP (NFR, NTR, ILAST, NSD, LWRK, NOTMP)
      INTYPMKS = 1
      KBTYP = KTMP
      CALL RDSENL (D(KBTYP), NSD-KBTYP+1, MAXTYPMK, IBINARY, NTYPMK,
     * LTYPMK)
      INTYPMKS = 0
      ITPSET = 1
      KTMP = KTMP + LTYPMK
      GOTO 50
 
CC-    INSERT TYPESETTING MARKS.
CC     (PRINT WIDTH IS ALSO SET TO 80. This changed on 2-Mar-98.
CC      PRINT WIDTH left unaltered.)
C 1400 ITPSET = 1
CC      LTXOUT = 80
C      LFOUT = 80
C      GOTO 50

C-    OMIT TYPESETTING MARKS.
 1500 ITPSET = -1
      IRTF = 0
      IHTML = 0
      GOTO 50

C-    NO TABULAR KEY.
 1600 NP(3) = 0
      NP(4) = 0
      GOTO 50

C-    NO BRACKETED KEY.
 1700 NP(5) = 0
      GOTO 50

C-    OUTPUT KEY STRUCTURE.
 1800 NP(6) = 1
      GOTO 50

C-    STORAGE FACTOR.
 1900 CALL RDREAL (RES)
      IF (RES.LT.1.0)
     *  CALL ERROR (JBUF, 'Value must not be less than 1.%')
      GOTO 50

C-    ALLOW IMPROPER SUBGROUPS
 2000 IALG = 2
      GOTO 50

C-    TREAT UNKNOWN AS INAPPLICABLE.
 2100 ITUNKV = 0
      GOTO 50

C-    PRINT WIDTH.
 2200 CALL RDINT (IWIDE)
      IF (IWIDE.EQ.0)  THEN 
        IBINARY = 1
        LTXOUT = LFOUT
      ELSE IF (IWIDE.LT.20)  THEN
        CALL ERROR (JBUF, 'Print width too small.%')
      ELSE IF (IWIDE.GT.MAXWID)  THEN
        WRITE(MBUF, 2210) MAXWID
 2210   FORMAT('Print width too large. maximum print width =',I4,'.%')
        CALL ERROR (JBUF, MBUF)
      ELSE 
        LTXOUT = IWIDE
        IF (ITPSET.LE.0) LFOUT = IABS(IWIDE)
      ENDIF
      GOTO 50

C-    TRUNCATE TABULAR KEY.
 2300 CALL RDINT (ICOL)
      IF (ICOL.LT.1)  THEN
        CALL ERROR (JBUF, 'Number of columns too small.%')
      ELSE
        KCOLS = ICOL
      ENDIF
      GOTO 50

C-    CHARACTERS FILE.
 2400 IF (LUNC.GT.0) CALL FERROR ('Characters file '//
     *  FNAME(LUNC)(1:LFNAME(LUNC))//' already opened.%')
      CALL GETFLI (2, IERR)
      IF (IERR.NE.0)  GOTO 9000
      CALL INICHR (NFR, ILAST)
      IF (NOTMP.EQ.1)  CALL INITMP (NFR, NTR, ILAST, NSD, LWRK, NOTMP)
      GOTO 50

C-    ITEMS FILE.
 2500 IF (LUNT.GT.0) CALL FERROR ('Items file '//
     *  FNAME(LUNT)(1:LFNAME(LUNT))//' already opened.%')
      CALL GETFLI (3, IERR)
      IF (IERR.NE.0)  GOTO 9000
      CALL INITEM (NTR, NFI, LCDEP, ILAST)
      IF (NOTMP.EQ.1)  CALL INITMP (NFR, NTR, ILAST, NSD, LWRK, NOTMP)
      GOTO 50

C-    KEY OUTPUT FILE.
 2600 CALL GETFLO (4, IERR)
      IF (IERR.NE.0)  GOTO 9000
      GOTO 50

C-    KEY STRUCTURE FILE.
 2700 CALL GETFLO (6, IERR)
      IF (IERR.NE.0)  GOTO 9000
      GOTO 50

C-    INSERT CHARACTER NUMBERS
 2800 IADCNO = 1
      GOTO 50

C-    LISTING FILE.
 2900 CALL GETFLO (9, IERR)
      IF (IERR.NE.0)  GOTO 9000
      IF (LUNREC(LUNL).LE.0) CALL PROGID (LUNL)
      GOTO 50

C-    KEY TYPSET FILE.
 3000 CALL GETFLO (5, IERR)
      IF (IERR.NE.0)  GOTO 9000
      GOTO 50

C-    COMMENT.
 3100 GOTO 50

C-    STOP AFTER COLUMN.
 3200 CALL RDINT (ISTOPC)
        IF (ISTOPC.LT.1)  CALL ERROR (JBUF, 'Column number too small.%')
      GOTO 50

C-    DUMP.
 3300 CALL RDINT (IDUMP)
      GOTO 50

C-    MATRIX DUMP.
 3400 CALL RDRNG (IMDMP1, IMDMP2, 0, 10000)
      IF (IMDMP1.LT.0)  THEN
        IMDMP1 = 0
        IMDMP2 = 0
      ENDIF
      CALL RDRNG (IRDMP1, IRDMP2, 0, 10000)
      GOTO 50

C-    TYPSET STYLE.
 3500 CALL RDTEXT (TSTYLE, LSTYLE, MAXSTY)
      GOTO 50

C-    TYPSET TAB.
 3600 CALL RDTEXT (TTAB, LTAB, MAXTAB)
      GOTO 50

C-    PAGE LENGTH.
 3700 CALL RDINT (LPRINT)
      IF (LPRINT.GT.0)  THEN
C       SET PAGING FOR FILES ALREADY OPEN.
        DO LUN = 1, NUN
          IF (LUNUSE(LUN).GT.0.AND.LUN.NE.LUNTO.AND.
     *     (LUN.EQ.LUNO.OR.LUN.EQ.LUNL)) LUNPAG(LUN) = 1
        ENDDO
      ENDIF
      GOTO 50
 
C-    TREAT CHARACTER AS VARIABLE.
 3800 IF (LUNC.LT.0)  THEN
        CALL OPNDEF (2)
        CALL INICHR (NFR, ILAST)
      ENDIF
      IF (LUNT.LT.0)  THEN
        CALL OPNDEF (3)
        CALL INITEM (NTR, NFI, LCDEP, ILAST)
      ENDIF
      IF (NOTMP.EQ.1)  CALL INITMP (NFR, NTR, ILAST, NSD, LWRK, NOTMP)
      CALL INITAX(NTR, ILAST)
      CALL TCMASK (D(KTAXA), NTR, D(KWRK2), NFR, 7)
      ITCHV = 1
      GOTO 50
 
C     INPUT FILE.
 3900 IF (NINPUT.GT.0)  GOTO 5000
      LUNTYP = 1
      CALL GETFLI (LUNTYP, IERR)
      IF (IERR.NE.0)  GOTO 9000
      NINPUT = NINPUT + 1
      GOTO 50
 
C     OUTPUT FORMAT RTF.
 4000 IF (JDIR(41).NE.0)  THEN
        CALL ERROR (JBUF, 'Equivalent directive already used.%')
      ELSE
        IRTF = 1
      ENDIF
      GOTO 50

C     OUTPUT FORMAT HTML.
 4100 IF (JDIR(40).NE.0)  THEN
        CALL ERROR (JBUF, 'Equivalent directive already used.%')
      ELSE
        IHTML = 1
        IRTF = 0
      ENDIF
      GOTO 50
 
C     PRINT COMMENT.
 4200 CONTINUE
      IF (LUNT.LT.0)  THEN
        CALL OPNDEF (3)
        CALL INITEM (NTR, NFI, LCDEP, ILAST)
      ENDIF
      IF (LUNC.LT.0)  THEN
        CALL OPNDEF (2)
        CALL INICHR (NFR, ILAST)
      ENDIF
      IF (NOTMP.EQ.1)  CALL INITMP (NFR, NTR, ILAST, NSD, LWRK, NOTMP)
      KBCMT = (KTMP-1) * NCHAR + 1
      CALL RDTEXTA (CSTR(KBCMT), LCMT, (NSD-KBCMT+1)*NCHAR)
      KTMP = KTMP + (LCMT+NCHAR-1)/NCHAR
      GOTO 50
 
C     OUTPUT DIRECTORY.
 4300 IERR = 0
      CALL NEXTWD (JE)
      IF (IBUF(JBUF:JBUF).EQ.STAR) THEN
        CALL ERROR (JBUF-1, 'Missing data.%')
        IERR = 1
      ENDIF
      IF (IERR.NE.0) GOTO 4310
      DIROUT = IBUF(JBUF:JE-1)
      LDIROUT = JE - JBUF
      IF (.NOT.CHKDIRY(DIROUT, LDIROUT))  THEN
        LDIROUT = 0
        CALL ERROR (JBUF-1,
     *   'The directory does not exist and cannot be created.%')
      ELSE
C       Add trailing '\' if not present.
        IF (DIROUT(LDIROUT:LDIROUT).NE.'\')  THEN
          LDIROUT = LDIROUT + 1
          DIROUT(LDIROUT:LDIROUT) = '\'
        ENDIF
      ENDIF
 4310 JBUF = JE
      GOTO 50
C

C--   CHECK THAT INPUT FILES HAVE BEEN OPENED.

C     ITEMS FILE.
 5000 IF (LUNT.LT.0)  THEN
        CALL OPNDEF (3)
        CALL INITEM (NTR, NFI, LCDEP, ILAST)
        IF (NOTMP.EQ.1)  CALL INITMP (NFR, NTR, ILAST, NSD, LWRK, NOTMP)
      ENDIF

C     CHARACTER FILE.
      IF (LUNC.LT.0)  THEN
        CALL OPNDEF(2)
        CALL INICHR (NFR, ILAST)
        IF (NOTMP.EQ.1)  CALL INITMP (NFR, NTR, ILAST, NSD, LWRK, NOTMP)
      ENDIF

C     COMPARE ITEM AND CHARACTER FILES.
      IF (NFR.NE.NFI)
     *  CALL FERROR ('Items and characters files do not match.%')

C-    READ MASKS FROM BINARY FILES, IF NOT ALREADY SPECIFIED.

C     READ CHARACTER MASK.
      IF (INFMSK.EQ.0)  THEN
        CALL RDDAI (D(KFMSK), NFR, MSKCHR, LUNT)
        NF = NONZER (D(KFMSK), NFR)
      ENDIF
      DO 5001 I = 1, NFR
        IF (D(KFMSK+I-1).NE.0)  D(KFMSK+I-1) = 1
 5001   CONTINUE

C     READ TAXON MASK.
      IF (INTMSK.EQ.0)  THEN
        CALL RDDAI (D(KTMSK), NTR, MSKTAX, LUNT)
        NTM = NONZER (D(KTMSK), NTR)
      ENDIF
      DO 5005 I = 1, NTR
        IF (D(KTMSK+I-1).NE.0)  D(KTMSK+I-1) = 1
 5005   CONTINUE

C     READ HEADER.
      IF (INHDR.EQ.0)  THEN
        CALL RDDAI (LHEAD, 1, IHDREC, LUNT)
        LHEAD = MIN0(LHEAD,MAXHDR)
        IHDREC = IHDREC + 1
        CALL RDCSTR (HEAD, LHEAD, IHDREC, LUNT)
      ENDIF

C     READ CHARACTER RELIABILITY INDICES.
      CALL RDDAR (RD(KRINDX), NFR, IRLREC, LUNT)

      DO 5010 I = 1, NFR
C       IF (D(KFMSK+I-1).NE.0)  THEN
          IF (INREL.EQ.1.AND.RD(KWRK1+I-1).GE.0)
     *     RD(KRINDX+I-1) = RD(KWRK1+I-1)
          IF (RD(KRINDX+I-1).LT.0)  RD(KRINDX+I-1) = 5.
C       ELSE
C         RD(KRINDX+I-1) = 0.
C       ENDIF
 5010   CONTINUE

C     READ ITEM ABUNDANCE INDICES.
      CALL RDDAR (RD(KAINDX), NTR, IABREC, LUNT)

      DO 5020 I = 1, NTR
        IF (D(KTMSK+I-1).NE.0)  THEN
          IF (INABUN.EQ.1.AND.RD(KWRK+I-1).GE.0.)
     *     RD(KAINDX+I-1) = RD(KWRK+I-1)
          IF (RD(KAINDX+I-1).EQ.0)  RD(KAINDX+I-1) = 5.
        ELSE
          RD(KAINDX+I-1) = 0.
        ENDIF
 5020   CONTINUE

C-    OUTPUT UNIT.
      LUNOUT = LUNL

      CALL JSTSTR ('Number of characters =', 0, LTXOUT)
      CALL JSTI (NFR, 0, LTXOUT)
      CALL JSTSTR ('Number of items =', 0, LTXOUT)
      CALL JSTI (NTR, 1, LTXOUT)

      CALL JSTSTR ('RBASE =', 0, LTXOUT)
      CALL JSTR (RBASE, 2, 0, LTXOUT)
      CALL JSTSTR ('ABASE =', 0, LTXOUT)
      CALL JSTR (ABASE, 2, 0, LTXOUT)
      CALL JSTSTR ('REUSE =', 0, LTXOUT)
      CALL JSTR (REUSE, 2, 0, LTXOUT)
      CALL JSTSTR ('VARYWT =', 0, LTXOUT)
      CALL JSTR (VARYWT, 1, 1, LTXOUT)

      CALL JSTSTR ('Number of confirmatory characters =',
     *  0, LTXOUT)
      CALL JSTI (NCONF, 0, LTXOUT)
      CALL JSTSTR ('Number of preset characters =', 0, LTXOUT)
      CALL JSTI (NSET, 1, LTXOUT)

      IF (IALG.EQ.2) THEN
        CALL JSTSTR ('Allow improper subgroups.', 0, LTXOUT)
      ENDIF
      IF (RES.GE.1.) THEN
        CALL JSTSTR ('Storage factor =', 0, LTXOUT)
        CALL JSTR (RES, 1, 0, LTXOUT)
      ENDIF
      IF (IALG.EQ.2 .OR. RES.GE.1) CALL JSTSTR (' ', 1, LTXOUT)

      CALL PRTMSK ('Characters', D(KFMSK), NFR, 0)
      CALL PRTMSK ('Items' ,D(KTMSK), NTR, 0)

C     IF STATE DESCRIPTIONS MUST BE READ.
      NP(7) = 0
      IF (NP(1).NE.0)  NP(7) = 1
      IF (NP(4).NE.0 .OR. NP(5).NE.0)  NP(7) = 2

C     IS A KEY REQUIRED.
      NP(8) = NP(3) + NP(4) + NP(5) + NP(6)
C     CHECK PARAMETER VALUES.
      IF (NFR.LT.0 .OR. NTR.LT.0 .OR.
     *   (NTR.EQ.0.AND.NP(8).NE.0) .OR.
     *   RBASE.LT.1 .OR. RBASE.GT.5 .OR.
     *   ABASE.LT.1 .OR. ABASE.GT.5 .OR.
     *   REUSE.LT.1 .OR. REUSE.GT.5 .OR.
     *   VARYWT.LT.0 .OR. VARYWT.GT.1 .OR.
     *   (RES.NE.0 .AND. RES.LT.1) .OR.
     *   NCONF.GT.4 .OR. NSET.LT.0 .OR.
     *   3*NSET+NFR+NTR.GT.MSTOR)  CALL FERROR ('Parameter errors.%')

C     CHECK OUTPUT UNITS.
      IF (LUNO.LT.0.AND.
     *  (NP(3).GT.0.OR.NP(4).GT.0.OR.(NP(5).GT.0.AND.ITPSET.LE.0)))
     *  CALL OPNDEF (4)
      IF (NP(5).NE.0.AND.LUNP.LT.0.AND.ITPSET.GT.0) THEN
        LTYPE = 5
        IF (IBINARY.NE.0) LTYPE = 10
        CALL OPNDEF (LTYPE)
      ENDIF
      IF (LUNS.LT.0.AND.NP(6).GT.0)  CALL OPNDEF (6)

C     IF REQUIRED, PUNCH HEADING AND PARAMETERS FOR STRUCTURE FILE.
      IF (NP(6).NE.0)  THEN
        CALL WRTREC (HEAD(1:LHEAD), LUNS)
        WRITE (LINE, 5060) NFR,NTR,TIM,DAT
 5060   FORMAT (2I5, 50X, A, 1X, A, '%')
        CALL MESS (LINE, LUNS)
      ENDIF
      GOTO 9100

 9000 CALL FERROR ('Execution terminated.%')

 9100 RETURN
      END
      SUBROUTINE PRESET (IPRE, L, NSET)                                     INOU

C  REVISED 8/10/86.
C  SETS CHARACTERS TO BE USED AT PARTICULAR POINTS IN THE KEY.

C  8/10/86. ORDER OF GROUP AND COLUMN REVERSED IN INPUT.

C  IPRE RETURNS THE PRESET INFORMATION.
C  L RECEIVES THE LENGTH OF IPRE.
C  NSET RETURNS THE NUMBER OF PRESET CHARACTERS.

C  INPUT IS IN THE FORM C,COL:GRP -
C   WHERE C IS A CHARACTER NUMBER.
C         COL IS A COLUMN NUMBER.
C         GRP IS A GROUP NUMBER.

      DIMENSION IPRE(L)

      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH

   10 CALL NEXTWD (JE)
        IF (IEOF.NE.0)  GOTO 100
        IF (IBUF(JBUF:JBUF).EQ.STAR)  GOTO 100

C       SEARCH FOR COMMA.
        JF = INDEX (IBUF(JBUF:JE), COMMA)
        IF (JF.EQ.0)  GOTO 30
        JF = JF + JBUF - 1
        CALL IDKOD (IC, IBUF(JBUF:JF-1), IERR)
        IF (IERR.NE.0)  GOTO 40
        JBUF = JF + 1

C       SEARCH FOR COLON.
        JF = INDEX (IBUF(JBUF:JE), COLON)
        IF (JF.EQ.0)  GOTO 30
        JF = JF + JBUF - 1
        CALL IDKOD (ICOL, IBUF(JBUF:JF-1), IERR)
        IF (IERR.NE.0)  GOTO 40
        JBUF = JF + 1

        CALL IDKOD (IGRP, IBUF(JBUF:JE-1), IERR)
        IF (IERR.NE.0)  GOTO 40

        NSET = NSET + 1
        ISET = 3*(NSET-1) + 1
        IPRE(ISET) = IC
        IPRE(ISET+1) = IGRP
        IPRE (ISET+2) = ICOL
        GOTO 50

   30   CALL ERROR (JBUF, 'Illegal syntax.%')
        GOTO 50

   40   CALL ERROR (JBUF, 'Invalid integer.%')

   50   JBUF = JE
        GOTO 10

  100 RETURN
      END
      SUBROUTINE PROGID (LUN)                                               INOU
 
C* REVISED 11-JUN-91.
C* OUTPUTS PROGRAM IDENTIFICATION.
 
C  LUN RECEIVES THE LOGICAL UNIT FOR THE OUTPUT.
 
      COMMON /PIDXXX/ PID
        CHARACTER*230 PID
 
      CHARACTER ENDLN*1
      PARAMETER(ENDLN='|')
 
      IB = 1
      L = LMESS(PID)
   10 L1 = INDEX(PID(IB:L), ENDLN) - 1
      IF (L1.LT.0)  L1 = L - IB + 1
      IF (L1.GT.0)  THEN
        CALL WRTREC (PID(IB:IB+L1-1), LUN)
      ELSE
        CALL WRTREC(' ', LUN)
      ENDIF
      IB = IB + L1 + 1
      IF (IB.LE.L)  GOTO 10
 
      RETURN
      END
      SUBROUTINE RDBUF                                                      INOU

C* REVISED 08-MAR-99.
C* READS NEXT INPUT RECORD.

      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /LUNDXX/ LUND
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(10),LUNPRE(10),
     *  LUNUSE(13),LUNREC(13),LUNPAG(13)
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      COMMON /TPSXXX/ ITPSET,MAXTYPMK,NTYPMK,LTYPMK,INTYPMKS
C
      LIREC = 120
      IEOF = 0
      IF (LUNUSE(LUNI).LE.0)  THEN
        IEOF = 1
        GOTO 40
      ENDIF

      CALL RREC (IBUF, LIREC, JEDAT, LUNI)
C
      IF (JEDAT.LT.0)  THEN
        IEOF = 1
        CLOSE(UNIT=LUNI)
C        LUNUSE(LUNI) = -1
C        LUNREC(LUNI) = 0
C       End of an input file?
        IF (LUNI.NE.LUND.AND.NINPUT.GT.0) THEN
          L = LUNI
          LUNI = LUNPRE(1)
          LUNPRE(1) = L
          NINPUT = NINPUT - 1
          IEOF = 0
        ENDIF
        GOTO 40
      ELSE IF (JEDAT.GT.0)  THEN
   20   IF (JEDAT.LT.1)  GOTO 30
          IF (IBUF(JEDAT:JEDAT).NE.BLANK)  GOTO 30
          JEDAT = JEDAT - 1
          GOTO 20
      ENDIF
 
   30 JEDAT = JEDAT + 1
      IBUF(JEDAT:JEDAT) = BLANK
      JBUF = 1

   40 RETURN
      END
      SUBROUTINE RDCSTR (STR, N, IREC, LUN)                                 INOU

C  REVISED 21/6/85.
C  READS N CHARACTERS FROM A DIRECT ACCESS FILE INTO THE ARRAY STR.
C  READING COMMENCES AT RECORD IREC ON LOGICAL UNIT LUN.


      CHARACTER*1 STR
      DIMENSION STR(N)

      COMMON /LRECDA/ LRECDA,LCREC

      I = 0
      NN = N
      JREC = IREC

   10 IF (NN.LE.0)  GOTO 20
        IREAD = MIN0 (NN,LCREC)
        READ(LUN,REC=JREC) (STR(J),J=I+1,I+IREAD)
        I = I + IREAD
        JREC = JREC + 1
        NN = NN - IREAD
        GOTO 10

   20 RETURN
      END
      SUBROUTINE RDDAI (IA, N, IREC, LUN)                                   INOU

C  REVISED 7/6/85.
C  READS N INTEGER WORDS FROM A DIRECT-ACCESS FILE INTO THE ARRAY IA.
C  READING COMMENCES AT RECORD IREC ON LOGICAL UNIT LUN.


      DIMENSION IA(N)

      COMMON /LRECDA/ LRECDA,LCREC

      I = 0
      NN = N
      JREC = IREC

   10 IF (NN.LE.0)  GOTO 20
        IREAD = MIN0 (NN,LRECDA)
        READ(LUN,REC=JREC) (IA(J),J=I+1,I+IREAD)
        I = I + IREAD
        JREC = JREC + 1
        NN = NN - IREAD
        GOTO 10

   20 RETURN
      END
      SUBROUTINE RDDAR (A, N, IREC, LUN)                                    INOU

C  REVISED 29/5/86.
C  READS N REAL WORDS FROM A DIRECT-ACCESS FILE INTO THE ARRAY A.
C  READING COMMENCES AT RECORD IREC ON LOGICAL UNIT LUN.


      DIMENSION A(N)

      COMMON /LRECDA/ LRECDA,LCREC

      I = 0
      NN = N
      JREC = IREC

   10 IF (NN.LE.0)  GOTO 20
        IREAD = MIN0 (NN,LRECDA)
        READ(LUN,REC=JREC) (A(J),J=I+1,I+IREAD)
        I = I + IREAD
        JREC = JREC + 1
        NN = NN - IREAD
        GOTO 10

   20 RETURN
      END
      SUBROUTINE RDINT (NUM)                                                INOU
C
C* REVISED 14/2/86.
C* READS A SINGLE INTEGER VALUE.
C
C  NUM RETURNS THE VALUE.
C
C  NEW RECORDS ARE READ IF REQUIRED.
C  ON EXIT, JBUF IS POSITIONED AFTER THE NUMBER, OR, IF THE NUMBER
C    WAS MISSING, AT THE START OF THE NEXT STAR-WORD.
C
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
C
C     LOCATE AND DECODE WORD.
      CALL NEXTWD (JE)
      IF (IEOF.NE.0)  GOTO 100
      IF (IBUF(JBUF:JBUF).EQ.STAR)  GO TO 100
      CALL IDKOD (NUM, IBUF(JBUF:JE-1), IERR)
      IF (IERR.NE.0)  CALL ERROR (JBUF, 'Invalid integer.%')
      JBUF = JE
  100 RETURN
      END
      SUBROUTINE RDKOD (X, IBF, IERR)                                       INOU

C  REVISED 23-JUN-92.
C  DECODES A REAL VALUE.


      CHARACTER*(*) IBF
      CHARACTER*10 FMT

      IERR = 0
      L = LEN (IBF)
      IF (L.LE.0)  GOTO 20

      WRITE (FMT,10)L
   10 FORMAT( '(F',I4, '.0)' )
      READ(IBF,FMT,ERR=20) X
      GOTO 30

   20 IERR = 1

   30 RETURN
      END
      SUBROUTINE RDMSK (ISET, MSK, LMSK, INCL)                              INOU
C
C* REVISED 11/6/85.
C* READS A MASK.
C
C  ISET RECEIVES A FLAG INDICATING THE VALUES TO BE SET IN THE MASK.
C    POSITIVE - 1 SET. ZERO - 0 SET. NEGATIVE - FIRST VALUE OF EACH
C    RANGE SET.
C  MSK RETURNS THE MASK (SEE BELOW).
C  LMSK RECEIVES THE LENGTH OF MSK.
C  INCL RETURNS THE NUMBER OF ELEMENTS OF MSK WITH NON-ZERO VALUES.
C
C  THE INPUT TAKES THE FORM N1-M1 N2-M2 ... AND IS TERMINATED BY A
C    STAR-WORD. THE -M1, -M2, ... ARE OPTIONAL.
C  MSK(N1) TO MSK(M1), ETC., ARE SET TO THE VALUE SPECIFIED BY ISET.
C    THE REST ARE SET TO 0 IF ISET IS NON-ZERO, OR 1 IF ISET IS ZERO.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR OF THE STAR-WORD.
C
      DIMENSION MSK(LMSK)
C
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
C
      JSET = MIN0(1,IABS(ISET))
      JPRE = 1 - JSET
      CALL SETIA (MSK, LMSK, JPRE)
C
C-    GET NEXT WORD AND CHECK FOR STAR.
   20 CALL NEXTWD (JE)
        IF (IEOF.NE.0)  GOTO 1000
        IF (IBUF(JBUF:JBUF).EQ.STAR)  GO TO 1000
C
C-      DECODE RANGE.
        CALL DERNG (IB, IE, 1, LMSK, JBUF, JE)
        IF (IB.LE.0)  GO TO 300
C
C-      SET VALUES.
        IF (ISET.LT.0)  JSET = IB
        DO 150 I = IB, IE
          IF (MSK(I).NE.JPRE)  GO TO 200
  150     MSK(I) = JSET
        GO TO 300
C
C-      ERROR MESSAGE.
  200   CALL ERROR (JBUF, 'Value already specified.%')
C
C-      PREPARE FOR NEXT WORD.
  300   JBUF = JE
        GO TO 20
C
C-    COUNT NUMBER OF NON-ZERO VALUES.
 1000 INCL = NONZER(MSK,LMSK)
      RETURN
      END
      SUBROUTINE RDNTXT (ITERM, DELIM, ITYPMKS, ITXT, LTXT, JTXT, IERR)    DIRG
 
C  REVISED 29-MAR-99.
C  READS LINES OF TEXT UP TO THE NEXT DELIMITER. TRAILING BLANKS ARE
C    REMOVED.
 
C  ITERM RECEIVES
C    0 IF THE DELIMITER MUST BE A BLANK-STAR
C    1 IF IT MAY BE EITHER BLANK-STAR OR BLANK-NUMERO.
C    2 IF THE DELIMITER MUST BE THAT SPECIFIED IN DELIM.
C  DELIM RECEIVES THE DELIMITER IF ITERM IS 2.
C  ITYPMKS RECEIVES WHETHER THIS IS READING THE "TYPESETTING MARKS" DIRECTIVE
C   IN BINARY MODE.
C   IF TRUE, THE BLANK NORMALLY APPENDED TO INPUT RECORDS IS IGNORED TO AVOID
C   UNWANTED BLANKS WITHIN THE TYPESETTING STRINGS.
C  ITXT RETURNS THE TEXT.
C  LTXT RECEIVES THE LENGTH OF ITXT.
C  JTXT RETURNS THE LENGTH OF TEXT READ.
C  IERR RETURNS 1 IF THE TEXT IS TOO LONG, 0 OTHERWISE.
 
 
      DIMENSION ITXT(LTXT)
      CHARACTER*1 DELIM
 
      COMMON /BLKXXX/ KBLANK
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
 
      IBKT = 0
      IERR = 0
      JTXT = 3
      IEND = ITERM
      CALL SKNONB
      NEWREC = 0
 
      IF (IEOF.NE.0)  GOTO 70
 
      IF (ITYPMKS.NE.0)  THEN
C       CHECK FOR END OF CURRENT ITEM BEFORE REMOVING TRAILING BLANK
        IF (IBUF(JBUF:JBUF).EQ.STAR .OR.
     *      IBUF(JBUF:JBUF).EQ.NUMERO) GOTO 5
 
C       STRIP TRAILING BLANK IF THIS IS WITHIN "TYPESETTING MARKS" DIRECTIVE.
        IF (IBUF(JEDAT:JEDAT).EQ.BLANK) JEDAT = JEDAT - 1
      ENDIF
 
    5 IF (IEND.EQ.2)  THEN
        IF (IBUF(JBUF:JBUF).NE.DELIM)  THEN
          IEND = 1
        ELSE
          JBUF = JBUF + 1
          IF (JBUF.GT.JEDAT)  THEN
            CALL RDBUF
            NEWREC = 1
C           FORCE END OF TEXT IF END-OF-FILE.
            IF (IEOF.NE.0)  IEND = 1
          ENDIF
        ENDIF
      ENDIF
 
      INBRACE  = 0
   10 IF ((IEND.LE.1.AND.IBUF(JBUF:JBUF).EQ.STAR) .OR.
     *    (IEND.EQ.1.AND.IBUF(JBUF:JBUF).EQ.NUMERO) .OR.
     *    (IEND.EQ.1.AND.IEOF.NE.0) )  THEN
        GOTO 50
      ELSEIF (IEND.EQ.2.AND.IBUF(JBUF:JBUF).EQ.DELIM)  THEN
        GOTO 40
      ENDIF
        IF (JTXT.GE.LTXT)  THEN
          IERR = 1
          GOTO 100
        ENDIF
        IF (ITYPMKS.NE.0 .AND. NEWREC.NE.0) THEN
C         REMOVE TERMINATING BLANK.
          IF (IBUF(JEDAT:JEDAT).EQ.BLANK) JEDAT = JEDAT - 1
          NEWREC = 0
        ENDIF
        JTXT = JTXT + 1
        ITXT(JTXT) = ICHAR(IBUF(JBUF:JBUF))
C       Check for match {}.
        IF (ITXT(JTXT).EQ.ICHAR(LBRACE).AND.
     *      ITXT(JTXT-1).NE.ICHAR(BSLSH)) THEN
          INBRACE = INBRACE + 1
        ELSEIF (ITXT(JTXT).EQ.ICHAR(RBRACE).AND.
     *          ITXT(JTXT-1).NE.ICHAR(BSLSH)) THEN
          INBRACE = INBRACE - 1
        ENDIF
        JBUF = JBUF + 1
        IF (JBUF.GT.JEDAT)  THEN
          CALL RDBUF
          NEWREC = 1
C         FORCE END OF TEXT IF END-OF-FILE.
          IF (IEND.EQ.2.AND.IEOF.NE.0)  THEN
            IEND = 1
            CALL ERROR (JBUF-1, 'Excess data or missing delimiter.%')
          ENDIF
        ENDIF
        GOTO 10
 
C     WHEN DELIMITER USED, SKIP TO NEXT * OR #.
   40 JBUF = JBUF + 1
   41 CALL NEXTWD(JE)
        IF (IEOF.NE.0 .OR.
     *      IBUF(JBUF:JBUF).EQ.STAR .OR.
     *      IBUF(JBUF:JBUF).EQ.NUMERO)  GOTO 70
        JBUF = JE
        GOTO 41
 
C     IF NO DELIMITER, REMOVE TRAILING BLANKS.
   50 L = JTXT
      DO 60 I = L, 4, -1
        IF (ITXT(I).NE.KBLANK)  GOTO 70
        JTXT = JTXT - 1
   60   CONTINUE
 
   70 IF (JTXT.GT.3)  THEN
        ITXT(1) = JTXT
        ITXT(2) = JTXT - 1
        ITXT(3) = 1
      ELSE
        JTXT = 0
      ENDIF
 
C     If this is not a TYPESETTING MARKS directive, report unmatched braces.
      IF (ITYPMKS.EQ.0.AND.INBRACE.NE.0)
     *  CALL ERROR (JBUF-1, 'Unmatched {} in preceding text.%')
 
  100 RETURN
      END
      SUBROUTINE RDREAL (X)                                                 INOU
C
C* REVISED 14/2/86.
C* READS A SINGLE REAL VALUE.
C
C  X RETURNS THE VALUE.
C
C  NEW RECORDS ARE READ IF REQUIRED.
C  ON EXIT, JBUF IS POSITIONED AFTER THE NUMBER, OR, IF THE NUMBER
C    WAS MISSING, AT THE START OF THE NEXT STAR-WORD.
C
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
 
C     LOCATE AND DECODE WORD.
      CALL NEXTWD (JE)
      IF (IEOF.NE.0)  GOTO 40
      IF (IBUF(JBUF:JBUF).EQ.STAR)  GO TO 40
      CALL RDKOD (X, IBUF(JBUF:JE-1), IERR)
      IF (IERR.NE.0)  CALL ERROR (JBUF, 'Invalid real number.%')
      JBUF = JE
C
   40 RETURN
      END
      SUBROUTINE RDRNG (IB, IE, IMIN, IMAX)                                 INOU
C
C* REVISED 17/6/87.
C* READS A SINGLE NUMERIC RANGE.
C
C  IB RETURNS THE START OF THE RANGE, OR IMIN-1 IF THERE ARE ERRORS.
C  IE RETURNS THE END OF THE RANGE.
C  IMIN RECEIVES THE MINIMUM ALLOWED VALUE.
C  IMAX RECEIVES THE MAXIMUM ALLOWED VALUE.

      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH

C-    GET NEXT WORD AND CHECK FOR STAR.
      CALL NEXTWD (JE)
      IF (IEOF.NE.0)  GOTO 900
      IF (IBUF(JBUF:JBUF).EQ.STAR)  GO TO 900

C-    DECODE RANGE.
      CALL DERNG (IB, IE, IMIN, IMAX, JBUF, JE)
      JBUF = JE
      GOTO 1000

  900 IB = IMIN - 1

 1000 RETURN
      END
      SUBROUTINE RDSENL (IDAT, LIDAT, IMAX, ITYPMRK, NR, JIDAT)             DIR4
 
C* REVISED 25-FEB-99.
C* READS A LIST OF NUMBERED TEXT STRINGS.
 
C  IDAT RETURNS THE STRINGS (SEE BELOW).
C  LIDAT RECEIVES THE LENGTH OF IDAT. ITS VALUE MUST BE IDENTICAL WITH
C    THE VALUE IN DIM XXX.
C  IMAX RECEIVES THE LARGEST PERMITTED STRING NUMBER.
C  ITYPMRK RECEIVES WHETHER THIS IS PROCESSING THE "TYPESETTING MARKS"
C    DIRECTIVE, IN BINARY OUTPUT MODE.
C   IF TRUE, THE BLANK NORMALLY APPENDED TO INPUT RECORDS IS IGNORED TO AVOID
C   UNWANTED BLANKS WITHIN THE TYPRSETTING STRINGS.
C  NR RETURNS THE NUMBER OF NUMBERED STRINGS READ.
C  JIDAT RETURNS THE POSITION OF THE LAST ELEMENT OF IDAT USED.
 
C  THE INPUT TAKES THE FORM  N1. STRING1 N2. STRING2  ETC., AND IS
C   TERMINATED BY A STAR-WORD.
C  THE STRINGS (SEE SUBR. SENTNC) ARE STORED FROM IDAT(IMAX+1) ON.
C    IDAT(N) POINTS TO THE STARTING LOCATION OF SENTENCE N.
C    A NEGATIVE VALUE INDICATES AN INVALID SENTENCE.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR OF THE STAR-WORD.
 
      DIMENSION IDAT(LIDAT)
      CHARACTER*1 DELIM
C
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
C
      PARAMETER (MAXWSK=1500)
 
      CALL SETIA (IDAT, IMAX, 0)
      JIDAT = IMAX
 
C     CHECK FOR PRESENCE OF OPTIONAL DELIMITER.
      CALL NEXTWD (JE)
        IF (IBUF(JBUF:JBUF).EQ.STAR)  GOTO 600
        IF (IBUF(JBUF:JBUF).EQ.NUMERO)  THEN
          IEND = 1
        ELSEIF (JE-JBUF.GT.1)  THEN
          IEND = 1
          GOTO 250
        ELSEIF (IBUF(JBUF:JBUF).EQ.LABRAC.OR.
     *          IBUF(JBUF:JBUF).EQ.RABRAC) THEN
          IEND = 1
          GOTO 260
        ELSE
          DELIM = IBUF(JBUF:JBUF)
          IEND = 2
          JBUF = JE
        ENDIF
 
C-    FIND AND DECODE NUMBER.
  100 IF (IEOF.NE.0)  GOTO 600
        CALL NEXTWD (JE)
  101   IF (IBUF(JBUF:JBUF).EQ.STAR)  GO TO 600
        IF (IBUF(JE-1:JE-1).NE.STOP)  GO TO 200
        IF (IBUF(JBUF:JBUF).EQ.NUMERO)  JBUF = JBUF + 1
        IF (JE-JBUF.LE.1)  GO TO 210
        CALL IDKOD (IN, IBUF(JBUF:JE-2), IERR)
        IF (IERR.NE.0)  GO TO 220
        IF (IN.LT.1)  GOTO 230
        IF (IN.GT.IMAX)  GO TO 231
        IF (IDAT(IN).NE.0)  GO TO 240
        NR = IN
 
C       CHECK FOR PRESENCE OF COMMENT.
        JBUF = JE
        CALL NEXTWD (JE)
        IF (IBUF(JBUF:JBUF).NE.LABRAC)  GOTO 150
        
C       LOOK FOR CLOSING BRACKET.
        NSKIP = 0
  120   IF (IBUF(JBUF:JBUF).EQ.STAR.OR.
     *      IBUF(JBUF:JBUF).EQ.NUMERO) GOTO 270
        IF (IBUF(JE-1:JE-1).EQ.RABRAC)  THEN
          JBUF = JE
          GOTO 150
        ELSE
          JBUF = JE
          CALL NEXTWD (JE)
          NSKIP = NSKIP + 1
          IF (IEOF.NE.0)  GOTO 700
          IF (NSKIP.GT.MAXWSK)  GOTO 710
          GOTO 120
        ENDIF
 
C-      READ TEXT ASSOCIATED WITH NUMBER.
  150   CALL RDNTXT (IEND, DELIM, ITYPMRK, IDAT(JIDAT+1), LIDAT-JIDAT,
     *   LEN, IERR)
        IF (LEN.GT.0)  THEN
          IDAT(IN) = JIDAT + 1
          JIDAT = JIDAT + LEN
        ELSE
          IDAT(IN) = 0
        ENDIF
        IF (IERR.NE.0)  GOTO 500
        GO TO 100
 
C-      ERROR MESSAGES.
  200   IPOINT = JE - 1
        CALL ERROR (IPOINT, 'Full stop missing.%')
        JBUF = JBUF + 1
        GO TO 300
  210   IPOINT = JBUF
        CALL ERROR (IPOINT, 'Missing number.%')
        GO TO 300
  220   IPOINT = JBUF + IERR - 1
        CALL ERROR (IPOINT, 'Illegal symbol - number expected.%')
        GO TO 300
  230   IPOINT = JBUF
        CALL ERROR (IPOINT, 'Value less than permitted minimum.%')
        GO TO 300
  231   IPOINT = JBUF
        CALL ERROR (IPOINT, 'Value greater than permitted maximum.%')
        GO TO 300
  240   CALL ERROR (JBUF, 'Item has already been specified.%')
        GOTO 300
  250   IPOINT = JBUF
        CALL ERROR (IPOINT, 'Delimiter must be a single character.%')
        GOTO 300
  260   IPOINT = JBUF
        CALL ERROR (IPOINT, 'Illegal delimiter.%')
        GOTO 300
  270   IPOINT = JBUF - 1
        CALL ERROR (IPOINT, 'Closing bracket is missing.%')
        GOTO 300
 
C  300   CALL SKDELW (1)
C        GOTO 100
  300   CALL SKDELW
        GOTO 600
  
  500   CALL ERROR(0, 'Insufficient storage for TYPESETTING MARKS.%')
        NR = 0
 
  600 RETURN
 
  700 CALL FERROR ('Closing bracket is missing.%')
 
  710 CALL FERROR
     * ('More than 200 words without finding a closing bracket.%')
 
      END
      SUBROUTINE RDTEXT (TEXT, LTEXT, MAXTXT)                               INOU

C  REVISED 1/4/87.
C  READS TEXT FROM INPUT.

      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH

      CHARACTER*(*) TEXT

      ISK = 0
      CALL SKNONB
      LTEXT = 0

   10 CONTINUE
      J = INDEX (IBUF(JBUF:JEDAT), STAR)
        IF (J.EQ.0)  THEN
          JE = JEDAT
        ELSE
          JE = J + JBUF - 2
        ENDIF
        L = JE - JBUF + 1
        IF (L.LE.0)  GOTO 100
        IF (LTEXT+L.GT.MAXTXT)  THEN
          L = MAXTXT - LTEXT
          ISK = 1
        ENDIF
        TEXT(LTEXT+1:LTEXT+L) = IBUF(JBUF:JBUF+L-1)
        LTEXT = LTEXT + L
        IF (ISK.NE.0)  GOTO 50
        IF (J.NE.0)  GOTO 100
        CALL RDBUF
        IF (IEOF.NE.0)  GOTO 100
        GOTO 10

   50 CALL SKDELW

  100 RETURN
      END
      SUBROUTINE RDTEXTA (TEXT, LTEXT, MAXTXT)                              INOU

C  REVISED 20-APR-99.
C  READS TEXT FROM INPUT.
C  (SAME AS RDTEXT, BUT READS INTO A CHARACTER*1 ARRAY)

      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH

      CHARACTER*1 TEXT(MAXTXT)

      ISK = 0
      CALL SKNONB
      LTEXT = 0

   10 CONTINUE
      J = INDEX (IBUF(JBUF:JEDAT), STAR)
        IF (J.EQ.0)  THEN
          JE = JEDAT
        ELSE
          JE = J + JBUF - 2
        ENDIF
        L = JE - JBUF + 1
        IF (L.LE.0)  GOTO 100
        IF (LTEXT+L.GT.MAXTXT)  THEN
          L = MAXTXT - LTEXT
          ISK = 1
        ENDIF
        DO JJ = 1, L
          TEXT(LTEXT+JJ) = IBUF(JBUF+JJ-1:JBUF+JJ-1)
        ENDDO
        LTEXT = LTEXT + L
        IF (ISK.NE.0)  GOTO 50
        IF (J.NE.0)  GOTO 100
        CALL RDBUF
        IF (IEOF.NE.0)  GOTO 100
        GOTO 10

   50 CALL SKDELW

  100 RETURN
      END
      SUBROUTINE SETIA (IA, N, IVAL)                                        INOU

C  REVISED 7/6/85.
C  SETS ELEMENTS OF AN INTEGER ARRAY TO A GIVEN VALUE.

      DIMENSION IA(N)

      DO 10 I = 1, N
        IA(I) = IVAL
   10   CONTINUE

      RETURN
      END
      SUBROUTINE SETRA (RA, N, RVAL)                                        INOU

C* REVISED 1/9/87.
C* SETS ELEMENTS OF AN REAL ARRAY TO A GIVEN VALUE.

      DIMENSION RA(N)

      DO 10 I = 1, N
        RA(I) = RVAL
   10 CONTINUE

      RETURN
      END
      SUBROUTINE SETLUN (FSPEC, LUN, LUNTYP)                                INOU

C* REVISED 19-APR-99.
C* SETS ATTRIBUTES OF A NEW LOGICAL UNIT.

C  FSPEC RECEIVES THE FILE SPECIFICATION.
C  LUN RECEIVES THE LOGICAL UNIT.
C  LUNTYP RECEIVES THE TYPE OF THE FILE.

      COMMON /LUFXXX/ FNAME(12),LFNAME(12)
        CHARACTER FNAME*128
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(10),LUNPRE(10),
     *  LUNUSE(13),LUNREC(13),LUNPAG(13)

      CHARACTER*60 FSPEC
      DIMENSION LU(10)
      EQUIVALENCE (LU(1),LUNI)

C      CALL EXNAME (FSPEC, FNAME(LUN))
C     Need to retain directory information.
      FNAME(LUN) = FSPEC
      LFNAME(LUN) = LSTRB(FSPEC)
      LUNPRE(LUNTYP) = LU(LUNTYP)
      LUNUSE(LUN) = LUNCOM(LUNTYP)
      LU(LUNTYP) = LUN
      IF ((LUNTYP.EQ.4.OR.LUNTYP.EQ.8).AND.LPRINT.GT.0) LUNPAG(LUN) = 1

      RETURN
      END
      SUBROUTINE SKB                                                        INOU

C  REVISED 11/4/88.
C  SKIPS TO THE FIRST BLANK SYMBOL.

C  NEW RECORDS ARE READ IF REQUIRED.
C  ON EXIT, JBUF IS AT THE BLANK SYMBOL.

      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH

      IF (IEOF.NE.0)  GOTO 10
      J = INDEX (IBUF(JBUF:JEDAT), BLANK)
      JBUF = J + JBUF - 1
   10 RETURN
      END
      SUBROUTINE SKDELW                                                     INOU

C* REVISED 11/4/87.
C* SKIPS TO THE START OF THE NEXT WORD STARTING WITH A STAR.

C  THE DELIMITER MAY BE AT THE CURRENT POSITION OF JBUF ON ENTRY.
C  NEW RECORDS ARE READ IF REQUIRED.
C  ON EXIT, JBUF IS POSITIONED AT THE DELIMITER.

      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH

C     MAXIMUM NUMBER OF WORDS TO BE SKIPPED.
      DATA MAXWSK/500/                                                        =*

      IF (IEOF.NE.0)  GOTO 200
      NWSK = 0
      IF (JBUF.EQ.1)  GO TO 100
      IF (IBUF(JBUF-1:JBUF-1).NE.BLANK)  CALL SKB

  100 CALL SKNONB
      IF (IEOF.NE.0)  GOTO 200
        IF (IBUF(JBUF:JBUF).EQ.STAR)  GO TO 200
        CALL SKB
        NWSK = NWSK + 1
        IF (NWSK.GT.MAXWSK)  GO TO 300
        GO TO 100

  200 RETURN

  300 CALL FERROR ('No legal delimiter found.%')
      END
      SUBROUTINE SKNONB                                                     INOU

C  REVISED 11/4/88.
C  SKIPS TO THE FIRST NON-BLANK CHARACTER.

C  NEW RECORDS ARE READ IF REQUIRED.
C  ON EXIT, JBUF IS AT THE NON-BLANK CHARACTER.

      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH

      IF (IEOF.NE.0)  GOTO 20
   10 IF (IBUF(JBUF:JBUF).NE.BLANK)  GO TO 20
        JBUF = JBUF + 1
        IF (JBUF.GT.JEDAT)  THEN
          CALL RDBUF
          IF (IEOF.NE.0)  GOTO 20
        ENDIF
        GO TO 10
   20 RETURN
      END
      SUBROUTINE TCMASK (ITAXA, NI, ICHARS, NC, LUNTYP)                     INOU
 
C* REVISED 7-SEP-94.
C* READS A CHARACTER MASK ASSOCIATED WITH A PARTICULAR TAXON.
 
C  ITAXA RETURNS RECORD ADDRESSES OF CHARACTER MASKS.
C  NI RECEIVES THE NUMBER OF TAXA.
C  ICHARS RECEIVES WORKING SPACE OF LENGTH NC.
C  NC RECEIVES THE NUMBER OF CHARACTERS.
C  LUNTYP RECEIVES TYPE OF OUTPUT FILE - SCRATCH.
 
C  THE INPUT TAKES THE FORM #T1. N1-M1 N2-M2 ... #T2. N1-M1 N2-M2 ...
C     AND IS TERMINATED BY A STAR-WORD. THE -M1, -M2, ... ARE OPTIONAL.
C  NEW RECORDS ARE READ IF REQUIRED.
C  IF AN ERROR IS FOUND, A MESSAGE IS PRINTED, IDERR IS SET, AND
C    NCERR IS INCREMENTED.
C  ON EXIT, JBUF IS POSITIONED AT THE STAR OF THE STAR-WORD.
 
      DIMENSION ITAXA(NI),ICHARS(NC)
      CHARACTER FSPEC*60, MBUF*70
 
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(10),LUNPRE(10),
     *  LUNUSE(13),LUNREC(13),LUNPAG(13)
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
 
 
C-    OPEN SCRATCH FILE.
      LRECS = NC
      CALL GETAU (LUN)
      FSPEC = 'scratch'
      CALL SETLUN (FSPEC, LUN, LUNTYP)
      CALL UOPEN (LUN, LUNUSE(LUN), FSPEC, LRECS, IERR)
      IF (IERR.NE.0) THEN 
        WRITE (MBUF, 210) FSPEC
  210   FORMAT ('Unable to open output file - ', A, '.%')
        CALL FERROR (MBUF)
      ENDIF

 
C     SET RECORD POINTER FOR SCRATCH FILE.
      IRECS = 0
 
C-    INITIALIZE TAXON RECORD POINTERS.
      CALL SETIA (ITAXA, NI, 0)
 
  
      IFIRST = 1
 
C-    GET NEXT WORD AND CHECK FOR STAR OR NUMERO.
   20 CALL NEXTWD (JE)
 
   30   IF (IEOF.NE.0.OR.
     *      IBUF(JBUF:JBUF).EQ.STAR.OR.IBUF(JBUF:JBUF).EQ.NUMERO) THEN
 
C         OUTPUT PREVIOUS DIAGNOSTIC CHARACTER SET.
          IF (IFIRST.EQ.0)  THEN
            IF (ITAXA(IT).EQ.0)  THEN
              IRECS = IRECS + 1
              IRECO = IRECS
              ITAXA(IT) = IRECS
            ELSE
              IRECO = ITAXA(IT)
            ENDIF
            WRITE(LUNS1,REC=IRECO) (ICHARS(I),I=1,NC)
C           CALL WRDAI (ICHARS, NC, LUN, LRECS, IRECO)
          ENDIF
          IF (IEOF.NE.0.OR.IBUF(JBUF:JBUF).EQ.STAR)  GOTO 1000
 
C         READ TAXON NUMBER.
          IF (IBUF(JE-1:JE-1).NE.STOP)  GOTO 76
          JBUF = JBUF + 1
          CALL IDKOD (IT, IBUF(JBUF:JE-2), IERR)
          IF (IERR.NE.0)  GOTO 70
          IF (ITAXA(IT).EQ.0)  THEN
            CALL SETIA (ICHARS, NC, 0)
          ELSE
            IREC = ITAXA(IT)
            READ(LUNS1,REC=IREC) (ICHARS(I),I=1,NC)
C           CALL RDDAI (ICHARS, NC, IREC, LUNS1)
          ENDIF
          IFIRST = 0
 
        ELSE
 
          IF (IFIRST.NE.0)  GOTO 75
C-        DECODE CHARACTER RANGE.
   40     CALL DERNG (IB, IE, 1, NC, JBUF, JE)
          IF (IB.LE.0)  GO TO 60
 
C-        SET VALUES.
          DO 50 I = IB, IE
            ICHARS(I) = 1
   50     CONTINUE
 
        ENDIF
 
C-      PREPARE FOR NEXT WORD.
   60   JBUF = JE
        GO TO 20
 
C-    INVALID TAXON NUMBER - SKIP TO NEXT STAR OR NUMERO.
   70 CALL ERROR(JBUF, 'Invalid taxon number.%')
      GOTO 80
   75 CALL ERROR(JBUF, '# expected.%')
      GOTO 80
   76 CALL ERROR(JE, 'Full stop missing.%')
      JBUF = JE
 
   80 CALL NEXTWD (JE)
        IF (IEOF.NE.0)  GOTO 1000
        IF (IBUF(JBUF:JBUF).EQ.STAR)  GOTO 1000
        IF (IBUF(JBUF:JBUF).EQ.NUMERO)  GOTO 30
        JBUF = JBUF + 1
        GOTO 80
 
 1000 RETURN
      END
      SUBROUTINE UCLOSE                                                     INOU

C* REVISED 26-MAR-99.
C* CLOSES FILES, LISTS NAMES OF OUTPUT FILES, AND STOPS.

C  NOTE. LUNFLG IS USED AS WORKING SPACE FOR FLAGS:
C    0 - DO NOT CLOSE FILE.
C    1 - CLOSE. 2 - CLOSE, LIST AS NON-EMPTY OUTPUT FILE.
C    3 - CLOSE AND DELETE. 4 - CLOSE AND DELETE, LIST AS EMPTY
C    OUTPUT FILE.

      LOGICAL*4 O,N,E
      CHARACTER*50 MBUF

      COMMON /ERRXXX/ IERR
      COMMON /LUFXXX/ FNAME(12),LFNAME(12)
        CHARACTER FNAME*128
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(10),LUNPRE(10),
     *  LUNUSE(13),LUNREC(13),LUNPAG(13)
      COMMON /LUTXXX/ LUNTI,LUNTO

C     LENGTH OF LUNFLG MUST BE EQUAL NUN.                                     =/
      DIMENSION LUNFLG(13)                                                    =*
 
   10 FORMAT (3X, A, '%')

      IF (IERR.NE.0) CALL EMESS ('ABNORMAL TERMINATION.%')

C     WHETHER THERE ARE NON-EMPTY AND EMPTY OUTPUT FILES TO BE LISTED.
      N = .FALSE.
      E = .FALSE.

C--   SET FLAGS TO SHOW HOW EACH UNIT MUST BE TREATED.
      DO 100 LUN = 1, NUN
        L = LUNUSE(LUN)

C-      UNUSED OR TERMINAL.
        IF (L.LE.0 .OR. LUN.EQ.LUNTO .OR. LUN.EQ.LUNTI) THEN
          LUNFLG(LUN) = 0

C-      INPUT.
        ELSEIF (L.LE.3) THEN
          LUNFLG(LUN) = 1
 
C-      OUTPUT.
        ELSEIF (L.GE.4 .AND. L.LE.6.OR.L.EQ.10) THEN
          IF (LUNREC(LUN).GT.0) THEN
            LUNFLG(LUN) = 2
            N = .TRUE.
          ELSE
            IF (IERR.GT.0) THEN
              LUNFLG(LUN) = 3
            ELSE
              LUNFLG(LUN) = 4
              E = .TRUE.
            ENDIF
          ENDIF

C-      SCRATCH.
        ELSE
          LUNFLG(LUN) = 3
        ENDIF

  100 CONTINUE

C--   PRINT NAMES OF NON-EMPTY OUTPUT FILES.
      IF (N) THEN
        CALL EMESS (' %')
        CALL EMESS ('OUTPUT FILES - %')
        DO 200 LUN = 1, NUN
          IF (LUNFLG(LUN).EQ.2) THEN
            WRITE (MBUF,10) FNAME(LUN)(1:LFNAME(LUN))
            CALL EMESS (MBUF)
          ENDIF
  200   CONTINUE
      ENDIF

C--   PRINT NAMES OF EMPTY OUTPUT FILES.
      IF (E) THEN
        CALL EMESS (' %')
        CALL EMESS ('OUTPUT FILES SPECIFIED BUT NOT USED -%')
        DO 300 LUN = 1, NUN
          IF (LUNFLG(LUN).EQ.4) THEN
            WRITE (MBUF,10) FNAME(LUN)(1:LFNAME(LUN))
            CALL EMESS (MBUF)
          ENDIF
  300   CONTINUE
      ENDIF

C--   CLOSE FILES.
      DO 400 LUN = 1, NUN
        IF (LUNFLG(LUN).LE.0) GOTO 400
        INQUIRE (UNIT=LUN, OPENED=O)
        IF (.NOT.O) GOTO 400
        IF (LUNFLG(LUN).LE.2) THEN
          CLOSE (UNIT=LUN)
        ELSE
          CLOSE (UNIT=LUN, STATUS='DELETE')
        ENDIF
  400 CONTINUE

      STOP ' '
      END
      SUBROUTINE WERROR (IPOINT, MBUF)                                      INOU

C* REVISED 17-DEC-93.
C* PRINTS WARNING MESSAGE.

C  IPOINT RECEIVES THE POSITION IN THE INPUT BUFFER AT WHICH THE ERROR
C   OCCURRED.
C  MBUF RECEIVES THE MESSAGE.

      CHARACTER*(*) MBUF

      COMMON /FMTXXX/ ITAB,LFOUT,LTXOUT,KCOLS,MAXWID
      COMMON /INPBUF/ IBUF
      CHARACTER*121 IBUF
      COMMON /INPXXX/ JBUF,JEDAT,IEOF,NINPUT
      COMMON /LUNXXX/ LUNI,LUNC,LUNT,LUNO,LUNP,LUNS,LUNS1,LUNE,LUNL,LUNB
      COMMON /SYMXXX/ BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH
      CHARACTER*1 BLANK,STOP,SEMIC,LBRAC,RBRAC,RANGE,STAR,UPAROW,
     *            COMMA,COLON,NUMERO,LABRAC,RABRAC,LBRACE,RBRACE,BSLSH

C     DIMENSION OF MTMP MUST BE SAME AS LENGTH OF IOUT IN /IOBUFX/
      CHARACTER MTMP*200                                                      =*

      L = LMESS (MBUF)
      IF (IPOINT.LE.0)  THEN
        CALL EMESS (MBUF(:L))
      ELSE
        DO I = 1, JEDAT
          IF (ICHAR(IBUF(I:I)).LT.32)  THEN
            CALL BADBUF(IPOINT, IBUF(1:JEDAT), JEDAT)
            GOTO 10
          ENDIF
        ENDDO
        CALL EMESS (IBUF(:JEDAT))
   10   MTMP = ' '
        MTMP(IPOINT:IPOINT) = UPAROW
        IF (L.LE.IPOINT-2) THEN
          MTMP(IPOINT-1-L:IPOINT-2) = MBUF(:L)
          CALL EMESS (MTMP(:IPOINT))
        ELSEIF (IPOINT+1+L.LE.MAXWID) THEN
          MTMP(IPOINT+2:) = MBUF(:L)
          CALL EMESS (MTMP(:IPOINT+1+L))
        ELSE
          CALL EMESS (MTMP(:IPOINT))
          CALL EMESS (MBUF(:L))
        ENDIF
      ENDIF

      RETURN
      END
      SUBROUTINE WRTREC (STR, LUN)                                          INOU

C* REVISED 26-MAR-99.
C* OUTPUTS A RECORD.

C  STR RECEIVES THE OUTPUT STRING.

      COMMON /LUOXXX/ NUN,LPRINT,LTOP,LUNCOM(10),LUNPRE(10),
     *  LUNUSE(13),LUNREC(13),LUNPAG(13)
 
      CHARACTER*(*) STR

      CALL LCOUNT (LUN)
      IF (LUNUSE(LUN).EQ.10)  THEN
        CALL WRECB (STR, LUN)
      ELSE
        CALL WREC (STR, LUN)
      ENDIF

  100 RETURN
      END
